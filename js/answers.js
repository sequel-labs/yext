var ANSWERS = (function () {
	'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var check = function (it) {
	  return it && it.Math == Math && it;
	};

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global_1 =
	  /* global globalThis -- safe */
	  check(typeof globalThis == 'object' && globalThis) ||
	  check(typeof window == 'object' && window) ||
	  check(typeof self == 'object' && self) ||
	  check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
	  // eslint-disable-next-line no-new-func -- fallback
	  (function () { return this; })() || Function('return this')();

	var fails = function (exec) {
	  try {
	    return !!exec();
	  } catch (error) {
	    return true;
	  }
	};

	// Detect IE8's incomplete defineProperty implementation
	var descriptors = !fails(function () {
	  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
	});

	var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
	var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// Nashorn ~ JDK8 bug
	var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

	// `Object.prototype.propertyIsEnumerable` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
	var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
	  var descriptor = getOwnPropertyDescriptor(this, V);
	  return !!descriptor && descriptor.enumerable;
	} : nativePropertyIsEnumerable;

	var objectPropertyIsEnumerable = {
		f: f
	};

	var createPropertyDescriptor = function (bitmap, value) {
	  return {
	    enumerable: !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable: !(bitmap & 4),
	    value: value
	  };
	};

	var toString = {}.toString;

	var classofRaw = function (it) {
	  return toString.call(it).slice(8, -1);
	};

	var split = ''.split;

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var indexedObject = fails(function () {
	  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  return !Object('z').propertyIsEnumerable(0);
	}) ? function (it) {
	  return classofRaw(it) == 'String' ? split.call(it, '') : Object(it);
	} : Object;

	// `RequireObjectCoercible` abstract operation
	// https://tc39.es/ecma262/#sec-requireobjectcoercible
	var requireObjectCoercible = function (it) {
	  if (it == undefined) throw TypeError("Can't call method on " + it);
	  return it;
	};

	// toObject with fallback for non-array-like ES3 strings



	var toIndexedObject = function (it) {
	  return indexedObject(requireObjectCoercible(it));
	};

	var isObject = function (it) {
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

	// `ToPrimitive` abstract operation
	// https://tc39.es/ecma262/#sec-toprimitive
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	var toPrimitive = function (input, PREFERRED_STRING) {
	  if (!isObject(input)) return input;
	  var fn, val;
	  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
	  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
	  throw TypeError("Can't convert object to primitive value");
	};

	var hasOwnProperty = {}.hasOwnProperty;

	var has = function (it, key) {
	  return hasOwnProperty.call(it, key);
	};

	var document$1 = global_1.document;
	// typeof document.createElement is 'object' in old IE
	var EXISTS = isObject(document$1) && isObject(document$1.createElement);

	var documentCreateElement = function (it) {
	  return EXISTS ? document$1.createElement(it) : {};
	};

	// Thank's IE8 for his funny defineProperty
	var ie8DomDefine = !descriptors && !fails(function () {
	  return Object.defineProperty(documentCreateElement('div'), 'a', {
	    get: function () { return 7; }
	  }).a != 7;
	});

	var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
	  O = toIndexedObject(O);
	  P = toPrimitive(P, true);
	  if (ie8DomDefine) try {
	    return nativeGetOwnPropertyDescriptor(O, P);
	  } catch (error) { /* empty */ }
	  if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
	};

	var objectGetOwnPropertyDescriptor = {
		f: f$1
	};

	var replacement = /#|\.prototype\./;

	var isForced = function (feature, detection) {
	  var value = data[normalize(feature)];
	  return value == POLYFILL ? true
	    : value == NATIVE ? false
	    : typeof detection == 'function' ? fails(detection)
	    : !!detection;
	};

	var normalize = isForced.normalize = function (string) {
	  return String(string).replace(replacement, '.').toLowerCase();
	};

	var data = isForced.data = {};
	var NATIVE = isForced.NATIVE = 'N';
	var POLYFILL = isForced.POLYFILL = 'P';

	var isForced_1 = isForced;

	var path = {};

	var aFunction = function (it) {
	  if (typeof it != 'function') {
	    throw TypeError(String(it) + ' is not a function');
	  } return it;
	};

	// optional / simple context binding
	var functionBindContext = function (fn, that, length) {
	  aFunction(fn);
	  if (that === undefined) return fn;
	  switch (length) {
	    case 0: return function () {
	      return fn.call(that);
	    };
	    case 1: return function (a) {
	      return fn.call(that, a);
	    };
	    case 2: return function (a, b) {
	      return fn.call(that, a, b);
	    };
	    case 3: return function (a, b, c) {
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function (/* ...args */) {
	    return fn.apply(that, arguments);
	  };
	};

	var anObject = function (it) {
	  if (!isObject(it)) {
	    throw TypeError(String(it) + ' is not an object');
	  } return it;
	};

	var nativeDefineProperty = Object.defineProperty;

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if (ie8DomDefine) try {
	    return nativeDefineProperty(O, P, Attributes);
	  } catch (error) { /* empty */ }
	  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
	  if ('value' in Attributes) O[P] = Attributes.value;
	  return O;
	};

	var objectDefineProperty = {
		f: f$2
	};

	var createNonEnumerableProperty = descriptors ? function (object, key, value) {
	  return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
	} : function (object, key, value) {
	  object[key] = value;
	  return object;
	};

	var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






	var wrapConstructor = function (NativeConstructor) {
	  var Wrapper = function (a, b, c) {
	    if (this instanceof NativeConstructor) {
	      switch (arguments.length) {
	        case 0: return new NativeConstructor();
	        case 1: return new NativeConstructor(a);
	        case 2: return new NativeConstructor(a, b);
	      } return new NativeConstructor(a, b, c);
	    } return NativeConstructor.apply(this, arguments);
	  };
	  Wrapper.prototype = NativeConstructor.prototype;
	  return Wrapper;
	};

	/*
	  options.target      - name of the target object
	  options.global      - target is the global object
	  options.stat        - export as static methods of target
	  options.proto       - export as prototype methods of target
	  options.real        - real prototype method for the `pure` version
	  options.forced      - export even if the native feature is available
	  options.bind        - bind methods to the target, required for the `pure` version
	  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
	  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
	  options.sham        - add a flag to not completely full polyfills
	  options.enumerable  - export as enumerable property
	  options.noTargetGet - prevent calling a getter on target
	*/
	var _export = function (options, source) {
	  var TARGET = options.target;
	  var GLOBAL = options.global;
	  var STATIC = options.stat;
	  var PROTO = options.proto;

	  var nativeSource = GLOBAL ? global_1 : STATIC ? global_1[TARGET] : (global_1[TARGET] || {}).prototype;

	  var target = GLOBAL ? path : path[TARGET] || (path[TARGET] = {});
	  var targetPrototype = target.prototype;

	  var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
	  var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;

	  for (key in source) {
	    FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
	    // contains in native
	    USE_NATIVE = !FORCED && nativeSource && has(nativeSource, key);

	    targetProperty = target[key];

	    if (USE_NATIVE) if (options.noTargetGet) {
	      descriptor = getOwnPropertyDescriptor$1(nativeSource, key);
	      nativeProperty = descriptor && descriptor.value;
	    } else nativeProperty = nativeSource[key];

	    // export native or implementation
	    sourceProperty = (USE_NATIVE && nativeProperty) ? nativeProperty : source[key];

	    if (USE_NATIVE && typeof targetProperty === typeof sourceProperty) continue;

	    // bind timers to global for call from export context
	    if (options.bind && USE_NATIVE) resultProperty = functionBindContext(sourceProperty, global_1);
	    // wrap global constructors for prevent changs in this version
	    else if (options.wrap && USE_NATIVE) resultProperty = wrapConstructor(sourceProperty);
	    // make static versions for prototype methods
	    else if (PROTO && typeof sourceProperty == 'function') resultProperty = functionBindContext(Function.call, sourceProperty);
	    // default case
	    else resultProperty = sourceProperty;

	    // add a flag to not completely full polyfills
	    if (options.sham || (sourceProperty && sourceProperty.sham) || (targetProperty && targetProperty.sham)) {
	      createNonEnumerableProperty(resultProperty, 'sham', true);
	    }

	    target[key] = resultProperty;

	    if (PROTO) {
	      VIRTUAL_PROTOTYPE = TARGET + 'Prototype';
	      if (!has(path, VIRTUAL_PROTOTYPE)) {
	        createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
	      }
	      // export virtual prototype methods
	      path[VIRTUAL_PROTOTYPE][key] = sourceProperty;
	      // export real prototype methods
	      if (options.real && targetPrototype && !targetPrototype[key]) {
	        createNonEnumerableProperty(targetPrototype, key, sourceProperty);
	      }
	    }
	  }
	};

	var aFunction$1 = function (variable) {
	  return typeof variable == 'function' ? variable : undefined;
	};

	var getBuiltIn = function (namespace, method) {
	  return arguments.length < 2 ? aFunction$1(path[namespace]) || aFunction$1(global_1[namespace])
	    : path[namespace] && path[namespace][method] || global_1[namespace] && global_1[namespace][method];
	};

	var engineUserAgent = getBuiltIn('navigator', 'userAgent') || '';

	var slice = [].slice;
	var MSIE = /MSIE .\./.test(engineUserAgent); // <- dirty ie9- check

	var wrap = function (scheduler) {
	  return function (handler, timeout /* , ...arguments */) {
	    var boundArgs = arguments.length > 2;
	    var args = boundArgs ? slice.call(arguments, 2) : undefined;
	    return scheduler(boundArgs ? function () {
	      // eslint-disable-next-line no-new-func -- spec requirement
	      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
	    } : handler, timeout);
	  };
	};

	// ie9- setTimeout & setInterval additional parameters fix
	// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
	_export({ global: true, bind: true, forced: MSIE }, {
	  // `setTimeout` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
	  setTimeout: wrap(global_1.setTimeout),
	  // `setInterval` method
	  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
	  setInterval: wrap(global_1.setInterval)
	});

	var setTimeout$1 = path.setTimeout;

	var setTimeout$2 = setTimeout$1;

	// a string of all valid unicode whitespaces
	var whitespaces = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002' +
	  '\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

	var whitespace = '[' + whitespaces + ']';
	var ltrim = RegExp('^' + whitespace + whitespace + '*');
	var rtrim = RegExp(whitespace + whitespace + '*$');

	// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
	var createMethod = function (TYPE) {
	  return function ($this) {
	    var string = String(requireObjectCoercible($this));
	    if (TYPE & 1) string = string.replace(ltrim, '');
	    if (TYPE & 2) string = string.replace(rtrim, '');
	    return string;
	  };
	};

	var stringTrim = {
	  // `String.prototype.{ trimLeft, trimStart }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimstart
	  start: createMethod(1),
	  // `String.prototype.{ trimRight, trimEnd }` methods
	  // https://tc39.es/ecma262/#sec-string.prototype.trimend
	  end: createMethod(2),
	  // `String.prototype.trim` method
	  // https://tc39.es/ecma262/#sec-string.prototype.trim
	  trim: createMethod(3)
	};

	var trim = stringTrim.trim;


	var $parseFloat = global_1.parseFloat;
	var FORCED = 1 / $parseFloat(whitespaces + '-0') !== -Infinity;

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	var numberParseFloat = FORCED ? function parseFloat(string) {
	  var trimmedString = trim(String(string));
	  var result = $parseFloat(trimmedString);
	  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
	} : $parseFloat;

	// `parseFloat` method
	// https://tc39.es/ecma262/#sec-parsefloat-string
	_export({ global: true, forced: parseFloat != numberParseFloat }, {
	  parseFloat: numberParseFloat
	});

	var _parseFloat = path.parseFloat;

	var _parseFloat$1 = _parseFloat;

	var _parseFloat$2 = _parseFloat$1;

	var slice$1 = [].slice;
	var factories = {};

	var construct = function (C, argsLength, args) {
	  if (!(argsLength in factories)) {
	    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
	    // eslint-disable-next-line no-new-func -- we have no proper alternatives, IE8- only
	    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
	  } return factories[argsLength](C, args);
	};

	// `Function.prototype.bind` method implementation
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	var functionBind = Function.bind || function bind(that /* , ...args */) {
	  var fn = aFunction(this);
	  var partArgs = slice$1.call(arguments, 1);
	  var boundFunction = function bound(/* args... */) {
	    var args = partArgs.concat(slice$1.call(arguments));
	    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
	  };
	  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
	  return boundFunction;
	};

	// `Function.prototype.bind` method
	// https://tc39.es/ecma262/#sec-function.prototype.bind
	_export({ target: 'Function', proto: true }, {
	  bind: functionBind
	});

	var entryVirtual = function (CONSTRUCTOR) {
	  return path[CONSTRUCTOR + 'Prototype'];
	};

	var bind = entryVirtual('Function').bind;

	var FunctionPrototype = Function.prototype;

	var bind_1 = function (it) {
	  var own = it.bind;
	  return it === FunctionPrototype || (it instanceof Function && own === FunctionPrototype.bind) ? bind : own;
	};

	var bind$1 = bind_1;

	var bind$2 = bind$1;

	var $stringify = getBuiltIn('JSON', 'stringify');
	var re = /[\uD800-\uDFFF]/g;
	var low = /^[\uD800-\uDBFF]$/;
	var hi = /^[\uDC00-\uDFFF]$/;

	var fix = function (match, offset, string) {
	  var prev = string.charAt(offset - 1);
	  var next = string.charAt(offset + 1);
	  if ((low.test(match) && !hi.test(next)) || (hi.test(match) && !low.test(prev))) {
	    return '\\u' + match.charCodeAt(0).toString(16);
	  } return match;
	};

	var FORCED$1 = fails(function () {
	  return $stringify('\uDF06\uD834') !== '"\\udf06\\ud834"'
	    || $stringify('\uDEAD') !== '"\\udead"';
	});

	if ($stringify) {
	  // `JSON.stringify` method
	  // https://tc39.es/ecma262/#sec-json.stringify
	  // https://github.com/tc39/proposal-well-formed-stringify
	  _export({ target: 'JSON', stat: true, forced: FORCED$1 }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      var result = $stringify.apply(null, arguments);
	      return typeof result == 'string' ? result.replace(re, fix) : result;
	    }
	  });
	}

	if (!path.JSON) path.JSON = { stringify: JSON.stringify };

	// eslint-disable-next-line no-unused-vars -- required for `.length`
	var stringify = function stringify(it, replacer, space) {
	  return path.JSON.stringify.apply(null, arguments);
	};

	var stringify$1 = stringify;

	var stringify$2 = stringify$1;

	var ceil = Math.ceil;
	var floor = Math.floor;

	// `ToInteger` abstract operation
	// https://tc39.es/ecma262/#sec-tointeger
	var toInteger = function (argument) {
	  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
	};

	// `String.prototype.{ codePointAt, at }` methods implementation
	var createMethod$1 = function (CONVERT_TO_STRING) {
	  return function ($this, pos) {
	    var S = String(requireObjectCoercible($this));
	    var position = toInteger(pos);
	    var size = S.length;
	    var first, second;
	    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
	    first = S.charCodeAt(position);
	    return first < 0xD800 || first > 0xDBFF || position + 1 === size
	      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
	        ? CONVERT_TO_STRING ? S.charAt(position) : first
	        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
	  };
	};

	var stringMultibyte = {
	  // `String.prototype.codePointAt` method
	  // https://tc39.es/ecma262/#sec-string.prototype.codepointat
	  codeAt: createMethod$1(false),
	  // `String.prototype.at` method
	  // https://github.com/mathiasbynens/String.prototype.at
	  charAt: createMethod$1(true)
	};

	var setGlobal = function (key, value) {
	  try {
	    createNonEnumerableProperty(global_1, key, value);
	  } catch (error) {
	    global_1[key] = value;
	  } return value;
	};

	var SHARED = '__core-js_shared__';
	var store = global_1[SHARED] || setGlobal(SHARED, {});

	var sharedStore = store;

	var functionToString = Function.toString;

	// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
	if (typeof sharedStore.inspectSource != 'function') {
	  sharedStore.inspectSource = function (it) {
	    return functionToString.call(it);
	  };
	}

	var inspectSource = sharedStore.inspectSource;

	var WeakMap = global_1.WeakMap;

	var nativeWeakMap = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));

	var isPure = true;

	var shared = createCommonjsModule(function (module) {
	(module.exports = function (key, value) {
	  return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
	})('versions', []).push({
	  version: '3.9.1',
	  mode:  'pure' ,
	  copyright: '© 2021 Denis Pushkarev (zloirock.ru)'
	});
	});

	var id = 0;
	var postfix = Math.random();

	var uid = function (key) {
	  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
	};

	var keys = shared('keys');

	var sharedKey = function (key) {
	  return keys[key] || (keys[key] = uid(key));
	};

	var hiddenKeys = {};

	var WeakMap$1 = global_1.WeakMap;
	var set, get, has$1;

	var enforce = function (it) {
	  return has$1(it) ? get(it) : set(it, {});
	};

	var getterFor = function (TYPE) {
	  return function (it) {
	    var state;
	    if (!isObject(it) || (state = get(it)).type !== TYPE) {
	      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
	    } return state;
	  };
	};

	if (nativeWeakMap) {
	  var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());
	  var wmget = store$1.get;
	  var wmhas = store$1.has;
	  var wmset = store$1.set;
	  set = function (it, metadata) {
	    metadata.facade = it;
	    wmset.call(store$1, it, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return wmget.call(store$1, it) || {};
	  };
	  has$1 = function (it) {
	    return wmhas.call(store$1, it);
	  };
	} else {
	  var STATE = sharedKey('state');
	  hiddenKeys[STATE] = true;
	  set = function (it, metadata) {
	    metadata.facade = it;
	    createNonEnumerableProperty(it, STATE, metadata);
	    return metadata;
	  };
	  get = function (it) {
	    return has(it, STATE) ? it[STATE] : {};
	  };
	  has$1 = function (it) {
	    return has(it, STATE);
	  };
	}

	var internalState = {
	  set: set,
	  get: get,
	  has: has$1,
	  enforce: enforce,
	  getterFor: getterFor
	};

	// `ToObject` abstract operation
	// https://tc39.es/ecma262/#sec-toobject
	var toObject = function (argument) {
	  return Object(requireObjectCoercible(argument));
	};

	var correctPrototypeGetter = !fails(function () {
	  function F() { /* empty */ }
	  F.prototype.constructor = null;
	  return Object.getPrototypeOf(new F()) !== F.prototype;
	});

	var IE_PROTO = sharedKey('IE_PROTO');
	var ObjectPrototype = Object.prototype;

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	var objectGetPrototypeOf = correctPrototypeGetter ? Object.getPrototypeOf : function (O) {
	  O = toObject(O);
	  if (has(O, IE_PROTO)) return O[IE_PROTO];
	  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectPrototype : null;
	};

	var engineIsNode = classofRaw(global_1.process) == 'process';

	var process = global_1.process;
	var versions = process && process.versions;
	var v8 = versions && versions.v8;
	var match, version;

	if (v8) {
	  match = v8.split('.');
	  version = match[0] + match[1];
	} else if (engineUserAgent) {
	  match = engineUserAgent.match(/Edge\/(\d+)/);
	  if (!match || match[1] >= 74) {
	    match = engineUserAgent.match(/Chrome\/(\d+)/);
	    if (match) version = match[1];
	  }
	}

	var engineV8Version = version && +version;

	var nativeSymbol = !!Object.getOwnPropertySymbols && !fails(function () {
	  /* global Symbol -- required for testing */
	  return !Symbol.sham &&
	    // Chrome 38 Symbol has incorrect toString conversion
	    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
	    (engineIsNode ? engineV8Version === 38 : engineV8Version > 37 && engineV8Version < 41);
	});

	var useSymbolAsUid = nativeSymbol
	  /* global Symbol -- safe */
	  && !Symbol.sham
	  && typeof Symbol.iterator == 'symbol';

	var WellKnownSymbolsStore = shared('wks');
	var Symbol$1 = global_1.Symbol;
	var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

	var wellKnownSymbol = function (name) {
	  if (!has(WellKnownSymbolsStore, name) || !(nativeSymbol || typeof WellKnownSymbolsStore[name] == 'string')) {
	    if (nativeSymbol && has(Symbol$1, name)) {
	      WellKnownSymbolsStore[name] = Symbol$1[name];
	    } else {
	      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
	    }
	  } return WellKnownSymbolsStore[name];
	};

	var ITERATOR = wellKnownSymbol('iterator');
	var BUGGY_SAFARI_ITERATORS = false;

	var returnThis = function () { return this; };

	// `%IteratorPrototype%` object
	// https://tc39.es/ecma262/#sec-%iteratorprototype%-object
	var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

	if ([].keys) {
	  arrayIterator = [].keys();
	  // Safari 8 has buggy iterators w/o `next`
	  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
	  else {
	    PrototypeOfArrayIteratorPrototype = objectGetPrototypeOf(objectGetPrototypeOf(arrayIterator));
	    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
	  }
	}

	var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == undefined || fails(function () {
	  var test = {};
	  // FF44- legacy iterators case
	  return IteratorPrototype[ITERATOR].call(test) !== test;
	});

	if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};

	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	if (( NEW_ITERATOR_PROTOTYPE) && !has(IteratorPrototype, ITERATOR)) {
	  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
	}

	var iteratorsCore = {
	  IteratorPrototype: IteratorPrototype,
	  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
	};

	var min = Math.min;

	// `ToLength` abstract operation
	// https://tc39.es/ecma262/#sec-tolength
	var toLength = function (argument) {
	  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
	};

	var max = Math.max;
	var min$1 = Math.min;

	// Helper for a popular repeating case of the spec:
	// Let integer be ? ToInteger(index).
	// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
	var toAbsoluteIndex = function (index, length) {
	  var integer = toInteger(index);
	  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
	};

	// `Array.prototype.{ indexOf, includes }` methods implementation
	var createMethod$2 = function (IS_INCLUDES) {
	  return function ($this, el, fromIndex) {
	    var O = toIndexedObject($this);
	    var length = toLength(O.length);
	    var index = toAbsoluteIndex(fromIndex, length);
	    var value;
	    // Array#includes uses SameValueZero equality algorithm
	    // eslint-disable-next-line no-self-compare -- NaN check
	    if (IS_INCLUDES && el != el) while (length > index) {
	      value = O[index++];
	      // eslint-disable-next-line no-self-compare -- NaN check
	      if (value != value) return true;
	    // Array#indexOf ignores holes, Array#includes - not
	    } else for (;length > index; index++) {
	      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

	var arrayIncludes = {
	  // `Array.prototype.includes` method
	  // https://tc39.es/ecma262/#sec-array.prototype.includes
	  includes: createMethod$2(true),
	  // `Array.prototype.indexOf` method
	  // https://tc39.es/ecma262/#sec-array.prototype.indexof
	  indexOf: createMethod$2(false)
	};

	var indexOf = arrayIncludes.indexOf;


	var objectKeysInternal = function (object, names) {
	  var O = toIndexedObject(object);
	  var i = 0;
	  var result = [];
	  var key;
	  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while (names.length > i) if (has(O, key = names[i++])) {
	    ~indexOf(result, key) || result.push(key);
	  }
	  return result;
	};

	// IE8- don't enum bug keys
	var enumBugKeys = [
	  'constructor',
	  'hasOwnProperty',
	  'isPrototypeOf',
	  'propertyIsEnumerable',
	  'toLocaleString',
	  'toString',
	  'valueOf'
	];

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	var objectKeys = Object.keys || function keys(O) {
	  return objectKeysInternal(O, enumBugKeys);
	};

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
	  anObject(O);
	  var keys = objectKeys(Properties);
	  var length = keys.length;
	  var index = 0;
	  var key;
	  while (length > index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
	  return O;
	};

	var html = getBuiltIn('document', 'documentElement');

	var GT = '>';
	var LT = '<';
	var PROTOTYPE = 'prototype';
	var SCRIPT = 'script';
	var IE_PROTO$1 = sharedKey('IE_PROTO');

	var EmptyConstructor = function () { /* empty */ };

	var scriptTag = function (content) {
	  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
	};

	// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
	var NullProtoObjectViaActiveX = function (activeXDocument) {
	  activeXDocument.write(scriptTag(''));
	  activeXDocument.close();
	  var temp = activeXDocument.parentWindow.Object;
	  activeXDocument = null; // avoid memory leak
	  return temp;
	};

	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var NullProtoObjectViaIFrame = function () {
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = documentCreateElement('iframe');
	  var JS = 'java' + SCRIPT + ':';
	  var iframeDocument;
	  iframe.style.display = 'none';
	  html.appendChild(iframe);
	  // https://github.com/zloirock/core-js/issues/475
	  iframe.src = String(JS);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(scriptTag('document.F=Object'));
	  iframeDocument.close();
	  return iframeDocument.F;
	};

	// Check for document.domain and active x support
	// No need to use active x approach when document.domain is not set
	// see https://github.com/es-shims/es5-shim/issues/150
	// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
	// avoid IE GC bug
	var activeXDocument;
	var NullProtoObject = function () {
	  try {
	    /* global ActiveXObject -- old IE */
	    activeXDocument = document.domain && new ActiveXObject('htmlfile');
	  } catch (error) { /* ignore */ }
	  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
	  var length = enumBugKeys.length;
	  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
	  return NullProtoObject();
	};

	hiddenKeys[IE_PROTO$1] = true;

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	var objectCreate = Object.create || function create(O, Properties) {
	  var result;
	  if (O !== null) {
	    EmptyConstructor[PROTOTYPE] = anObject(O);
	    result = new EmptyConstructor();
	    EmptyConstructor[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO$1] = O;
	  } else result = NullProtoObject();
	  return Properties === undefined ? result : objectDefineProperties(result, Properties);
	};

	var TO_STRING_TAG = wellKnownSymbol('toStringTag');
	var test = {};

	test[TO_STRING_TAG] = 'z';

	var toStringTagSupport = String(test) === '[object z]';

	var TO_STRING_TAG$1 = wellKnownSymbol('toStringTag');
	// ES3 wrong here
	var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

	// fallback for IE11 Script Access Denied error
	var tryGet = function (it, key) {
	  try {
	    return it[key];
	  } catch (error) { /* empty */ }
	};

	// getting tag from ES6+ `Object.prototype.toString`
	var classof = toStringTagSupport ? classofRaw : function (it) {
	  var O, tag, result;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == 'string' ? tag
	    // builtinTag case
	    : CORRECT_ARGUMENTS ? classofRaw(O)
	    // ES3 arguments fallback
	    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
	};

	// `Object.prototype.toString` method implementation
	// https://tc39.es/ecma262/#sec-object.prototype.tostring
	var objectToString = toStringTagSupport ? {}.toString : function toString() {
	  return '[object ' + classof(this) + ']';
	};

	var defineProperty = objectDefineProperty.f;





	var TO_STRING_TAG$2 = wellKnownSymbol('toStringTag');

	var setToStringTag = function (it, TAG, STATIC, SET_METHOD) {
	  if (it) {
	    var target = STATIC ? it : it.prototype;
	    if (!has(target, TO_STRING_TAG$2)) {
	      defineProperty(target, TO_STRING_TAG$2, { configurable: true, value: TAG });
	    }
	    if (SET_METHOD && !toStringTagSupport) {
	      createNonEnumerableProperty(target, 'toString', objectToString);
	    }
	  }
	};

	var iterators = {};

	var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;





	var returnThis$1 = function () { return this; };

	var createIteratorConstructor = function (IteratorConstructor, NAME, next) {
	  var TO_STRING_TAG = NAME + ' Iterator';
	  IteratorConstructor.prototype = objectCreate(IteratorPrototype$1, { next: createPropertyDescriptor(1, next) });
	  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
	  iterators[TO_STRING_TAG] = returnThis$1;
	  return IteratorConstructor;
	};

	var aPossiblePrototype = function (it) {
	  if (!isObject(it) && it !== null) {
	    throw TypeError("Can't set " + String(it) + ' as a prototype');
	  } return it;
	};

	/* eslint-disable no-proto -- safe */



	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	// Works with __proto__ only. Old v8 can't work with null proto objects.
	var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function () {
	  var CORRECT_SETTER = false;
	  var test = {};
	  var setter;
	  try {
	    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
	    setter.call(test, []);
	    CORRECT_SETTER = test instanceof Array;
	  } catch (error) { /* empty */ }
	  return function setPrototypeOf(O, proto) {
	    anObject(O);
	    aPossiblePrototype(proto);
	    if (CORRECT_SETTER) setter.call(O, proto);
	    else O.__proto__ = proto;
	    return O;
	  };
	}() : undefined);

	var redefine = function (target, key, value, options) {
	  if (options && options.enumerable) target[key] = value;
	  else createNonEnumerableProperty(target, key, value);
	};

	var IteratorPrototype$2 = iteratorsCore.IteratorPrototype;
	var BUGGY_SAFARI_ITERATORS$1 = iteratorsCore.BUGGY_SAFARI_ITERATORS;
	var ITERATOR$1 = wellKnownSymbol('iterator');
	var KEYS = 'keys';
	var VALUES = 'values';
	var ENTRIES = 'entries';

	var returnThis$2 = function () { return this; };

	var defineIterator = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
	  createIteratorConstructor(IteratorConstructor, NAME, next);

	  var getIterationMethod = function (KIND) {
	    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
	    if (!BUGGY_SAFARI_ITERATORS$1 && KIND in IterablePrototype) return IterablePrototype[KIND];
	    switch (KIND) {
	      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
	      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
	      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
	    } return function () { return new IteratorConstructor(this); };
	  };

	  var TO_STRING_TAG = NAME + ' Iterator';
	  var INCORRECT_VALUES_NAME = false;
	  var IterablePrototype = Iterable.prototype;
	  var nativeIterator = IterablePrototype[ITERATOR$1]
	    || IterablePrototype['@@iterator']
	    || DEFAULT && IterablePrototype[DEFAULT];
	  var defaultIterator = !BUGGY_SAFARI_ITERATORS$1 && nativeIterator || getIterationMethod(DEFAULT);
	  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
	  var CurrentIteratorPrototype, methods, KEY;

	  // fix native
	  if (anyNativeIterator) {
	    CurrentIteratorPrototype = objectGetPrototypeOf(anyNativeIterator.call(new Iterable()));
	    if (IteratorPrototype$2 !== Object.prototype && CurrentIteratorPrototype.next) {
	      // Set @@toStringTag to native iterators
	      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
	      iterators[TO_STRING_TAG] = returnThis$2;
	    }
	  }

	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
	    INCORRECT_VALUES_NAME = true;
	    defaultIterator = function values() { return nativeIterator.call(this); };
	  }

	  // define iterator
	  if (( FORCED) && IterablePrototype[ITERATOR$1] !== defaultIterator) {
	    createNonEnumerableProperty(IterablePrototype, ITERATOR$1, defaultIterator);
	  }
	  iterators[NAME] = defaultIterator;

	  // export additional methods
	  if (DEFAULT) {
	    methods = {
	      values: getIterationMethod(VALUES),
	      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
	      entries: getIterationMethod(ENTRIES)
	    };
	    if (FORCED) for (KEY in methods) {
	      if (BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
	        redefine(IterablePrototype, KEY, methods[KEY]);
	      }
	    } else _export({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS$1 || INCORRECT_VALUES_NAME }, methods);
	  }

	  return methods;
	};

	var charAt = stringMultibyte.charAt;



	var STRING_ITERATOR = 'String Iterator';
	var setInternalState = internalState.set;
	var getInternalState = internalState.getterFor(STRING_ITERATOR);

	// `String.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-string.prototype-@@iterator
	defineIterator(String, 'String', function (iterated) {
	  setInternalState(this, {
	    type: STRING_ITERATOR,
	    string: String(iterated),
	    index: 0
	  });
	// `%StringIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%stringiteratorprototype%.next
	}, function next() {
	  var state = getInternalState(this);
	  var string = state.string;
	  var index = state.index;
	  var point;
	  if (index >= string.length) return { value: undefined, done: true };
	  point = charAt(string, index);
	  state.index += point.length;
	  return { value: point, done: false };
	});

	var ITERATOR$2 = wellKnownSymbol('iterator');

	var nativeUrl = !fails(function () {
	  var url = new URL('b?a=1&b=2&c=3', 'http://a');
	  var searchParams = url.searchParams;
	  var result = '';
	  url.pathname = 'c%20d';
	  searchParams.forEach(function (value, key) {
	    searchParams['delete']('b');
	    result += key + value;
	  });
	  return (isPure && !url.toJSON)
	    || !searchParams.sort
	    || url.href !== 'http://a/c%20d?a=1&c=3'
	    || searchParams.get('c') !== '3'
	    || String(new URLSearchParams('?a=1')) !== 'a=1'
	    || !searchParams[ITERATOR$2]
	    // throws in Edge
	    || new URL('https://a@b').username !== 'a'
	    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
	    // not punycoded in Edge
	    || new URL('http://тест').host !== 'xn--e1aybc'
	    // not escaped in Chrome 62-
	    || new URL('http://a#б').hash !== '#%D0%B1'
	    // fails in Chrome 66-
	    || result !== 'a1c3'
	    // throws in Safari
	    || new URL('http://x', undefined).host !== 'x';
	});

	var anInstance = function (it, Constructor, name) {
	  if (!(it instanceof Constructor)) {
	    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
	  } return it;
	};

	var f$3 = Object.getOwnPropertySymbols;

	var objectGetOwnPropertySymbols = {
		f: f$3
	};

	var nativeAssign = Object.assign;
	var defineProperty$1 = Object.defineProperty;

	// `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign
	var objectAssign = !nativeAssign || fails(function () {
	  // should have correct order of operations (Edge bug)
	  if (descriptors && nativeAssign({ b: 1 }, nativeAssign(defineProperty$1({}, 'a', {
	    enumerable: true,
	    get: function () {
	      defineProperty$1(this, 'b', {
	        value: 3,
	        enumerable: false
	      });
	    }
	  }), { b: 2 })).b !== 1) return true;
	  // should work with symbols and should have deterministic property order (V8 bug)
	  var A = {};
	  var B = {};
	  /* global Symbol -- required for testing */
	  var symbol = Symbol();
	  var alphabet = 'abcdefghijklmnopqrst';
	  A[symbol] = 7;
	  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
	  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
	}) ? function assign(target, source) { // eslint-disable-line no-unused-vars -- required for `.length`
	  var T = toObject(target);
	  var argumentsLength = arguments.length;
	  var index = 1;
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  var propertyIsEnumerable = objectPropertyIsEnumerable.f;
	  while (argumentsLength > index) {
	    var S = indexedObject(arguments[index++]);
	    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
	    var length = keys.length;
	    var j = 0;
	    var key;
	    while (length > j) {
	      key = keys[j++];
	      if (!descriptors || propertyIsEnumerable.call(S, key)) T[key] = S[key];
	    }
	  } return T;
	} : nativeAssign;

	var iteratorClose = function (iterator) {
	  var returnMethod = iterator['return'];
	  if (returnMethod !== undefined) {
	    return anObject(returnMethod.call(iterator)).value;
	  }
	};

	// call something on iterator step with safe closing on error
	var callWithSafeIterationClosing = function (iterator, fn, value, ENTRIES) {
	  try {
	    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch (error) {
	    iteratorClose(iterator);
	    throw error;
	  }
	};

	var ITERATOR$3 = wellKnownSymbol('iterator');
	var ArrayPrototype = Array.prototype;

	// check on default Array iterator
	var isArrayIteratorMethod = function (it) {
	  return it !== undefined && (iterators.Array === it || ArrayPrototype[ITERATOR$3] === it);
	};

	var createProperty = function (object, key, value) {
	  var propertyKey = toPrimitive(key);
	  if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
	  else object[propertyKey] = value;
	};

	var ITERATOR$4 = wellKnownSymbol('iterator');

	var getIteratorMethod = function (it) {
	  if (it != undefined) return it[ITERATOR$4]
	    || it['@@iterator']
	    || iterators[classof(it)];
	};

	// `Array.from` method implementation
	// https://tc39.es/ecma262/#sec-array.from
	var arrayFrom = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
	  var O = toObject(arrayLike);
	  var C = typeof this == 'function' ? this : Array;
	  var argumentsLength = arguments.length;
	  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
	  var mapping = mapfn !== undefined;
	  var iteratorMethod = getIteratorMethod(O);
	  var index = 0;
	  var length, result, step, iterator, next, value;
	  if (mapping) mapfn = functionBindContext(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
	  // if the target is not iterable or it's an array with the default iterator - use a simple case
	  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
	    iterator = iteratorMethod.call(O);
	    next = iterator.next;
	    result = new C();
	    for (;!(step = next.call(iterator)).done; index++) {
	      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
	      createProperty(result, index, value);
	    }
	  } else {
	    length = toLength(O.length);
	    result = new C(length);
	    for (;length > index; index++) {
	      value = mapping ? mapfn(O[index], index) : O[index];
	      createProperty(result, index, value);
	    }
	  }
	  result.length = index;
	  return result;
	};

	// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
	var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
	var base = 36;
	var tMin = 1;
	var tMax = 26;
	var skew = 38;
	var damp = 700;
	var initialBias = 72;
	var initialN = 128; // 0x80
	var delimiter = '-'; // '\x2D'
	var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
	var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
	var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
	var baseMinusTMin = base - tMin;
	var floor$1 = Math.floor;
	var stringFromCharCode = String.fromCharCode;

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 */
	var ucs2decode = function (string) {
	  var output = [];
	  var counter = 0;
	  var length = string.length;
	  while (counter < length) {
	    var value = string.charCodeAt(counter++);
	    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	      // It's a high surrogate, and there is a next character.
	      var extra = string.charCodeAt(counter++);
	      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
	        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	      } else {
	        // It's an unmatched surrogate; only append this code unit, in case the
	        // next code unit is the high surrogate of a surrogate pair.
	        output.push(value);
	        counter--;
	      }
	    } else {
	      output.push(value);
	    }
	  }
	  return output;
	};

	/**
	 * Converts a digit/integer into a basic code point.
	 */
	var digitToBasic = function (digit) {
	  //  0..25 map to ASCII a..z or A..Z
	  // 26..35 map to ASCII 0..9
	  return digit + 22 + 75 * (digit < 26);
	};

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 */
	var adapt = function (delta, numPoints, firstTime) {
	  var k = 0;
	  delta = firstTime ? floor$1(delta / damp) : delta >> 1;
	  delta += floor$1(delta / numPoints);
	  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
	    delta = floor$1(delta / baseMinusTMin);
	  }
	  return floor$1(k + (baseMinusTMin + 1) * delta / (delta + skew));
	};

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 */
	// eslint-disable-next-line max-statements -- TODO
	var encode = function (input) {
	  var output = [];

	  // Convert the input in UCS-2 to an array of Unicode code points.
	  input = ucs2decode(input);

	  // Cache the length.
	  var inputLength = input.length;

	  // Initialize the state.
	  var n = initialN;
	  var delta = 0;
	  var bias = initialBias;
	  var i, currentValue;

	  // Handle the basic code points.
	  for (i = 0; i < input.length; i++) {
	    currentValue = input[i];
	    if (currentValue < 0x80) {
	      output.push(stringFromCharCode(currentValue));
	    }
	  }

	  var basicLength = output.length; // number of basic code points.
	  var handledCPCount = basicLength; // number of code points that have been handled;

	  // Finish the basic string with a delimiter unless it's empty.
	  if (basicLength) {
	    output.push(delimiter);
	  }

	  // Main encoding loop:
	  while (handledCPCount < inputLength) {
	    // All non-basic code points < n have been handled already. Find the next larger one:
	    var m = maxInt;
	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue >= n && currentValue < m) {
	        m = currentValue;
	      }
	    }

	    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
	    var handledCPCountPlusOne = handledCPCount + 1;
	    if (m - n > floor$1((maxInt - delta) / handledCPCountPlusOne)) {
	      throw RangeError(OVERFLOW_ERROR);
	    }

	    delta += (m - n) * handledCPCountPlusOne;
	    n = m;

	    for (i = 0; i < input.length; i++) {
	      currentValue = input[i];
	      if (currentValue < n && ++delta > maxInt) {
	        throw RangeError(OVERFLOW_ERROR);
	      }
	      if (currentValue == n) {
	        // Represent delta as a generalized variable-length integer.
	        var q = delta;
	        for (var k = base; /* no condition */; k += base) {
	          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	          if (q < t) break;
	          var qMinusT = q - t;
	          var baseMinusT = base - t;
	          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
	          q = floor$1(qMinusT / baseMinusT);
	        }

	        output.push(stringFromCharCode(digitToBasic(q)));
	        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	        delta = 0;
	        ++handledCPCount;
	      }
	    }

	    ++delta;
	    ++n;
	  }
	  return output.join('');
	};

	var stringPunycodeToAscii = function (input) {
	  var encoded = [];
	  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
	  var i, label;
	  for (i = 0; i < labels.length; i++) {
	    label = labels[i];
	    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
	  }
	  return encoded.join('.');
	};

	var ARRAY_ITERATOR = 'Array Iterator';
	var setInternalState$1 = internalState.set;
	var getInternalState$1 = internalState.getterFor(ARRAY_ITERATOR);

	// `Array.prototype.entries` method
	// https://tc39.es/ecma262/#sec-array.prototype.entries
	// `Array.prototype.keys` method
	// https://tc39.es/ecma262/#sec-array.prototype.keys
	// `Array.prototype.values` method
	// https://tc39.es/ecma262/#sec-array.prototype.values
	// `Array.prototype[@@iterator]` method
	// https://tc39.es/ecma262/#sec-array.prototype-@@iterator
	// `CreateArrayIterator` internal method
	// https://tc39.es/ecma262/#sec-createarrayiterator
	var es_array_iterator = defineIterator(Array, 'Array', function (iterated, kind) {
	  setInternalState$1(this, {
	    type: ARRAY_ITERATOR,
	    target: toIndexedObject(iterated), // target
	    index: 0,                          // next index
	    kind: kind                         // kind
	  });
	// `%ArrayIteratorPrototype%.next` method
	// https://tc39.es/ecma262/#sec-%arrayiteratorprototype%.next
	}, function () {
	  var state = getInternalState$1(this);
	  var target = state.target;
	  var kind = state.kind;
	  var index = state.index++;
	  if (!target || index >= target.length) {
	    state.target = undefined;
	    return { value: undefined, done: true };
	  }
	  if (kind == 'keys') return { value: index, done: false };
	  if (kind == 'values') return { value: target[index], done: false };
	  return { value: [index, target[index]], done: false };
	}, 'values');

	// argumentsList[@@iterator] is %ArrayProto_values%
	// https://tc39.es/ecma262/#sec-createunmappedargumentsobject
	// https://tc39.es/ecma262/#sec-createmappedargumentsobject
	iterators.Arguments = iterators.Array;

	var redefineAll = function (target, src, options) {
	  for (var key in src) {
	    if (options && options.unsafe && target[key]) target[key] = src[key];
	    else redefine(target, key, src[key], options);
	  } return target;
	};

	var getIterator = function (it) {
	  var iteratorMethod = getIteratorMethod(it);
	  if (typeof iteratorMethod != 'function') {
	    throw TypeError(String(it) + ' is not iterable');
	  } return anObject(iteratorMethod.call(it));
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`





















	var $fetch = getBuiltIn('fetch');
	var Headers = getBuiltIn('Headers');
	var ITERATOR$5 = wellKnownSymbol('iterator');
	var URL_SEARCH_PARAMS = 'URLSearchParams';
	var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
	var setInternalState$2 = internalState.set;
	var getInternalParamsState = internalState.getterFor(URL_SEARCH_PARAMS);
	var getInternalIteratorState = internalState.getterFor(URL_SEARCH_PARAMS_ITERATOR);

	var plus = /\+/g;
	var sequences = Array(4);

	var percentSequence = function (bytes) {
	  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
	};

	var percentDecode = function (sequence) {
	  try {
	    return decodeURIComponent(sequence);
	  } catch (error) {
	    return sequence;
	  }
	};

	var deserialize = function (it) {
	  var result = it.replace(plus, ' ');
	  var bytes = 4;
	  try {
	    return decodeURIComponent(result);
	  } catch (error) {
	    while (bytes) {
	      result = result.replace(percentSequence(bytes--), percentDecode);
	    }
	    return result;
	  }
	};

	var find = /[!'()~]|%20/g;

	var replace = {
	  '!': '%21',
	  "'": '%27',
	  '(': '%28',
	  ')': '%29',
	  '~': '%7E',
	  '%20': '+'
	};

	var replacer = function (match) {
	  return replace[match];
	};

	var serialize = function (it) {
	  return encodeURIComponent(it).replace(find, replacer);
	};

	var parseSearchParams = function (result, query) {
	  if (query) {
	    var attributes = query.split('&');
	    var index = 0;
	    var attribute, entry;
	    while (index < attributes.length) {
	      attribute = attributes[index++];
	      if (attribute.length) {
	        entry = attribute.split('=');
	        result.push({
	          key: deserialize(entry.shift()),
	          value: deserialize(entry.join('='))
	        });
	      }
	    }
	  }
	};

	var updateSearchParams = function (query) {
	  this.entries.length = 0;
	  parseSearchParams(this.entries, query);
	};

	var validateArgumentsLength = function (passed, required) {
	  if (passed < required) throw TypeError('Not enough arguments');
	};

	var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
	  setInternalState$2(this, {
	    type: URL_SEARCH_PARAMS_ITERATOR,
	    iterator: getIterator(getInternalParamsState(params).entries),
	    kind: kind
	  });
	}, 'Iterator', function next() {
	  var state = getInternalIteratorState(this);
	  var kind = state.kind;
	  var step = state.iterator.next();
	  var entry = step.value;
	  if (!step.done) {
	    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
	  } return step;
	});

	// `URLSearchParams` constructor
	// https://url.spec.whatwg.org/#interface-urlsearchparams
	var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
	  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
	  var init = arguments.length > 0 ? arguments[0] : undefined;
	  var that = this;
	  var entries = [];
	  var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;

	  setInternalState$2(that, {
	    type: URL_SEARCH_PARAMS,
	    entries: entries,
	    updateURL: function () { /* empty */ },
	    updateSearchParams: updateSearchParams
	  });

	  if (init !== undefined) {
	    if (isObject(init)) {
	      iteratorMethod = getIteratorMethod(init);
	      if (typeof iteratorMethod === 'function') {
	        iterator = iteratorMethod.call(init);
	        next = iterator.next;
	        while (!(step = next.call(iterator)).done) {
	          entryIterator = getIterator(anObject(step.value));
	          entryNext = entryIterator.next;
	          if (
	            (first = entryNext.call(entryIterator)).done ||
	            (second = entryNext.call(entryIterator)).done ||
	            !entryNext.call(entryIterator).done
	          ) throw TypeError('Expected sequence with length 2');
	          entries.push({ key: first.value + '', value: second.value + '' });
	        }
	      } else for (key in init) if (has(init, key)) entries.push({ key: key, value: init[key] + '' });
	    } else {
	      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
	    }
	  }
	};

	var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

	redefineAll(URLSearchParamsPrototype, {
	  // `URLSearchParams.prototype.append` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
	  append: function append(name, value) {
	    validateArgumentsLength(arguments.length, 2);
	    var state = getInternalParamsState(this);
	    state.entries.push({ key: name + '', value: value + '' });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.delete` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
	  'delete': function (name) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index].key === key) entries.splice(index, 1);
	      else index++;
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.get` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
	  get: function get(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) return entries[index].value;
	    }
	    return null;
	  },
	  // `URLSearchParams.prototype.getAll` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
	  getAll: function getAll(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var result = [];
	    var index = 0;
	    for (; index < entries.length; index++) {
	      if (entries[index].key === key) result.push(entries[index].value);
	    }
	    return result;
	  },
	  // `URLSearchParams.prototype.has` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
	  has: function has(name) {
	    validateArgumentsLength(arguments.length, 1);
	    var entries = getInternalParamsState(this).entries;
	    var key = name + '';
	    var index = 0;
	    while (index < entries.length) {
	      if (entries[index++].key === key) return true;
	    }
	    return false;
	  },
	  // `URLSearchParams.prototype.set` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
	  set: function set(name, value) {
	    validateArgumentsLength(arguments.length, 1);
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    var found = false;
	    var key = name + '';
	    var val = value + '';
	    var index = 0;
	    var entry;
	    for (; index < entries.length; index++) {
	      entry = entries[index];
	      if (entry.key === key) {
	        if (found) entries.splice(index--, 1);
	        else {
	          found = true;
	          entry.value = val;
	        }
	      }
	    }
	    if (!found) entries.push({ key: key, value: val });
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.sort` method
	  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
	  sort: function sort() {
	    var state = getInternalParamsState(this);
	    var entries = state.entries;
	    // Array#sort is not stable in some engines
	    var slice = entries.slice();
	    var entry, entriesIndex, sliceIndex;
	    entries.length = 0;
	    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
	      entry = slice[sliceIndex];
	      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
	        if (entries[entriesIndex].key > entry.key) {
	          entries.splice(entriesIndex, 0, entry);
	          break;
	        }
	      }
	      if (entriesIndex === sliceIndex) entries.push(entry);
	    }
	    state.updateURL();
	  },
	  // `URLSearchParams.prototype.forEach` method
	  forEach: function forEach(callback /* , thisArg */) {
	    var entries = getInternalParamsState(this).entries;
	    var boundFunction = functionBindContext(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var index = 0;
	    var entry;
	    while (index < entries.length) {
	      entry = entries[index++];
	      boundFunction(entry.value, entry.key, this);
	    }
	  },
	  // `URLSearchParams.prototype.keys` method
	  keys: function keys() {
	    return new URLSearchParamsIterator(this, 'keys');
	  },
	  // `URLSearchParams.prototype.values` method
	  values: function values() {
	    return new URLSearchParamsIterator(this, 'values');
	  },
	  // `URLSearchParams.prototype.entries` method
	  entries: function entries() {
	    return new URLSearchParamsIterator(this, 'entries');
	  }
	}, { enumerable: true });

	// `URLSearchParams.prototype[@@iterator]` method
	redefine(URLSearchParamsPrototype, ITERATOR$5, URLSearchParamsPrototype.entries);

	// `URLSearchParams.prototype.toString` method
	// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
	redefine(URLSearchParamsPrototype, 'toString', function toString() {
	  var entries = getInternalParamsState(this).entries;
	  var result = [];
	  var index = 0;
	  var entry;
	  while (index < entries.length) {
	    entry = entries[index++];
	    result.push(serialize(entry.key) + '=' + serialize(entry.value));
	  } return result.join('&');
	}, { enumerable: true });

	setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

	_export({ global: true, forced: !nativeUrl }, {
	  URLSearchParams: URLSearchParamsConstructor
	});

	// Wrap `fetch` for correct work with polyfilled `URLSearchParams`
	// https://github.com/zloirock/core-js/issues/674
	if (!nativeUrl && typeof $fetch == 'function' && typeof Headers == 'function') {
	  _export({ global: true, enumerable: true, forced: true }, {
	    fetch: function fetch(input /* , init */) {
	      var args = [input];
	      var init, body, headers;
	      if (arguments.length > 1) {
	        init = arguments[1];
	        if (isObject(init)) {
	          body = init.body;
	          if (classof(body) === URL_SEARCH_PARAMS) {
	            headers = init.headers ? new Headers(init.headers) : new Headers();
	            if (!headers.has('content-type')) {
	              headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	            init = objectCreate(init, {
	              body: createPropertyDescriptor(0, String(body)),
	              headers: createPropertyDescriptor(0, headers)
	            });
	          }
	        }
	        args.push(init);
	      } return $fetch.apply(this, args);
	    }
	  });
	}

	var web_urlSearchParams = {
	  URLSearchParams: URLSearchParamsConstructor,
	  getState: getInternalParamsState
	};

	// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`











	var codeAt = stringMultibyte.codeAt;





	var NativeURL = global_1.URL;
	var URLSearchParams$1 = web_urlSearchParams.URLSearchParams;
	var getInternalSearchParamsState = web_urlSearchParams.getState;
	var setInternalState$3 = internalState.set;
	var getInternalURLState = internalState.getterFor('URL');
	var floor$2 = Math.floor;
	var pow = Math.pow;

	var INVALID_AUTHORITY = 'Invalid authority';
	var INVALID_SCHEME = 'Invalid scheme';
	var INVALID_HOST = 'Invalid host';
	var INVALID_PORT = 'Invalid port';

	var ALPHA = /[A-Za-z]/;
	var ALPHANUMERIC = /[\d+-.A-Za-z]/;
	var DIGIT = /\d/;
	var HEX_START = /^(0x|0X)/;
	var OCT = /^[0-7]+$/;
	var DEC = /^\d+$/;
	var HEX = /^[\dA-Fa-f]+$/;
	/* eslint-disable no-control-regex -- safe */
	var FORBIDDEN_HOST_CODE_POINT = /[\u0000\t\u000A\u000D #%/:?@[\\]]/;
	var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\t\u000A\u000D #/:?@[\\]]/;
	var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
	var TAB_AND_NEW_LINE = /[\t\u000A\u000D]/g;
	/* eslint-enable no-control-regex -- safe */
	var EOF;

	var parseHost = function (url, input) {
	  var result, codePoints, index;
	  if (input.charAt(0) == '[') {
	    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
	    result = parseIPv6(input.slice(1, -1));
	    if (!result) return INVALID_HOST;
	    url.host = result;
	  // opaque host
	  } else if (!isSpecial(url)) {
	    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
	    result = '';
	    codePoints = arrayFrom(input);
	    for (index = 0; index < codePoints.length; index++) {
	      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
	    }
	    url.host = result;
	  } else {
	    input = stringPunycodeToAscii(input);
	    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
	    result = parseIPv4(input);
	    if (result === null) return INVALID_HOST;
	    url.host = result;
	  }
	};

	var parseIPv4 = function (input) {
	  var parts = input.split('.');
	  var partsLength, numbers, index, part, radix, number, ipv4;
	  if (parts.length && parts[parts.length - 1] == '') {
	    parts.pop();
	  }
	  partsLength = parts.length;
	  if (partsLength > 4) return input;
	  numbers = [];
	  for (index = 0; index < partsLength; index++) {
	    part = parts[index];
	    if (part == '') return input;
	    radix = 10;
	    if (part.length > 1 && part.charAt(0) == '0') {
	      radix = HEX_START.test(part) ? 16 : 8;
	      part = part.slice(radix == 8 ? 1 : 2);
	    }
	    if (part === '') {
	      number = 0;
	    } else {
	      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
	      number = parseInt(part, radix);
	    }
	    numbers.push(number);
	  }
	  for (index = 0; index < partsLength; index++) {
	    number = numbers[index];
	    if (index == partsLength - 1) {
	      if (number >= pow(256, 5 - partsLength)) return null;
	    } else if (number > 255) return null;
	  }
	  ipv4 = numbers.pop();
	  for (index = 0; index < numbers.length; index++) {
	    ipv4 += numbers[index] * pow(256, 3 - index);
	  }
	  return ipv4;
	};

	// eslint-disable-next-line max-statements -- TODO
	var parseIPv6 = function (input) {
	  var address = [0, 0, 0, 0, 0, 0, 0, 0];
	  var pieceIndex = 0;
	  var compress = null;
	  var pointer = 0;
	  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

	  var char = function () {
	    return input.charAt(pointer);
	  };

	  if (char() == ':') {
	    if (input.charAt(1) != ':') return;
	    pointer += 2;
	    pieceIndex++;
	    compress = pieceIndex;
	  }
	  while (char()) {
	    if (pieceIndex == 8) return;
	    if (char() == ':') {
	      if (compress !== null) return;
	      pointer++;
	      pieceIndex++;
	      compress = pieceIndex;
	      continue;
	    }
	    value = length = 0;
	    while (length < 4 && HEX.test(char())) {
	      value = value * 16 + parseInt(char(), 16);
	      pointer++;
	      length++;
	    }
	    if (char() == '.') {
	      if (length == 0) return;
	      pointer -= length;
	      if (pieceIndex > 6) return;
	      numbersSeen = 0;
	      while (char()) {
	        ipv4Piece = null;
	        if (numbersSeen > 0) {
	          if (char() == '.' && numbersSeen < 4) pointer++;
	          else return;
	        }
	        if (!DIGIT.test(char())) return;
	        while (DIGIT.test(char())) {
	          number = parseInt(char(), 10);
	          if (ipv4Piece === null) ipv4Piece = number;
	          else if (ipv4Piece == 0) return;
	          else ipv4Piece = ipv4Piece * 10 + number;
	          if (ipv4Piece > 255) return;
	          pointer++;
	        }
	        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
	        numbersSeen++;
	        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
	      }
	      if (numbersSeen != 4) return;
	      break;
	    } else if (char() == ':') {
	      pointer++;
	      if (!char()) return;
	    } else if (char()) return;
	    address[pieceIndex++] = value;
	  }
	  if (compress !== null) {
	    swaps = pieceIndex - compress;
	    pieceIndex = 7;
	    while (pieceIndex != 0 && swaps > 0) {
	      swap = address[pieceIndex];
	      address[pieceIndex--] = address[compress + swaps - 1];
	      address[compress + --swaps] = swap;
	    }
	  } else if (pieceIndex != 8) return;
	  return address;
	};

	var findLongestZeroSequence = function (ipv6) {
	  var maxIndex = null;
	  var maxLength = 1;
	  var currStart = null;
	  var currLength = 0;
	  var index = 0;
	  for (; index < 8; index++) {
	    if (ipv6[index] !== 0) {
	      if (currLength > maxLength) {
	        maxIndex = currStart;
	        maxLength = currLength;
	      }
	      currStart = null;
	      currLength = 0;
	    } else {
	      if (currStart === null) currStart = index;
	      ++currLength;
	    }
	  }
	  if (currLength > maxLength) {
	    maxIndex = currStart;
	    maxLength = currLength;
	  }
	  return maxIndex;
	};

	var serializeHost = function (host) {
	  var result, index, compress, ignore0;
	  // ipv4
	  if (typeof host == 'number') {
	    result = [];
	    for (index = 0; index < 4; index++) {
	      result.unshift(host % 256);
	      host = floor$2(host / 256);
	    } return result.join('.');
	  // ipv6
	  } else if (typeof host == 'object') {
	    result = '';
	    compress = findLongestZeroSequence(host);
	    for (index = 0; index < 8; index++) {
	      if (ignore0 && host[index] === 0) continue;
	      if (ignore0) ignore0 = false;
	      if (compress === index) {
	        result += index ? ':' : '::';
	        ignore0 = true;
	      } else {
	        result += host[index].toString(16);
	        if (index < 7) result += ':';
	      }
	    }
	    return '[' + result + ']';
	  } return host;
	};

	var C0ControlPercentEncodeSet = {};
	var fragmentPercentEncodeSet = objectAssign({}, C0ControlPercentEncodeSet, {
	  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
	});
	var pathPercentEncodeSet = objectAssign({}, fragmentPercentEncodeSet, {
	  '#': 1, '?': 1, '{': 1, '}': 1
	});
	var userinfoPercentEncodeSet = objectAssign({}, pathPercentEncodeSet, {
	  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
	});

	var percentEncode = function (char, set) {
	  var code = codeAt(char, 0);
	  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
	};

	var specialSchemes = {
	  ftp: 21,
	  file: null,
	  http: 80,
	  https: 443,
	  ws: 80,
	  wss: 443
	};

	var isSpecial = function (url) {
	  return has(specialSchemes, url.scheme);
	};

	var includesCredentials = function (url) {
	  return url.username != '' || url.password != '';
	};

	var cannotHaveUsernamePasswordPort = function (url) {
	  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
	};

	var isWindowsDriveLetter = function (string, normalized) {
	  var second;
	  return string.length == 2 && ALPHA.test(string.charAt(0))
	    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
	};

	var startsWithWindowsDriveLetter = function (string) {
	  var third;
	  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
	    string.length == 2 ||
	    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
	  );
	};

	var shortenURLsPath = function (url) {
	  var path = url.path;
	  var pathSize = path.length;
	  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
	    path.pop();
	  }
	};

	var isSingleDot = function (segment) {
	  return segment === '.' || segment.toLowerCase() === '%2e';
	};

	var isDoubleDot = function (segment) {
	  segment = segment.toLowerCase();
	  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
	};

	// States:
	var SCHEME_START = {};
	var SCHEME = {};
	var NO_SCHEME = {};
	var SPECIAL_RELATIVE_OR_AUTHORITY = {};
	var PATH_OR_AUTHORITY = {};
	var RELATIVE = {};
	var RELATIVE_SLASH = {};
	var SPECIAL_AUTHORITY_SLASHES = {};
	var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
	var AUTHORITY = {};
	var HOST = {};
	var HOSTNAME = {};
	var PORT = {};
	var FILE = {};
	var FILE_SLASH = {};
	var FILE_HOST = {};
	var PATH_START = {};
	var PATH = {};
	var CANNOT_BE_A_BASE_URL_PATH = {};
	var QUERY = {};
	var FRAGMENT = {};

	// eslint-disable-next-line max-statements -- TODO
	var parseURL = function (url, input, stateOverride, base) {
	  var state = stateOverride || SCHEME_START;
	  var pointer = 0;
	  var buffer = '';
	  var seenAt = false;
	  var seenBracket = false;
	  var seenPasswordToken = false;
	  var codePoints, char, bufferCodePoints, failure;

	  if (!stateOverride) {
	    url.scheme = '';
	    url.username = '';
	    url.password = '';
	    url.host = null;
	    url.port = null;
	    url.path = [];
	    url.query = null;
	    url.fragment = null;
	    url.cannotBeABaseURL = false;
	    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
	  }

	  input = input.replace(TAB_AND_NEW_LINE, '');

	  codePoints = arrayFrom(input);

	  while (pointer <= codePoints.length) {
	    char = codePoints[pointer];
	    switch (state) {
	      case SCHEME_START:
	        if (char && ALPHA.test(char)) {
	          buffer += char.toLowerCase();
	          state = SCHEME;
	        } else if (!stateOverride) {
	          state = NO_SCHEME;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case SCHEME:
	        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
	          buffer += char.toLowerCase();
	        } else if (char == ':') {
	          if (stateOverride && (
	            (isSpecial(url) != has(specialSchemes, buffer)) ||
	            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
	            (url.scheme == 'file' && !url.host)
	          )) return;
	          url.scheme = buffer;
	          if (stateOverride) {
	            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
	            return;
	          }
	          buffer = '';
	          if (url.scheme == 'file') {
	            state = FILE;
	          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
	            state = SPECIAL_RELATIVE_OR_AUTHORITY;
	          } else if (isSpecial(url)) {
	            state = SPECIAL_AUTHORITY_SLASHES;
	          } else if (codePoints[pointer + 1] == '/') {
	            state = PATH_OR_AUTHORITY;
	            pointer++;
	          } else {
	            url.cannotBeABaseURL = true;
	            url.path.push('');
	            state = CANNOT_BE_A_BASE_URL_PATH;
	          }
	        } else if (!stateOverride) {
	          buffer = '';
	          state = NO_SCHEME;
	          pointer = 0;
	          continue;
	        } else return INVALID_SCHEME;
	        break;

	      case NO_SCHEME:
	        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
	        if (base.cannotBeABaseURL && char == '#') {
	          url.scheme = base.scheme;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          url.cannotBeABaseURL = true;
	          state = FRAGMENT;
	          break;
	        }
	        state = base.scheme == 'file' ? FILE : RELATIVE;
	        continue;

	      case SPECIAL_RELATIVE_OR_AUTHORITY:
	        if (char == '/' && codePoints[pointer + 1] == '/') {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	          pointer++;
	        } else {
	          state = RELATIVE;
	          continue;
	        } break;

	      case PATH_OR_AUTHORITY:
	        if (char == '/') {
	          state = AUTHORITY;
	          break;
	        } else {
	          state = PATH;
	          continue;
	        }

	      case RELATIVE:
	        url.scheme = base.scheme;
	        if (char == EOF) {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
	          state = RELATIVE_SLASH;
	        } else if (char == '?') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.query = base.query;
	          url.fragment = '';
	          state = FRAGMENT;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          url.path = base.path.slice();
	          url.path.pop();
	          state = PATH;
	          continue;
	        } break;

	      case RELATIVE_SLASH:
	        if (isSpecial(url) && (char == '/' || char == '\\')) {
	          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        } else if (char == '/') {
	          state = AUTHORITY;
	        } else {
	          url.username = base.username;
	          url.password = base.password;
	          url.host = base.host;
	          url.port = base.port;
	          state = PATH;
	          continue;
	        } break;

	      case SPECIAL_AUTHORITY_SLASHES:
	        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
	        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
	        pointer++;
	        break;

	      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
	        if (char != '/' && char != '\\') {
	          state = AUTHORITY;
	          continue;
	        } break;

	      case AUTHORITY:
	        if (char == '@') {
	          if (seenAt) buffer = '%40' + buffer;
	          seenAt = true;
	          bufferCodePoints = arrayFrom(buffer);
	          for (var i = 0; i < bufferCodePoints.length; i++) {
	            var codePoint = bufferCodePoints[i];
	            if (codePoint == ':' && !seenPasswordToken) {
	              seenPasswordToken = true;
	              continue;
	            }
	            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
	            if (seenPasswordToken) url.password += encodedCodePoints;
	            else url.username += encodedCodePoints;
	          }
	          buffer = '';
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (seenAt && buffer == '') return INVALID_AUTHORITY;
	          pointer -= arrayFrom(buffer).length + 1;
	          buffer = '';
	          state = HOST;
	        } else buffer += char;
	        break;

	      case HOST:
	      case HOSTNAME:
	        if (stateOverride && url.scheme == 'file') {
	          state = FILE_HOST;
	          continue;
	        } else if (char == ':' && !seenBracket) {
	          if (buffer == '') return INVALID_HOST;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PORT;
	          if (stateOverride == HOSTNAME) return;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url))
	        ) {
	          if (isSpecial(url) && buffer == '') return INVALID_HOST;
	          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
	          failure = parseHost(url, buffer);
	          if (failure) return failure;
	          buffer = '';
	          state = PATH_START;
	          if (stateOverride) return;
	          continue;
	        } else {
	          if (char == '[') seenBracket = true;
	          else if (char == ']') seenBracket = false;
	          buffer += char;
	        } break;

	      case PORT:
	        if (DIGIT.test(char)) {
	          buffer += char;
	        } else if (
	          char == EOF || char == '/' || char == '?' || char == '#' ||
	          (char == '\\' && isSpecial(url)) ||
	          stateOverride
	        ) {
	          if (buffer != '') {
	            var port = parseInt(buffer, 10);
	            if (port > 0xFFFF) return INVALID_PORT;
	            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
	            buffer = '';
	          }
	          if (stateOverride) return;
	          state = PATH_START;
	          continue;
	        } else return INVALID_PORT;
	        break;

	      case FILE:
	        url.scheme = 'file';
	        if (char == '/' || char == '\\') state = FILE_SLASH;
	        else if (base && base.scheme == 'file') {
	          if (char == EOF) {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	          } else if (char == '?') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.host = base.host;
	            url.path = base.path.slice();
	            url.query = base.query;
	            url.fragment = '';
	            state = FRAGMENT;
	          } else {
	            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	              url.host = base.host;
	              url.path = base.path.slice();
	              shortenURLsPath(url);
	            }
	            state = PATH;
	            continue;
	          }
	        } else {
	          state = PATH;
	          continue;
	        } break;

	      case FILE_SLASH:
	        if (char == '/' || char == '\\') {
	          state = FILE_HOST;
	          break;
	        }
	        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
	          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
	          else url.host = base.host;
	        }
	        state = PATH;
	        continue;

	      case FILE_HOST:
	        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
	          if (!stateOverride && isWindowsDriveLetter(buffer)) {
	            state = PATH;
	          } else if (buffer == '') {
	            url.host = '';
	            if (stateOverride) return;
	            state = PATH_START;
	          } else {
	            failure = parseHost(url, buffer);
	            if (failure) return failure;
	            if (url.host == 'localhost') url.host = '';
	            if (stateOverride) return;
	            buffer = '';
	            state = PATH_START;
	          } continue;
	        } else buffer += char;
	        break;

	      case PATH_START:
	        if (isSpecial(url)) {
	          state = PATH;
	          if (char != '/' && char != '\\') continue;
	        } else if (!stateOverride && char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          state = PATH;
	          if (char != '/') continue;
	        } break;

	      case PATH:
	        if (
	          char == EOF || char == '/' ||
	          (char == '\\' && isSpecial(url)) ||
	          (!stateOverride && (char == '?' || char == '#'))
	        ) {
	          if (isDoubleDot(buffer)) {
	            shortenURLsPath(url);
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else if (isSingleDot(buffer)) {
	            if (char != '/' && !(char == '\\' && isSpecial(url))) {
	              url.path.push('');
	            }
	          } else {
	            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
	              if (url.host) url.host = '';
	              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
	            }
	            url.path.push(buffer);
	          }
	          buffer = '';
	          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
	            while (url.path.length > 1 && url.path[0] === '') {
	              url.path.shift();
	            }
	          }
	          if (char == '?') {
	            url.query = '';
	            state = QUERY;
	          } else if (char == '#') {
	            url.fragment = '';
	            state = FRAGMENT;
	          }
	        } else {
	          buffer += percentEncode(char, pathPercentEncodeSet);
	        } break;

	      case CANNOT_BE_A_BASE_URL_PATH:
	        if (char == '?') {
	          url.query = '';
	          state = QUERY;
	        } else if (char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case QUERY:
	        if (!stateOverride && char == '#') {
	          url.fragment = '';
	          state = FRAGMENT;
	        } else if (char != EOF) {
	          if (char == "'" && isSpecial(url)) url.query += '%27';
	          else if (char == '#') url.query += '%23';
	          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
	        } break;

	      case FRAGMENT:
	        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
	        break;
	    }

	    pointer++;
	  }
	};

	// `URL` constructor
	// https://url.spec.whatwg.org/#url-class
	var URLConstructor = function URL(url /* , base */) {
	  var that = anInstance(this, URLConstructor, 'URL');
	  var base = arguments.length > 1 ? arguments[1] : undefined;
	  var urlString = String(url);
	  var state = setInternalState$3(that, { type: 'URL' });
	  var baseState, failure;
	  if (base !== undefined) {
	    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
	    else {
	      failure = parseURL(baseState = {}, String(base));
	      if (failure) throw TypeError(failure);
	    }
	  }
	  failure = parseURL(state, urlString, null, baseState);
	  if (failure) throw TypeError(failure);
	  var searchParams = state.searchParams = new URLSearchParams$1();
	  var searchParamsState = getInternalSearchParamsState(searchParams);
	  searchParamsState.updateSearchParams(state.query);
	  searchParamsState.updateURL = function () {
	    state.query = String(searchParams) || null;
	  };
	  if (!descriptors) {
	    that.href = serializeURL.call(that);
	    that.origin = getOrigin.call(that);
	    that.protocol = getProtocol.call(that);
	    that.username = getUsername.call(that);
	    that.password = getPassword.call(that);
	    that.host = getHost.call(that);
	    that.hostname = getHostname.call(that);
	    that.port = getPort.call(that);
	    that.pathname = getPathname.call(that);
	    that.search = getSearch.call(that);
	    that.searchParams = getSearchParams.call(that);
	    that.hash = getHash.call(that);
	  }
	};

	var URLPrototype = URLConstructor.prototype;

	var serializeURL = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var username = url.username;
	  var password = url.password;
	  var host = url.host;
	  var port = url.port;
	  var path = url.path;
	  var query = url.query;
	  var fragment = url.fragment;
	  var output = scheme + ':';
	  if (host !== null) {
	    output += '//';
	    if (includesCredentials(url)) {
	      output += username + (password ? ':' + password : '') + '@';
	    }
	    output += serializeHost(host);
	    if (port !== null) output += ':' + port;
	  } else if (scheme == 'file') output += '//';
	  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	  if (query !== null) output += '?' + query;
	  if (fragment !== null) output += '#' + fragment;
	  return output;
	};

	var getOrigin = function () {
	  var url = getInternalURLState(this);
	  var scheme = url.scheme;
	  var port = url.port;
	  if (scheme == 'blob') try {
	    return new URL(scheme.path[0]).origin;
	  } catch (error) {
	    return 'null';
	  }
	  if (scheme == 'file' || !isSpecial(url)) return 'null';
	  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
	};

	var getProtocol = function () {
	  return getInternalURLState(this).scheme + ':';
	};

	var getUsername = function () {
	  return getInternalURLState(this).username;
	};

	var getPassword = function () {
	  return getInternalURLState(this).password;
	};

	var getHost = function () {
	  var url = getInternalURLState(this);
	  var host = url.host;
	  var port = url.port;
	  return host === null ? ''
	    : port === null ? serializeHost(host)
	    : serializeHost(host) + ':' + port;
	};

	var getHostname = function () {
	  var host = getInternalURLState(this).host;
	  return host === null ? '' : serializeHost(host);
	};

	var getPort = function () {
	  var port = getInternalURLState(this).port;
	  return port === null ? '' : String(port);
	};

	var getPathname = function () {
	  var url = getInternalURLState(this);
	  var path = url.path;
	  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
	};

	var getSearch = function () {
	  var query = getInternalURLState(this).query;
	  return query ? '?' + query : '';
	};

	var getSearchParams = function () {
	  return getInternalURLState(this).searchParams;
	};

	var getHash = function () {
	  var fragment = getInternalURLState(this).fragment;
	  return fragment ? '#' + fragment : '';
	};

	var accessorDescriptor = function (getter, setter) {
	  return { get: getter, set: setter, configurable: true, enumerable: true };
	};

	if (descriptors) {
	  objectDefineProperties(URLPrototype, {
	    // `URL.prototype.href` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-href
	    href: accessorDescriptor(serializeURL, function (href) {
	      var url = getInternalURLState(this);
	      var urlString = String(href);
	      var failure = parseURL(url, urlString);
	      if (failure) throw TypeError(failure);
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.origin` getter
	    // https://url.spec.whatwg.org/#dom-url-origin
	    origin: accessorDescriptor(getOrigin),
	    // `URL.prototype.protocol` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-protocol
	    protocol: accessorDescriptor(getProtocol, function (protocol) {
	      var url = getInternalURLState(this);
	      parseURL(url, String(protocol) + ':', SCHEME_START);
	    }),
	    // `URL.prototype.username` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-username
	    username: accessorDescriptor(getUsername, function (username) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(username));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.username = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.password` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-password
	    password: accessorDescriptor(getPassword, function (password) {
	      var url = getInternalURLState(this);
	      var codePoints = arrayFrom(String(password));
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      url.password = '';
	      for (var i = 0; i < codePoints.length; i++) {
	        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
	      }
	    }),
	    // `URL.prototype.host` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-host
	    host: accessorDescriptor(getHost, function (host) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(host), HOST);
	    }),
	    // `URL.prototype.hostname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hostname
	    hostname: accessorDescriptor(getHostname, function (hostname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      parseURL(url, String(hostname), HOSTNAME);
	    }),
	    // `URL.prototype.port` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-port
	    port: accessorDescriptor(getPort, function (port) {
	      var url = getInternalURLState(this);
	      if (cannotHaveUsernamePasswordPort(url)) return;
	      port = String(port);
	      if (port == '') url.port = null;
	      else parseURL(url, port, PORT);
	    }),
	    // `URL.prototype.pathname` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-pathname
	    pathname: accessorDescriptor(getPathname, function (pathname) {
	      var url = getInternalURLState(this);
	      if (url.cannotBeABaseURL) return;
	      url.path = [];
	      parseURL(url, pathname + '', PATH_START);
	    }),
	    // `URL.prototype.search` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-search
	    search: accessorDescriptor(getSearch, function (search) {
	      var url = getInternalURLState(this);
	      search = String(search);
	      if (search == '') {
	        url.query = null;
	      } else {
	        if ('?' == search.charAt(0)) search = search.slice(1);
	        url.query = '';
	        parseURL(url, search, QUERY);
	      }
	      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
	    }),
	    // `URL.prototype.searchParams` getter
	    // https://url.spec.whatwg.org/#dom-url-searchparams
	    searchParams: accessorDescriptor(getSearchParams),
	    // `URL.prototype.hash` accessors pair
	    // https://url.spec.whatwg.org/#dom-url-hash
	    hash: accessorDescriptor(getHash, function (hash) {
	      var url = getInternalURLState(this);
	      hash = String(hash);
	      if (hash == '') {
	        url.fragment = null;
	        return;
	      }
	      if ('#' == hash.charAt(0)) hash = hash.slice(1);
	      url.fragment = '';
	      parseURL(url, hash, FRAGMENT);
	    })
	  });
	}

	// `URL.prototype.toJSON` method
	// https://url.spec.whatwg.org/#dom-url-tojson
	redefine(URLPrototype, 'toJSON', function toJSON() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	// `URL.prototype.toString` method
	// https://url.spec.whatwg.org/#URL-stringification-behavior
	redefine(URLPrototype, 'toString', function toString() {
	  return serializeURL.call(this);
	}, { enumerable: true });

	if (NativeURL) {
	  var nativeCreateObjectURL = NativeURL.createObjectURL;
	  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
	  // `URL.createObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
	    return nativeCreateObjectURL.apply(NativeURL, arguments);
	  });
	  // `URL.revokeObjectURL` method
	  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
	    return nativeRevokeObjectURL.apply(NativeURL, arguments);
	  });
	}

	setToStringTag(URLConstructor, 'URL');

	_export({ global: true, forced: !nativeUrl, sham: !descriptors }, {
	  URL: URLConstructor
	});

	var url = path.URL;

	var url$1 = url;

	var url$2 = url$1;

	var $includes = arrayIncludes.includes;


	// `Array.prototype.includes` method
	// https://tc39.es/ecma262/#sec-array.prototype.includes
	_export({ target: 'Array', proto: true }, {
	  includes: function includes(el /* , fromIndex = 0 */) {
	    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var includes = entryVirtual('Array').includes;

	var MATCH = wellKnownSymbol('match');

	// `IsRegExp` abstract operation
	// https://tc39.es/ecma262/#sec-isregexp
	var isRegexp = function (it) {
	  var isRegExp;
	  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == 'RegExp');
	};

	var notARegexp = function (it) {
	  if (isRegexp(it)) {
	    throw TypeError("The method doesn't accept regular expressions");
	  } return it;
	};

	var MATCH$1 = wellKnownSymbol('match');

	var correctIsRegexpLogic = function (METHOD_NAME) {
	  var regexp = /./;
	  try {
	    '/./'[METHOD_NAME](regexp);
	  } catch (error1) {
	    try {
	      regexp[MATCH$1] = false;
	      return '/./'[METHOD_NAME](regexp);
	    } catch (error2) { /* empty */ }
	  } return false;
	};

	// `String.prototype.includes` method
	// https://tc39.es/ecma262/#sec-string.prototype.includes
	_export({ target: 'String', proto: true, forced: !correctIsRegexpLogic('includes') }, {
	  includes: function includes(searchString /* , position = 0 */) {
	    return !!~String(requireObjectCoercible(this))
	      .indexOf(notARegexp(searchString), arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var includes$1 = entryVirtual('String').includes;

	var ArrayPrototype$1 = Array.prototype;
	var StringPrototype = String.prototype;

	var includes$2 = function (it) {
	  var own = it.includes;
	  if (it === ArrayPrototype$1 || (it instanceof Array && own === ArrayPrototype$1.includes)) return includes;
	  if (typeof it === 'string' || it === StringPrototype || (it instanceof String && own === StringPrototype.includes)) {
	    return includes$1;
	  } return own;
	};

	var includes$3 = includes$2;

	var includes$4 = includes$3;

	// `Object.assign` method
	// https://tc39.es/ecma262/#sec-object.assign
	_export({ target: 'Object', stat: true, forced: Object.assign !== objectAssign }, {
	  assign: objectAssign
	});

	var assign = path.Object.assign;

	var assign$1 = assign;

	var assign$2 = assign$1;

	var _extends_1 = createCommonjsModule(function (module) {
	function _extends() {
	  module.exports = _extends = assign$2 || function (target) {
	    for (var i = 1; i < arguments.length; i++) {
	      var source = arguments[i];

	      for (var key in source) {
	        if (Object.prototype.hasOwnProperty.call(source, key)) {
	          target[key] = source[key];
	        }
	      }
	    }

	    return target;
	  };

	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	  return _extends.apply(this, arguments);
	}

	module.exports = _extends;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _extends = unwrapExports(_extends_1);

	var Result = function (stopped, result) {
	  this.stopped = stopped;
	  this.result = result;
	};

	var iterate = function (iterable, unboundFunction, options) {
	  var that = options && options.that;
	  var AS_ENTRIES = !!(options && options.AS_ENTRIES);
	  var IS_ITERATOR = !!(options && options.IS_ITERATOR);
	  var INTERRUPTED = !!(options && options.INTERRUPTED);
	  var fn = functionBindContext(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
	  var iterator, iterFn, index, length, result, next, step;

	  var stop = function (condition) {
	    if (iterator) iteratorClose(iterator);
	    return new Result(true, condition);
	  };

	  var callFn = function (value) {
	    if (AS_ENTRIES) {
	      anObject(value);
	      return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
	    } return INTERRUPTED ? fn(value, stop) : fn(value);
	  };

	  if (IS_ITERATOR) {
	    iterator = iterable;
	  } else {
	    iterFn = getIteratorMethod(iterable);
	    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
	    // optimisation for array iterators
	    if (isArrayIteratorMethod(iterFn)) {
	      for (index = 0, length = toLength(iterable.length); length > index; index++) {
	        result = callFn(iterable[index]);
	        if (result && result instanceof Result) return result;
	      } return new Result(false);
	    }
	    iterator = iterFn.call(iterable);
	  }

	  next = iterator.next;
	  while (!(step = next.call(iterator)).done) {
	    try {
	      result = callFn(step.value);
	    } catch (error) {
	      iteratorClose(iterator);
	      throw error;
	    }
	    if (typeof result == 'object' && result && result instanceof Result) return result;
	  } return new Result(false);
	};

	var $AggregateError = function AggregateError(errors, message) {
	  var that = this;
	  if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message);
	  if (objectSetPrototypeOf) {
	    // eslint-disable-next-line unicorn/error-message -- expected
	    that = objectSetPrototypeOf(new Error(undefined), objectGetPrototypeOf(that));
	  }
	  if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message));
	  var errorsArray = [];
	  iterate(errors, errorsArray.push, { that: errorsArray });
	  createNonEnumerableProperty(that, 'errors', errorsArray);
	  return that;
	};

	$AggregateError.prototype = objectCreate(Error.prototype, {
	  constructor: createPropertyDescriptor(5, $AggregateError),
	  message: createPropertyDescriptor(5, ''),
	  name: createPropertyDescriptor(5, 'AggregateError')
	});

	// `AggregateError` constructor
	// https://tc39.es/ecma262/#sec-aggregate-error-constructor
	_export({ global: true }, {
	  AggregateError: $AggregateError
	});

	var nativePromiseConstructor = global_1.Promise;

	var SPECIES = wellKnownSymbol('species');

	var setSpecies = function (CONSTRUCTOR_NAME) {
	  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
	  var defineProperty = objectDefineProperty.f;

	  if (descriptors && Constructor && !Constructor[SPECIES]) {
	    defineProperty(Constructor, SPECIES, {
	      configurable: true,
	      get: function () { return this; }
	    });
	  }
	};

	var ITERATOR$6 = wellKnownSymbol('iterator');
	var SAFE_CLOSING = false;

	try {
	  var called = 0;
	  var iteratorWithReturn = {
	    next: function () {
	      return { done: !!called++ };
	    },
	    'return': function () {
	      SAFE_CLOSING = true;
	    }
	  };
	  iteratorWithReturn[ITERATOR$6] = function () {
	    return this;
	  };
	  // eslint-disable-next-line no-throw-literal -- required for testing
	  Array.from(iteratorWithReturn, function () { throw 2; });
	} catch (error) { /* empty */ }

	var checkCorrectnessOfIteration = function (exec, SKIP_CLOSING) {
	  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
	  var ITERATION_SUPPORT = false;
	  try {
	    var object = {};
	    object[ITERATOR$6] = function () {
	      return {
	        next: function () {
	          return { done: ITERATION_SUPPORT = true };
	        }
	      };
	    };
	    exec(object);
	  } catch (error) { /* empty */ }
	  return ITERATION_SUPPORT;
	};

	var SPECIES$1 = wellKnownSymbol('species');

	// `SpeciesConstructor` abstract operation
	// https://tc39.es/ecma262/#sec-speciesconstructor
	var speciesConstructor = function (O, defaultConstructor) {
	  var C = anObject(O).constructor;
	  var S;
	  return C === undefined || (S = anObject(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction(S);
	};

	var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(engineUserAgent);

	var location$1 = global_1.location;
	var set$1 = global_1.setImmediate;
	var clear = global_1.clearImmediate;
	var process$1 = global_1.process;
	var MessageChannel = global_1.MessageChannel;
	var Dispatch = global_1.Dispatch;
	var counter = 0;
	var queue = {};
	var ONREADYSTATECHANGE = 'onreadystatechange';
	var defer, channel, port;

	var run = function (id) {
	  // eslint-disable-next-line no-prototype-builtins -- safe
	  if (queue.hasOwnProperty(id)) {
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};

	var runner = function (id) {
	  return function () {
	    run(id);
	  };
	};

	var listener = function (event) {
	  run(event.data);
	};

	var post = function (id) {
	  // old engines have not location.origin
	  global_1.postMessage(id + '', location$1.protocol + '//' + location$1.host);
	};

	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if (!set$1 || !clear) {
	  set$1 = function setImmediate(fn) {
	    var args = [];
	    var i = 1;
	    while (arguments.length > i) args.push(arguments[i++]);
	    queue[++counter] = function () {
	      // eslint-disable-next-line no-new-func -- spec requirement
	      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clear = function clearImmediate(id) {
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if (engineIsNode) {
	    defer = function (id) {
	      process$1.nextTick(runner(id));
	    };
	  // Sphere (JS game engine) Dispatch API
	  } else if (Dispatch && Dispatch.now) {
	    defer = function (id) {
	      Dispatch.now(runner(id));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  // except iOS - https://github.com/zloirock/core-js/issues/624
	  } else if (MessageChannel && !engineIsIos) {
	    channel = new MessageChannel();
	    port = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = functionBindContext(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if (
	    global_1.addEventListener &&
	    typeof postMessage == 'function' &&
	    !global_1.importScripts &&
	    location$1 && location$1.protocol !== 'file:' &&
	    !fails(post)
	  ) {
	    defer = post;
	    global_1.addEventListener('message', listener, false);
	  // IE8-
	  } else if (ONREADYSTATECHANGE in documentCreateElement('script')) {
	    defer = function (id) {
	      html.appendChild(documentCreateElement('script'))[ONREADYSTATECHANGE] = function () {
	        html.removeChild(this);
	        run(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function (id) {
	      setTimeout(runner(id), 0);
	    };
	  }
	}

	var task = {
	  set: set$1,
	  clear: clear
	};

	var engineIsWebosWebkit = /web0s(?!.*chrome)/i.test(engineUserAgent);

	var getOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var macrotask = task.set;




	var MutationObserver$1 = global_1.MutationObserver || global_1.WebKitMutationObserver;
	var document$2 = global_1.document;
	var process$2 = global_1.process;
	var Promise$1 = global_1.Promise;
	// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
	var queueMicrotaskDescriptor = getOwnPropertyDescriptor$2(global_1, 'queueMicrotask');
	var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

	var flush, head, last, notify, toggle, node, promise, then;

	// modern engines have queueMicrotask method
	if (!queueMicrotask) {
	  flush = function () {
	    var parent, fn;
	    if (engineIsNode && (parent = process$2.domain)) parent.exit();
	    while (head) {
	      fn = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch (error) {
	        if (head) notify();
	        else last = undefined;
	        throw error;
	      }
	    } last = undefined;
	    if (parent) parent.enter();
	  };

	  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
	  // also except WebOS Webkit https://github.com/zloirock/core-js/issues/898
	  if (!engineIsIos && !engineIsNode && !engineIsWebosWebkit && MutationObserver$1 && document$2) {
	    toggle = true;
	    node = document$2.createTextNode('');
	    new MutationObserver$1(flush).observe(node, { characterData: true });
	    notify = function () {
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if (Promise$1 && Promise$1.resolve) {
	    // Promise.resolve without an argument throws an error in LG WebOS 2
	    promise = Promise$1.resolve(undefined);
	    then = promise.then;
	    notify = function () {
	      then.call(promise, flush);
	    };
	  // Node.js without promises
	  } else if (engineIsNode) {
	    notify = function () {
	      process$2.nextTick(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function () {
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global_1, flush);
	    };
	  }
	}

	var microtask = queueMicrotask || function (fn) {
	  var task = { fn: fn, next: undefined };
	  if (last) last.next = task;
	  if (!head) {
	    head = task;
	    notify();
	  } last = task;
	};

	var PromiseCapability = function (C) {
	  var resolve, reject;
	  this.promise = new C(function ($$resolve, $$reject) {
	    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject = aFunction(reject);
	};

	// 25.4.1.5 NewPromiseCapability(C)
	var f$4 = function (C) {
	  return new PromiseCapability(C);
	};

	var newPromiseCapability = {
		f: f$4
	};

	var promiseResolve = function (C, x) {
	  anObject(C);
	  if (isObject(x) && x.constructor === C) return x;
	  var promiseCapability = newPromiseCapability.f(C);
	  var resolve = promiseCapability.resolve;
	  resolve(x);
	  return promiseCapability.promise;
	};

	var hostReportErrors = function (a, b) {
	  var console = global_1.console;
	  if (console && console.error) {
	    arguments.length === 1 ? console.error(a) : console.error(a, b);
	  }
	};

	var perform = function (exec) {
	  try {
	    return { error: false, value: exec() };
	  } catch (error) {
	    return { error: true, value: error };
	  }
	};

	var task$1 = task.set;











	var SPECIES$2 = wellKnownSymbol('species');
	var PROMISE = 'Promise';
	var getInternalState$2 = internalState.get;
	var setInternalState$4 = internalState.set;
	var getInternalPromiseState = internalState.getterFor(PROMISE);
	var PromiseConstructor = nativePromiseConstructor;
	var TypeError$1 = global_1.TypeError;
	var document$3 = global_1.document;
	var process$3 = global_1.process;
	var $fetch$1 = getBuiltIn('fetch');
	var newPromiseCapability$1 = newPromiseCapability.f;
	var newGenericPromiseCapability = newPromiseCapability$1;
	var DISPATCH_EVENT = !!(document$3 && document$3.createEvent && global_1.dispatchEvent);
	var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function';
	var UNHANDLED_REJECTION = 'unhandledrejection';
	var REJECTION_HANDLED = 'rejectionhandled';
	var PENDING = 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	var HANDLED = 1;
	var UNHANDLED = 2;
	var Internal, OwnPromiseCapability, PromiseWrapper;

	var FORCED$2 = isForced_1(PROMISE, function () {
	  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
	  if (!GLOBAL_CORE_JS_PROMISE) {
	    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
	    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
	    // We can't detect it synchronously, so just check versions
	    if (engineV8Version === 66) return true;
	    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    if (!engineIsNode && !NATIVE_REJECTION_EVENT) return true;
	  }
	  // We need Promise#finally in the pure version for preventing prototype pollution
	  if ( !PromiseConstructor.prototype['finally']) return true;
	  // We can't use @@species feature detection in V8 since it causes
	  // deoptimization and performance degradation
	  // https://github.com/zloirock/core-js/issues/679
	  if (engineV8Version >= 51 && /native code/.test(PromiseConstructor)) return false;
	  // Detect correctness of subclassing with @@species support
	  var promise = PromiseConstructor.resolve(1);
	  var FakePromise = function (exec) {
	    exec(function () { /* empty */ }, function () { /* empty */ });
	  };
	  var constructor = promise.constructor = {};
	  constructor[SPECIES$2] = FakePromise;
	  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
	});

	var INCORRECT_ITERATION = FORCED$2 || !checkCorrectnessOfIteration(function (iterable) {
	  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
	});

	// helpers
	var isThenable = function (it) {
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};

	var notify$1 = function (state, isReject) {
	  if (state.notified) return;
	  state.notified = true;
	  var chain = state.reactions;
	  microtask(function () {
	    var value = state.value;
	    var ok = state.state == FULFILLED;
	    var index = 0;
	    // variable length - can't use forEach
	    while (chain.length > index) {
	      var reaction = chain[index++];
	      var handler = ok ? reaction.ok : reaction.fail;
	      var resolve = reaction.resolve;
	      var reject = reaction.reject;
	      var domain = reaction.domain;
	      var result, then, exited;
	      try {
	        if (handler) {
	          if (!ok) {
	            if (state.rejection === UNHANDLED) onHandleUnhandled(state);
	            state.rejection = HANDLED;
	          }
	          if (handler === true) result = value;
	          else {
	            if (domain) domain.enter();
	            result = handler(value); // can throw
	            if (domain) {
	              domain.exit();
	              exited = true;
	            }
	          }
	          if (result === reaction.promise) {
	            reject(TypeError$1('Promise-chain cycle'));
	          } else if (then = isThenable(result)) {
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch (error) {
	        if (domain && !exited) domain.exit();
	        reject(error);
	      }
	    }
	    state.reactions = [];
	    state.notified = false;
	    if (isReject && !state.rejection) onUnhandled(state);
	  });
	};

	var dispatchEvent = function (name, promise, reason) {
	  var event, handler;
	  if (DISPATCH_EVENT) {
	    event = document$3.createEvent('Event');
	    event.promise = promise;
	    event.reason = reason;
	    event.initEvent(name, false, true);
	    global_1.dispatchEvent(event);
	  } else event = { promise: promise, reason: reason };
	  if (!NATIVE_REJECTION_EVENT && (handler = global_1['on' + name])) handler(event);
	  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
	};

	var onUnhandled = function (state) {
	  task$1.call(global_1, function () {
	    var promise = state.facade;
	    var value = state.value;
	    var IS_UNHANDLED = isUnhandled(state);
	    var result;
	    if (IS_UNHANDLED) {
	      result = perform(function () {
	        if (engineIsNode) {
	          process$3.emit('unhandledRejection', value, promise);
	        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      state.rejection = engineIsNode || isUnhandled(state) ? UNHANDLED : HANDLED;
	      if (result.error) throw result.value;
	    }
	  });
	};

	var isUnhandled = function (state) {
	  return state.rejection !== HANDLED && !state.parent;
	};

	var onHandleUnhandled = function (state) {
	  task$1.call(global_1, function () {
	    var promise = state.facade;
	    if (engineIsNode) {
	      process$3.emit('rejectionHandled', promise);
	    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
	  });
	};

	var bind$3 = function (fn, state, unwrap) {
	  return function (value) {
	    fn(state, value, unwrap);
	  };
	};

	var internalReject = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  state.value = value;
	  state.state = REJECTED;
	  notify$1(state, true);
	};

	var internalResolve = function (state, value, unwrap) {
	  if (state.done) return;
	  state.done = true;
	  if (unwrap) state = unwrap;
	  try {
	    if (state.facade === value) throw TypeError$1("Promise can't be resolved itself");
	    var then = isThenable(value);
	    if (then) {
	      microtask(function () {
	        var wrapper = { done: false };
	        try {
	          then.call(value,
	            bind$3(internalResolve, wrapper, state),
	            bind$3(internalReject, wrapper, state)
	          );
	        } catch (error) {
	          internalReject(wrapper, error, state);
	        }
	      });
	    } else {
	      state.value = value;
	      state.state = FULFILLED;
	      notify$1(state, false);
	    }
	  } catch (error) {
	    internalReject({ done: false }, error, state);
	  }
	};

	// constructor polyfill
	if (FORCED$2) {
	  // 25.4.3.1 Promise(executor)
	  PromiseConstructor = function Promise(executor) {
	    anInstance(this, PromiseConstructor, PROMISE);
	    aFunction(executor);
	    Internal.call(this);
	    var state = getInternalState$2(this);
	    try {
	      executor(bind$3(internalResolve, state), bind$3(internalReject, state));
	    } catch (error) {
	      internalReject(state, error);
	    }
	  };
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  Internal = function Promise(executor) {
	    setInternalState$4(this, {
	      type: PROMISE,
	      done: false,
	      notified: false,
	      parent: false,
	      reactions: [],
	      rejection: false,
	      state: PENDING,
	      value: undefined
	    });
	  };
	  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
	    // `Promise.prototype.then` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.then
	    then: function then(onFulfilled, onRejected) {
	      var state = getInternalPromiseState(this);
	      var reaction = newPromiseCapability$1(speciesConstructor(this, PromiseConstructor));
	      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail = typeof onRejected == 'function' && onRejected;
	      reaction.domain = engineIsNode ? process$3.domain : undefined;
	      state.parent = true;
	      state.reactions.push(reaction);
	      if (state.state != PENDING) notify$1(state, false);
	      return reaction.promise;
	    },
	    // `Promise.prototype.catch` method
	    // https://tc39.es/ecma262/#sec-promise.prototype.catch
	    'catch': function (onRejected) {
	      return this.then(undefined, onRejected);
	    }
	  });
	  OwnPromiseCapability = function () {
	    var promise = new Internal();
	    var state = getInternalState$2(promise);
	    this.promise = promise;
	    this.resolve = bind$3(internalResolve, state);
	    this.reject = bind$3(internalReject, state);
	  };
	  newPromiseCapability.f = newPromiseCapability$1 = function (C) {
	    return C === PromiseConstructor || C === PromiseWrapper
	      ? new OwnPromiseCapability(C)
	      : newGenericPromiseCapability(C);
	  };
	}

	_export({ global: true, wrap: true, forced: FORCED$2 }, {
	  Promise: PromiseConstructor
	});

	setToStringTag(PromiseConstructor, PROMISE, false, true);
	setSpecies(PROMISE);

	PromiseWrapper = getBuiltIn(PROMISE);

	// statics
	_export({ target: PROMISE, stat: true, forced: FORCED$2 }, {
	  // `Promise.reject` method
	  // https://tc39.es/ecma262/#sec-promise.reject
	  reject: function reject(r) {
	    var capability = newPromiseCapability$1(this);
	    capability.reject.call(undefined, r);
	    return capability.promise;
	  }
	});

	_export({ target: PROMISE, stat: true, forced: isPure  }, {
	  // `Promise.resolve` method
	  // https://tc39.es/ecma262/#sec-promise.resolve
	  resolve: function resolve(x) {
	    return promiseResolve( this === PromiseWrapper ? PromiseConstructor : this, x);
	  }
	});

	_export({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
	  // `Promise.all` method
	  // https://tc39.es/ecma262/#sec-promise.all
	  all: function all(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        $promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  },
	  // `Promise.race` method
	  // https://tc39.es/ecma262/#sec-promise.race
	  race: function race(iterable) {
	    var C = this;
	    var capability = newPromiseCapability$1(C);
	    var reject = capability.reject;
	    var result = perform(function () {
	      var $promiseResolve = aFunction(C.resolve);
	      iterate(iterable, function (promise) {
	        $promiseResolve.call(C, promise).then(capability.resolve, reject);
	      });
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// `Promise.allSettled` method
	// https://tc39.es/ecma262/#sec-promise.allsettled
	_export({ target: 'Promise', stat: true }, {
	  allSettled: function allSettled(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction(C.resolve);
	      var values = [];
	      var counter = 0;
	      var remaining = 1;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'fulfilled', value: value };
	          --remaining || resolve(values);
	        }, function (error) {
	          if (alreadyCalled) return;
	          alreadyCalled = true;
	          values[index] = { status: 'rejected', reason: error };
	          --remaining || resolve(values);
	        });
	      });
	      --remaining || resolve(values);
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	var PROMISE_ANY_ERROR = 'No one promise resolved';

	// `Promise.any` method
	// https://tc39.es/ecma262/#sec-promise.any
	_export({ target: 'Promise', stat: true }, {
	  any: function any(iterable) {
	    var C = this;
	    var capability = newPromiseCapability.f(C);
	    var resolve = capability.resolve;
	    var reject = capability.reject;
	    var result = perform(function () {
	      var promiseResolve = aFunction(C.resolve);
	      var errors = [];
	      var counter = 0;
	      var remaining = 1;
	      var alreadyResolved = false;
	      iterate(iterable, function (promise) {
	        var index = counter++;
	        var alreadyRejected = false;
	        errors.push(undefined);
	        remaining++;
	        promiseResolve.call(C, promise).then(function (value) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyResolved = true;
	          resolve(value);
	        }, function (error) {
	          if (alreadyRejected || alreadyResolved) return;
	          alreadyRejected = true;
	          errors[index] = error;
	          --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	        });
	      });
	      --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR));
	    });
	    if (result.error) reject(result.value);
	    return capability.promise;
	  }
	});

	// Safari bug https://bugs.webkit.org/show_bug.cgi?id=200829
	var NON_GENERIC = !!nativePromiseConstructor && fails(function () {
	  nativePromiseConstructor.prototype['finally'].call({ then: function () { /* empty */ } }, function () { /* empty */ });
	});

	// `Promise.prototype.finally` method
	// https://tc39.es/ecma262/#sec-promise.prototype.finally
	_export({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, {
	  'finally': function (onFinally) {
	    var C = speciesConstructor(this, getBuiltIn('Promise'));
	    var isFunction = typeof onFinally == 'function';
	    return this.then(
	      isFunction ? function (x) {
	        return promiseResolve(C, onFinally()).then(function () { return x; });
	      } : onFinally,
	      isFunction ? function (e) {
	        return promiseResolve(C, onFinally()).then(function () { throw e; });
	      } : onFinally
	    );
	  }
	});

	// iterable DOM collections
	// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
	var domIterables = {
	  CSSRuleList: 0,
	  CSSStyleDeclaration: 0,
	  CSSValueList: 0,
	  ClientRectList: 0,
	  DOMRectList: 0,
	  DOMStringList: 0,
	  DOMTokenList: 1,
	  DataTransferItemList: 0,
	  FileList: 0,
	  HTMLAllCollection: 0,
	  HTMLCollection: 0,
	  HTMLFormElement: 0,
	  HTMLSelectElement: 0,
	  MediaList: 0,
	  MimeTypeArray: 0,
	  NamedNodeMap: 0,
	  NodeList: 1,
	  PaintRequestList: 0,
	  Plugin: 0,
	  PluginArray: 0,
	  SVGLengthList: 0,
	  SVGNumberList: 0,
	  SVGPathSegList: 0,
	  SVGPointList: 0,
	  SVGStringList: 0,
	  SVGTransformList: 0,
	  SourceBufferList: 0,
	  StyleSheetList: 0,
	  TextTrackCueList: 0,
	  TextTrackList: 0,
	  TouchList: 0
	};

	var TO_STRING_TAG$3 = wellKnownSymbol('toStringTag');

	for (var COLLECTION_NAME in domIterables) {
	  var Collection = global_1[COLLECTION_NAME];
	  var CollectionPrototype = Collection && Collection.prototype;
	  if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG$3) {
	    createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG$3, COLLECTION_NAME);
	  }
	  iterators[COLLECTION_NAME] = iterators.Array;
	}

	var promise$1 = path.Promise;

	var promise$2 = promise$1;

	var promise$3 = promise$2;

	// `IsArray` abstract operation
	// https://tc39.es/ecma262/#sec-isarray
	var isArray = Array.isArray || function isArray(arg) {
	  return classofRaw(arg) == 'Array';
	};

	var SPECIES$3 = wellKnownSymbol('species');

	// `ArraySpeciesCreate` abstract operation
	// https://tc39.es/ecma262/#sec-arrayspeciescreate
	var arraySpeciesCreate = function (originalArray, length) {
	  var C;
	  if (isArray(originalArray)) {
	    C = originalArray.constructor;
	    // cross-realm fallback
	    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
	    else if (isObject(C)) {
	      C = C[SPECIES$3];
	      if (C === null) C = undefined;
	    }
	  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
	};

	var push = [].push;

	// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
	var createMethod$3 = function (TYPE) {
	  var IS_MAP = TYPE == 1;
	  var IS_FILTER = TYPE == 2;
	  var IS_SOME = TYPE == 3;
	  var IS_EVERY = TYPE == 4;
	  var IS_FIND_INDEX = TYPE == 6;
	  var IS_FILTER_OUT = TYPE == 7;
	  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
	  return function ($this, callbackfn, that, specificCreate) {
	    var O = toObject($this);
	    var self = indexedObject(O);
	    var boundFunction = functionBindContext(callbackfn, that, 3);
	    var length = toLength(self.length);
	    var index = 0;
	    var create = specificCreate || arraySpeciesCreate;
	    var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
	    var value, result;
	    for (;length > index; index++) if (NO_HOLES || index in self) {
	      value = self[index];
	      result = boundFunction(value, index, O);
	      if (TYPE) {
	        if (IS_MAP) target[index] = result; // map
	        else if (result) switch (TYPE) {
	          case 3: return true;              // some
	          case 5: return value;             // find
	          case 6: return index;             // findIndex
	          case 2: push.call(target, value); // filter
	        } else switch (TYPE) {
	          case 4: return false;             // every
	          case 7: push.call(target, value); // filterOut
	        }
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
	  };
	};

	var arrayIteration = {
	  // `Array.prototype.forEach` method
	  // https://tc39.es/ecma262/#sec-array.prototype.foreach
	  forEach: createMethod$3(0),
	  // `Array.prototype.map` method
	  // https://tc39.es/ecma262/#sec-array.prototype.map
	  map: createMethod$3(1),
	  // `Array.prototype.filter` method
	  // https://tc39.es/ecma262/#sec-array.prototype.filter
	  filter: createMethod$3(2),
	  // `Array.prototype.some` method
	  // https://tc39.es/ecma262/#sec-array.prototype.some
	  some: createMethod$3(3),
	  // `Array.prototype.every` method
	  // https://tc39.es/ecma262/#sec-array.prototype.every
	  every: createMethod$3(4),
	  // `Array.prototype.find` method
	  // https://tc39.es/ecma262/#sec-array.prototype.find
	  find: createMethod$3(5),
	  // `Array.prototype.findIndex` method
	  // https://tc39.es/ecma262/#sec-array.prototype.findIndex
	  findIndex: createMethod$3(6),
	  // `Array.prototype.filterOut` method
	  // https://github.com/tc39/proposal-array-filtering
	  filterOut: createMethod$3(7)
	};

	var SPECIES$4 = wellKnownSymbol('species');

	var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
	  // We can't use this feature detection in V8 since it causes
	  // deoptimization and serious performance degradation
	  // https://github.com/zloirock/core-js/issues/677
	  return engineV8Version >= 51 || !fails(function () {
	    var array = [];
	    var constructor = array.constructor = {};
	    constructor[SPECIES$4] = function () {
	      return { foo: 1 };
	    };
	    return array[METHOD_NAME](Boolean).foo !== 1;
	  });
	};

	var $filter = arrayIteration.filter;


	var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');

	// `Array.prototype.filter` method
	// https://tc39.es/ecma262/#sec-array.prototype.filter
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var filter = entryVirtual('Array').filter;

	var ArrayPrototype$2 = Array.prototype;

	var filter_1 = function (it) {
	  var own = it.filter;
	  return it === ArrayPrototype$2 || (it instanceof Array && own === ArrayPrototype$2.filter) ? filter : own;
	};

	var filter$1 = filter_1;

	var filter$2 = filter$1;

	var arrayMethodIsStrict = function (METHOD_NAME, argument) {
	  var method = [][METHOD_NAME];
	  return !!method && fails(function () {
	    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
	    method.call(null, argument || function () { throw 1; }, 1);
	  });
	};

	var $forEach = arrayIteration.forEach;


	var STRICT_METHOD = arrayMethodIsStrict('forEach');

	// `Array.prototype.forEach` method implementation
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	var arrayForEach = !STRICT_METHOD ? function forEach(callbackfn /* , thisArg */) {
	  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	} : [].forEach;

	// `Array.prototype.forEach` method
	// https://tc39.es/ecma262/#sec-array.prototype.foreach
	_export({ target: 'Array', proto: true, forced: [].forEach != arrayForEach }, {
	  forEach: arrayForEach
	});

	var forEach = entryVirtual('Array').forEach;

	var forEach$1 = forEach;

	var ArrayPrototype$3 = Array.prototype;

	var DOMIterables = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var forEach_1 = function (it) {
	  var own = it.forEach;
	  return it === ArrayPrototype$3 || (it instanceof Array && own === ArrayPrototype$3.forEach)
	    // eslint-disable-next-line no-prototype-builtins -- safe
	    || DOMIterables.hasOwnProperty(classof(it)) ? forEach$1 : own;
	};

	var forEach$2 = forEach_1;

	// `Object.fromEntries` method
	// https://github.com/tc39/proposal-object-from-entries
	_export({ target: 'Object', stat: true }, {
	  fromEntries: function fromEntries(iterable) {
	    var obj = {};
	    iterate(iterable, function (k, v) {
	      createProperty(obj, k, v);
	    }, { AS_ENTRIES: true });
	    return obj;
	  }
	});

	var fromEntries = path.Object.fromEntries;

	var fromEntries$1 = fromEntries;

	var fromEntries$2 = fromEntries$1;

	// `Object.defineProperty` method
	// https://tc39.es/ecma262/#sec-object.defineproperty
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperty: objectDefineProperty.f
	});

	var defineProperty_1 = createCommonjsModule(function (module) {
	var Object = path.Object;

	var defineProperty = module.exports = function defineProperty(it, key, desc) {
	  return Object.defineProperty(it, key, desc);
	};

	if (Object.defineProperty.sham) defineProperty.sham = true;
	});

	var defineProperty$2 = defineProperty_1;

	var defineProperty$3 = defineProperty$2;

	// `Object.defineProperties` method
	// https://tc39.es/ecma262/#sec-object.defineproperties
	_export({ target: 'Object', stat: true, forced: !descriptors, sham: !descriptors }, {
	  defineProperties: objectDefineProperties
	});

	var defineProperties_1 = createCommonjsModule(function (module) {
	var Object = path.Object;

	var defineProperties = module.exports = function defineProperties(T, D) {
	  return Object.defineProperties(T, D);
	};

	if (Object.defineProperties.sham) defineProperties.sham = true;
	});

	var defineProperties = defineProperties_1;

	var defineProperties$1 = defineProperties;

	var hiddenKeys$1 = enumBugKeys.concat('length', 'prototype');

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	var f$5 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
	  return objectKeysInternal(O, hiddenKeys$1);
	};

	var objectGetOwnPropertyNames = {
		f: f$5
	};

	// all object keys, includes non-enumerable and symbols
	var ownKeys = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
	  var keys = objectGetOwnPropertyNames.f(anObject(it));
	  var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
	  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
	};

	// `Object.getOwnPropertyDescriptors` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
	    var O = toIndexedObject(object);
	    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
	    var keys = ownKeys(O);
	    var result = {};
	    var index = 0;
	    var key, descriptor;
	    while (keys.length > index) {
	      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
	      if (descriptor !== undefined) createProperty(result, key, descriptor);
	    }
	    return result;
	  }
	});

	var getOwnPropertyDescriptors = path.Object.getOwnPropertyDescriptors;

	var getOwnPropertyDescriptors$1 = getOwnPropertyDescriptors;

	var getOwnPropertyDescriptors$2 = getOwnPropertyDescriptors$1;

	var nativeGetOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;


	var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor$1(1); });
	var FORCED$3 = !descriptors || FAILS_ON_PRIMITIVES;

	// `Object.getOwnPropertyDescriptor` method
	// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
	_export({ target: 'Object', stat: true, forced: FORCED$3, sham: !descriptors }, {
	  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
	    return nativeGetOwnPropertyDescriptor$1(toIndexedObject(it), key);
	  }
	});

	var getOwnPropertyDescriptor_1 = createCommonjsModule(function (module) {
	var Object = path.Object;

	var getOwnPropertyDescriptor = module.exports = function getOwnPropertyDescriptor(it, key) {
	  return Object.getOwnPropertyDescriptor(it, key);
	};

	if (Object.getOwnPropertyDescriptor.sham) getOwnPropertyDescriptor.sham = true;
	});

	var getOwnPropertyDescriptor$3 = getOwnPropertyDescriptor_1;

	var getOwnPropertyDescriptor$4 = getOwnPropertyDescriptor$3;

	var nativeGetOwnPropertyNames = objectGetOwnPropertyNames.f;

	var toString$1 = {}.toString;

	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];

	var getWindowNames = function (it) {
	  try {
	    return nativeGetOwnPropertyNames(it);
	  } catch (error) {
	    return windowNames.slice();
	  }
	};

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var f$6 = function getOwnPropertyNames(it) {
	  return windowNames && toString$1.call(it) == '[object Window]'
	    ? getWindowNames(it)
	    : nativeGetOwnPropertyNames(toIndexedObject(it));
	};

	var objectGetOwnPropertyNamesExternal = {
		f: f$6
	};

	var f$7 = wellKnownSymbol;

	var wellKnownSymbolWrapped = {
		f: f$7
	};

	var defineProperty$4 = objectDefineProperty.f;

	var defineWellKnownSymbol = function (NAME) {
	  var Symbol = path.Symbol || (path.Symbol = {});
	  if (!has(Symbol, NAME)) defineProperty$4(Symbol, NAME, {
	    value: wellKnownSymbolWrapped.f(NAME)
	  });
	};

	var $forEach$1 = arrayIteration.forEach;

	var HIDDEN = sharedKey('hidden');
	var SYMBOL = 'Symbol';
	var PROTOTYPE$1 = 'prototype';
	var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
	var setInternalState$5 = internalState.set;
	var getInternalState$3 = internalState.getterFor(SYMBOL);
	var ObjectPrototype$1 = Object[PROTOTYPE$1];
	var $Symbol = global_1.Symbol;
	var $stringify$1 = getBuiltIn('JSON', 'stringify');
	var nativeGetOwnPropertyDescriptor$2 = objectGetOwnPropertyDescriptor.f;
	var nativeDefineProperty$1 = objectDefineProperty.f;
	var nativeGetOwnPropertyNames$1 = objectGetOwnPropertyNamesExternal.f;
	var nativePropertyIsEnumerable$1 = objectPropertyIsEnumerable.f;
	var AllSymbols = shared('symbols');
	var ObjectPrototypeSymbols = shared('op-symbols');
	var StringToSymbolRegistry = shared('string-to-symbol-registry');
	var SymbolToStringRegistry = shared('symbol-to-string-registry');
	var WellKnownSymbolsStore$1 = shared('wks');
	var QObject = global_1.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var USE_SETTER = !QObject || !QObject[PROTOTYPE$1] || !QObject[PROTOTYPE$1].findChild;

	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDescriptor = descriptors && fails(function () {
	  return objectCreate(nativeDefineProperty$1({}, 'a', {
	    get: function () { return nativeDefineProperty$1(this, 'a', { value: 7 }).a; }
	  })).a != 7;
	}) ? function (O, P, Attributes) {
	  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor$2(ObjectPrototype$1, P);
	  if (ObjectPrototypeDescriptor) delete ObjectPrototype$1[P];
	  nativeDefineProperty$1(O, P, Attributes);
	  if (ObjectPrototypeDescriptor && O !== ObjectPrototype$1) {
	    nativeDefineProperty$1(ObjectPrototype$1, P, ObjectPrototypeDescriptor);
	  }
	} : nativeDefineProperty$1;

	var wrap$1 = function (tag, description) {
	  var symbol = AllSymbols[tag] = objectCreate($Symbol[PROTOTYPE$1]);
	  setInternalState$5(symbol, {
	    type: SYMBOL,
	    tag: tag,
	    description: description
	  });
	  if (!descriptors) symbol.description = description;
	  return symbol;
	};

	var isSymbol = useSymbolAsUid ? function (it) {
	  return typeof it == 'symbol';
	} : function (it) {
	  return Object(it) instanceof $Symbol;
	};

	var $defineProperty = function defineProperty(O, P, Attributes) {
	  if (O === ObjectPrototype$1) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
	  anObject(O);
	  var key = toPrimitive(P, true);
	  anObject(Attributes);
	  if (has(AllSymbols, key)) {
	    if (!Attributes.enumerable) {
	      if (!has(O, HIDDEN)) nativeDefineProperty$1(O, HIDDEN, createPropertyDescriptor(1, {}));
	      O[HIDDEN][key] = true;
	    } else {
	      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
	      Attributes = objectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
	    } return setSymbolDescriptor(O, key, Attributes);
	  } return nativeDefineProperty$1(O, key, Attributes);
	};

	var $defineProperties = function defineProperties(O, Properties) {
	  anObject(O);
	  var properties = toIndexedObject(Properties);
	  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
	  $forEach$1(keys, function (key) {
	    if (!descriptors || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
	  });
	  return O;
	};

	var $create = function create(O, Properties) {
	  return Properties === undefined ? objectCreate(O) : $defineProperties(objectCreate(O), Properties);
	};

	var $propertyIsEnumerable = function propertyIsEnumerable(V) {
	  var P = toPrimitive(V, true);
	  var enumerable = nativePropertyIsEnumerable$1.call(this, P);
	  if (this === ObjectPrototype$1 && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
	  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
	};

	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
	  var it = toIndexedObject(O);
	  var key = toPrimitive(P, true);
	  if (it === ObjectPrototype$1 && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
	  var descriptor = nativeGetOwnPropertyDescriptor$2(it, key);
	  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
	    descriptor.enumerable = true;
	  }
	  return descriptor;
	};

	var $getOwnPropertyNames = function getOwnPropertyNames(O) {
	  var names = nativeGetOwnPropertyNames$1(toIndexedObject(O));
	  var result = [];
	  $forEach$1(names, function (key) {
	    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
	  });
	  return result;
	};

	var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
	  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype$1;
	  var names = nativeGetOwnPropertyNames$1(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
	  var result = [];
	  $forEach$1(names, function (key) {
	    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype$1, key))) {
	      result.push(AllSymbols[key]);
	    }
	  });
	  return result;
	};

	// `Symbol` constructor
	// https://tc39.es/ecma262/#sec-symbol-constructor
	if (!nativeSymbol) {
	  $Symbol = function Symbol() {
	    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
	    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
	    var tag = uid(description);
	    var setter = function (value) {
	      if (this === ObjectPrototype$1) setter.call(ObjectPrototypeSymbols, value);
	      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
	      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
	    };
	    if (descriptors && USE_SETTER) setSymbolDescriptor(ObjectPrototype$1, tag, { configurable: true, set: setter });
	    return wrap$1(tag, description);
	  };

	  redefine($Symbol[PROTOTYPE$1], 'toString', function toString() {
	    return getInternalState$3(this).tag;
	  });

	  redefine($Symbol, 'withoutSetter', function (description) {
	    return wrap$1(uid(description), description);
	  });

	  objectPropertyIsEnumerable.f = $propertyIsEnumerable;
	  objectDefineProperty.f = $defineProperty;
	  objectGetOwnPropertyDescriptor.f = $getOwnPropertyDescriptor;
	  objectGetOwnPropertyNames.f = objectGetOwnPropertyNamesExternal.f = $getOwnPropertyNames;
	  objectGetOwnPropertySymbols.f = $getOwnPropertySymbols;

	  wellKnownSymbolWrapped.f = function (name) {
	    return wrap$1(wellKnownSymbol(name), name);
	  };

	  if (descriptors) {
	    // https://github.com/tc39/proposal-Symbol-description
	    nativeDefineProperty$1($Symbol[PROTOTYPE$1], 'description', {
	      configurable: true,
	      get: function description() {
	        return getInternalState$3(this).description;
	      }
	    });
	  }
	}

	_export({ global: true, wrap: true, forced: !nativeSymbol, sham: !nativeSymbol }, {
	  Symbol: $Symbol
	});

	$forEach$1(objectKeys(WellKnownSymbolsStore$1), function (name) {
	  defineWellKnownSymbol(name);
	});

	_export({ target: SYMBOL, stat: true, forced: !nativeSymbol }, {
	  // `Symbol.for` method
	  // https://tc39.es/ecma262/#sec-symbol.for
	  'for': function (key) {
	    var string = String(key);
	    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
	    var symbol = $Symbol(string);
	    StringToSymbolRegistry[string] = symbol;
	    SymbolToStringRegistry[symbol] = string;
	    return symbol;
	  },
	  // `Symbol.keyFor` method
	  // https://tc39.es/ecma262/#sec-symbol.keyfor
	  keyFor: function keyFor(sym) {
	    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
	    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
	  },
	  useSetter: function () { USE_SETTER = true; },
	  useSimple: function () { USE_SETTER = false; }
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol, sham: !descriptors }, {
	  // `Object.create` method
	  // https://tc39.es/ecma262/#sec-object.create
	  create: $create,
	  // `Object.defineProperty` method
	  // https://tc39.es/ecma262/#sec-object.defineproperty
	  defineProperty: $defineProperty,
	  // `Object.defineProperties` method
	  // https://tc39.es/ecma262/#sec-object.defineproperties
	  defineProperties: $defineProperties,
	  // `Object.getOwnPropertyDescriptor` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptors
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
	});

	_export({ target: 'Object', stat: true, forced: !nativeSymbol }, {
	  // `Object.getOwnPropertyNames` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertynames
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // `Object.getOwnPropertySymbols` method
	  // https://tc39.es/ecma262/#sec-object.getownpropertysymbols
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});

	// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
	// https://bugs.chromium.org/p/v8/issues/detail?id=3443
	_export({ target: 'Object', stat: true, forced: fails(function () { objectGetOwnPropertySymbols.f(1); }) }, {
	  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
	    return objectGetOwnPropertySymbols.f(toObject(it));
	  }
	});

	// `JSON.stringify` method behavior with symbols
	// https://tc39.es/ecma262/#sec-json.stringify
	if ($stringify$1) {
	  var FORCED_JSON_STRINGIFY = !nativeSymbol || fails(function () {
	    var symbol = $Symbol();
	    // MS Edge converts symbol values to JSON as {}
	    return $stringify$1([symbol]) != '[null]'
	      // WebKit converts symbol values to JSON as null
	      || $stringify$1({ a: symbol }) != '{}'
	      // V8 throws on boxed symbols
	      || $stringify$1(Object(symbol)) != '{}';
	  });

	  _export({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
	    // eslint-disable-next-line no-unused-vars -- required for `.length`
	    stringify: function stringify(it, replacer, space) {
	      var args = [it];
	      var index = 1;
	      var $replacer;
	      while (arguments.length > index) args.push(arguments[index++]);
	      $replacer = replacer;
	      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
	      if (!isArray(replacer)) replacer = function (key, value) {
	        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
	        if (!isSymbol(value)) return value;
	      };
	      args[1] = replacer;
	      return $stringify$1.apply(null, args);
	    }
	  });
	}

	// `Symbol.prototype[@@toPrimitive]` method
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@toprimitive
	if (!$Symbol[PROTOTYPE$1][TO_PRIMITIVE]) {
	  createNonEnumerableProperty($Symbol[PROTOTYPE$1], TO_PRIMITIVE, $Symbol[PROTOTYPE$1].valueOf);
	}
	// `Symbol.prototype[@@toStringTag]` property
	// https://tc39.es/ecma262/#sec-symbol.prototype-@@tostringtag
	setToStringTag($Symbol, SYMBOL);

	hiddenKeys[HIDDEN] = true;

	var getOwnPropertySymbols = path.Object.getOwnPropertySymbols;

	var getOwnPropertySymbols$1 = getOwnPropertySymbols;

	var getOwnPropertySymbols$2 = getOwnPropertySymbols$1;

	var FAILS_ON_PRIMITIVES$1 = fails(function () { objectKeys(1); });

	// `Object.keys` method
	// https://tc39.es/ecma262/#sec-object.keys
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$1 }, {
	  keys: function keys(it) {
	    return objectKeys(toObject(it));
	  }
	});

	var keys$1 = path.Object.keys;

	var keys$2 = keys$1;

	var keys$3 = keys$2;

	// `Array.isArray` method
	// https://tc39.es/ecma262/#sec-array.isarray
	_export({ target: 'Array', stat: true }, {
	  isArray: isArray
	});

	var isArray$1 = path.Array.isArray;

	var isArray$2 = isArray$1;

	var isArray$3 = isArray$2;

	var $map = arrayIteration.map;


	var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport('map');

	// `Array.prototype.map` method
	// https://tc39.es/ecma262/#sec-array.prototype.map
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$1 }, {
	  map: function map(callbackfn /* , thisArg */) {
	    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var map = entryVirtual('Array').map;

	var ArrayPrototype$4 = Array.prototype;

	var map_1 = function (it) {
	  var own = it.map;
	  return it === ArrayPrototype$4 || (it instanceof Array && own === ArrayPrototype$4.map) ? map : own;
	};

	var map$1 = map_1;

	var map$2 = map$1;

	// `Array.prototype.{ reduce, reduceRight }` methods implementation
	var createMethod$4 = function (IS_RIGHT) {
	  return function (that, callbackfn, argumentsLength, memo) {
	    aFunction(callbackfn);
	    var O = toObject(that);
	    var self = indexedObject(O);
	    var length = toLength(O.length);
	    var index = IS_RIGHT ? length - 1 : 0;
	    var i = IS_RIGHT ? -1 : 1;
	    if (argumentsLength < 2) while (true) {
	      if (index in self) {
	        memo = self[index];
	        index += i;
	        break;
	      }
	      index += i;
	      if (IS_RIGHT ? index < 0 : length <= index) {
	        throw TypeError('Reduce of empty array with no initial value');
	      }
	    }
	    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
	      memo = callbackfn(memo, self[index], index, O);
	    }
	    return memo;
	  };
	};

	var arrayReduce = {
	  // `Array.prototype.reduce` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduce
	  left: createMethod$4(false),
	  // `Array.prototype.reduceRight` method
	  // https://tc39.es/ecma262/#sec-array.prototype.reduceright
	  right: createMethod$4(true)
	};

	var $reduce = arrayReduce.left;




	var STRICT_METHOD$1 = arrayMethodIsStrict('reduce');
	// Chrome 80-82 has a critical bug
	// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982
	var CHROME_BUG = !engineIsNode && engineV8Version > 79 && engineV8Version < 83;

	// `Array.prototype.reduce` method
	// https://tc39.es/ecma262/#sec-array.prototype.reduce
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$1 || CHROME_BUG }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var reduce = entryVirtual('Array').reduce;

	var ArrayPrototype$5 = Array.prototype;

	var reduce_1 = function (it) {
	  var own = it.reduce;
	  return it === ArrayPrototype$5 || (it instanceof Array && own === ArrayPrototype$5.reduce) ? reduce : own;
	};

	var reduce$1 = reduce_1;

	var reduce$2 = reduce$1;

	var defineProperty$5 = defineProperty_1;

	var defineProperty$6 = defineProperty$5;

	var defineProperty$7 = createCommonjsModule(function (module) {
	function _defineProperty(obj, key, value) {
	  if (key in obj) {
	    defineProperty$6(obj, key, {
	      value: value,
	      enumerable: true,
	      configurable: true,
	      writable: true
	    });
	  } else {
	    obj[key] = value;
	  }

	  return obj;
	}

	module.exports = _defineProperty;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _defineProperty = unwrapExports(defineProperty$7);

	// `Object.create` method
	// https://tc39.es/ecma262/#sec-object.create
	_export({ target: 'Object', stat: true, sham: !descriptors }, {
	  create: objectCreate
	});

	var Object$1 = path.Object;

	var create = function create(P, D) {
	  return Object$1.create(P, D);
	};

	var create$1 = create;

	var create$2 = create$1;

	var AnswersCore_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.AnswersCore = void 0;
	  /**
	   * Provides methods for executing searches, submitting questions, and performing autocompletes.
	   *
	   * @public
	   */

	  var AnswersCore = /*#__PURE__*/function () {
	    /** @internal */
	    function AnswersCore(searchService, questionSubmissionService, autoCompleteService) {
	      this.searchService = searchService;
	      this.questionSubmissionService = questionSubmissionService;
	      this.autoCompleteService = autoCompleteService;
	    }
	    /**
	     * Performs an Answers search across all verticals.
	     *
	     * @remarks
	     * If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @param request - Universal search request options
	     */


	    var _proto = AnswersCore.prototype;

	    _proto.universalSearch = function universalSearch(request) {
	      return this.searchService.universalSearch(request);
	    }
	    /**
	     * Performs an Answers search for a single vertical.
	     *
	     * @remarks
	     * If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @param request - Vertical search request options
	     */
	    ;

	    _proto.verticalSearch = function verticalSearch(request) {
	      return this.searchService.verticalSearch(request);
	    }
	    /**
	     * Submits a custom question to the Answers API.
	     *
	     * @remarks
	     * If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @param request - Question submission request options
	     */
	    ;

	    _proto.submitQuestion = function submitQuestion(request) {
	      return this.questionSubmissionService.submitQuestion(request);
	    }
	    /**
	     * Performs an autocomplete request across all verticals.
	     *
	     * @remarks
	     * If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @param request - Universal autocomplete request options
	     */
	    ;

	    _proto.universalAutocomplete = function universalAutocomplete(request) {
	      return this.autoCompleteService.universalAutocomplete(request);
	    }
	    /**
	     * Performs an autocomplete request for a single vertical.
	     *
	     * @remarks
	     * If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @param request - Vertical autocomplete request options
	     */
	    ;

	    _proto.verticalAutocomplete = function verticalAutocomplete(request) {
	      return this.autoCompleteService.verticalAutocomplete(request);
	    }
	    /**
	     * Performs a filtersearch request against specified fields within a single vertical.
	     *
	     * @remarks
	     * This differs from the vertical autocomplete because the vertical autocomplete operates on all entity fields whereas
	     * filtersearch operates only on specified fields. If rejected, the reason will be an {@link AnswersError}.
	     *
	     * @example
	     * A site has a 'products' vertical and would like a way to allow the user to narrow down the results by the product name.
	     * The site can add a second search bar powered by filtersearch which will include only product names as search
	     * suggestions.
	     *
	     * @param request - filtersearch request options
	     */
	    ;

	    _proto.filterSearch = function filterSearch(request) {
	      return this.autoCompleteService.filterSearch(request);
	    };

	    return AnswersCore;
	  }();

	  exports.AnswersCore = AnswersCore;
	});
	unwrapExports(AnswersCore_1);
	var AnswersCore_2 = AnswersCore_1.AnswersCore;

	var runtime = createCommonjsModule(function (module) {
	/**
	 * Copyright (c) 2014-present, Facebook, Inc.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */

	var regeneratorRuntime = (function (exports) {

	  var Op = Object.prototype;
	  var hasOwn = Op.hasOwnProperty;
	  var undefined$1; // More compressible than void 0.
	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

	  function wrap(innerFn, outerFn, self, tryLocsList) {
	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
	    var generator = Object.create(protoGenerator.prototype);
	    var context = new Context(tryLocsList || []);

	    // The ._invoke method unifies the implementations of the .next,
	    // .throw, and .return methods.
	    generator._invoke = makeInvokeMethod(innerFn, self, context);

	    return generator;
	  }
	  exports.wrap = wrap;

	  // Try/catch helper to minimize deoptimizations. Returns a completion
	  // record like context.tryEntries[i].completion. This interface could
	  // have been (and was previously) designed to take a closure to be
	  // invoked without arguments, but in all the cases we care about we
	  // already have an existing method we want to call, so there's no need
	  // to create a new function object. We can even get away with assuming
	  // the method takes exactly one argument, since that happens to be true
	  // in every case, so we don't have to touch the arguments object. The
	  // only additional allocation required is the completion record, which
	  // has a stable shape and so hopefully should be cheap to allocate.
	  function tryCatch(fn, obj, arg) {
	    try {
	      return { type: "normal", arg: fn.call(obj, arg) };
	    } catch (err) {
	      return { type: "throw", arg: err };
	    }
	  }

	  var GenStateSuspendedStart = "suspendedStart";
	  var GenStateSuspendedYield = "suspendedYield";
	  var GenStateExecuting = "executing";
	  var GenStateCompleted = "completed";

	  // Returning this object from the innerFn has the same effect as
	  // breaking out of the dispatch switch statement.
	  var ContinueSentinel = {};

	  // Dummy constructor functions that we use as the .constructor and
	  // .constructor.prototype properties for functions that return Generator
	  // objects. For full spec compliance, you may wish to configure your
	  // minifier not to mangle the names of these two functions.
	  function Generator() {}
	  function GeneratorFunction() {}
	  function GeneratorFunctionPrototype() {}

	  // This is a polyfill for %IteratorPrototype% for environments that
	  // don't natively support it.
	  var IteratorPrototype = {};
	  IteratorPrototype[iteratorSymbol] = function () {
	    return this;
	  };

	  var getProto = Object.getPrototypeOf;
	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
	  if (NativeIteratorPrototype &&
	      NativeIteratorPrototype !== Op &&
	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
	    // This environment has a native %IteratorPrototype%; use it instead
	    // of the polyfill.
	    IteratorPrototype = NativeIteratorPrototype;
	  }

	  var Gp = GeneratorFunctionPrototype.prototype =
	    Generator.prototype = Object.create(IteratorPrototype);
	  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
	  GeneratorFunctionPrototype.constructor = GeneratorFunction;
	  GeneratorFunctionPrototype[toStringTagSymbol] =
	    GeneratorFunction.displayName = "GeneratorFunction";

	  // Helper for defining the .next, .throw, and .return methods of the
	  // Iterator interface in terms of a single ._invoke method.
	  function defineIteratorMethods(prototype) {
	    ["next", "throw", "return"].forEach(function(method) {
	      prototype[method] = function(arg) {
	        return this._invoke(method, arg);
	      };
	    });
	  }

	  exports.isGeneratorFunction = function(genFun) {
	    var ctor = typeof genFun === "function" && genFun.constructor;
	    return ctor
	      ? ctor === GeneratorFunction ||
	        // For the native GeneratorFunction constructor, the best we can
	        // do is to check its .name property.
	        (ctor.displayName || ctor.name) === "GeneratorFunction"
	      : false;
	  };

	  exports.mark = function(genFun) {
	    if (Object.setPrototypeOf) {
	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
	    } else {
	      genFun.__proto__ = GeneratorFunctionPrototype;
	      if (!(toStringTagSymbol in genFun)) {
	        genFun[toStringTagSymbol] = "GeneratorFunction";
	      }
	    }
	    genFun.prototype = Object.create(Gp);
	    return genFun;
	  };

	  // Within the body of any async function, `await x` is transformed to
	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
	  // meant to be awaited.
	  exports.awrap = function(arg) {
	    return { __await: arg };
	  };

	  function AsyncIterator(generator) {
	    function invoke(method, arg, resolve, reject) {
	      var record = tryCatch(generator[method], generator, arg);
	      if (record.type === "throw") {
	        reject(record.arg);
	      } else {
	        var result = record.arg;
	        var value = result.value;
	        if (value &&
	            typeof value === "object" &&
	            hasOwn.call(value, "__await")) {
	          return Promise.resolve(value.__await).then(function(value) {
	            invoke("next", value, resolve, reject);
	          }, function(err) {
	            invoke("throw", err, resolve, reject);
	          });
	        }

	        return Promise.resolve(value).then(function(unwrapped) {
	          // When a yielded Promise is resolved, its final value becomes
	          // the .value of the Promise<{value,done}> result for the
	          // current iteration.
	          result.value = unwrapped;
	          resolve(result);
	        }, function(error) {
	          // If a rejected Promise was yielded, throw the rejection back
	          // into the async generator function so it can be handled there.
	          return invoke("throw", error, resolve, reject);
	        });
	      }
	    }

	    var previousPromise;

	    function enqueue(method, arg) {
	      function callInvokeWithMethodAndArg() {
	        return new Promise(function(resolve, reject) {
	          invoke(method, arg, resolve, reject);
	        });
	      }

	      return previousPromise =
	        // If enqueue has been called before, then we want to wait until
	        // all previous Promises have been resolved before calling invoke,
	        // so that results are always delivered in the correct order. If
	        // enqueue has not been called before, then it is important to
	        // call invoke immediately, without waiting on a callback to fire,
	        // so that the async generator function has the opportunity to do
	        // any necessary setup in a predictable way. This predictability
	        // is why the Promise constructor synchronously invokes its
	        // executor callback, and why async functions synchronously
	        // execute code before the first await. Since we implement simple
	        // async functions in terms of async generators, it is especially
	        // important to get this right, even though it requires care.
	        previousPromise ? previousPromise.then(
	          callInvokeWithMethodAndArg,
	          // Avoid propagating failures to Promises returned by later
	          // invocations of the iterator.
	          callInvokeWithMethodAndArg
	        ) : callInvokeWithMethodAndArg();
	    }

	    // Define the unified helper method that is used to implement .next,
	    // .throw, and .return (see defineIteratorMethods).
	    this._invoke = enqueue;
	  }

	  defineIteratorMethods(AsyncIterator.prototype);
	  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
	    return this;
	  };
	  exports.AsyncIterator = AsyncIterator;

	  // Note that simple async functions are implemented on top of
	  // AsyncIterator objects; they just return a Promise for the value of
	  // the final result produced by the iterator.
	  exports.async = function(innerFn, outerFn, self, tryLocsList) {
	    var iter = new AsyncIterator(
	      wrap(innerFn, outerFn, self, tryLocsList)
	    );

	    return exports.isGeneratorFunction(outerFn)
	      ? iter // If outerFn is a generator, return the full iterator.
	      : iter.next().then(function(result) {
	          return result.done ? result.value : iter.next();
	        });
	  };

	  function makeInvokeMethod(innerFn, self, context) {
	    var state = GenStateSuspendedStart;

	    return function invoke(method, arg) {
	      if (state === GenStateExecuting) {
	        throw new Error("Generator is already running");
	      }

	      if (state === GenStateCompleted) {
	        if (method === "throw") {
	          throw arg;
	        }

	        // Be forgiving, per 25.3.3.3.3 of the spec:
	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
	        return doneResult();
	      }

	      context.method = method;
	      context.arg = arg;

	      while (true) {
	        var delegate = context.delegate;
	        if (delegate) {
	          var delegateResult = maybeInvokeDelegate(delegate, context);
	          if (delegateResult) {
	            if (delegateResult === ContinueSentinel) continue;
	            return delegateResult;
	          }
	        }

	        if (context.method === "next") {
	          // Setting context._sent for legacy support of Babel's
	          // function.sent implementation.
	          context.sent = context._sent = context.arg;

	        } else if (context.method === "throw") {
	          if (state === GenStateSuspendedStart) {
	            state = GenStateCompleted;
	            throw context.arg;
	          }

	          context.dispatchException(context.arg);

	        } else if (context.method === "return") {
	          context.abrupt("return", context.arg);
	        }

	        state = GenStateExecuting;

	        var record = tryCatch(innerFn, self, context);
	        if (record.type === "normal") {
	          // If an exception is thrown from innerFn, we leave state ===
	          // GenStateExecuting and loop back for another invocation.
	          state = context.done
	            ? GenStateCompleted
	            : GenStateSuspendedYield;

	          if (record.arg === ContinueSentinel) {
	            continue;
	          }

	          return {
	            value: record.arg,
	            done: context.done
	          };

	        } else if (record.type === "throw") {
	          state = GenStateCompleted;
	          // Dispatch the exception by looping back around to the
	          // context.dispatchException(context.arg) call above.
	          context.method = "throw";
	          context.arg = record.arg;
	        }
	      }
	    };
	  }

	  // Call delegate.iterator[context.method](context.arg) and handle the
	  // result, either by returning a { value, done } result from the
	  // delegate iterator, or by modifying context.method and context.arg,
	  // setting context.delegate to null, and returning the ContinueSentinel.
	  function maybeInvokeDelegate(delegate, context) {
	    var method = delegate.iterator[context.method];
	    if (method === undefined$1) {
	      // A .throw or .return when the delegate iterator has no .throw
	      // method always terminates the yield* loop.
	      context.delegate = null;

	      if (context.method === "throw") {
	        // Note: ["return"] must be used for ES3 parsing compatibility.
	        if (delegate.iterator["return"]) {
	          // If the delegate iterator has a return method, give it a
	          // chance to clean up.
	          context.method = "return";
	          context.arg = undefined$1;
	          maybeInvokeDelegate(delegate, context);

	          if (context.method === "throw") {
	            // If maybeInvokeDelegate(context) changed context.method from
	            // "return" to "throw", let that override the TypeError below.
	            return ContinueSentinel;
	          }
	        }

	        context.method = "throw";
	        context.arg = new TypeError(
	          "The iterator does not provide a 'throw' method");
	      }

	      return ContinueSentinel;
	    }

	    var record = tryCatch(method, delegate.iterator, context.arg);

	    if (record.type === "throw") {
	      context.method = "throw";
	      context.arg = record.arg;
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    var info = record.arg;

	    if (! info) {
	      context.method = "throw";
	      context.arg = new TypeError("iterator result is not an object");
	      context.delegate = null;
	      return ContinueSentinel;
	    }

	    if (info.done) {
	      // Assign the result of the finished delegate to the temporary
	      // variable specified by delegate.resultName (see delegateYield).
	      context[delegate.resultName] = info.value;

	      // Resume execution at the desired location (see delegateYield).
	      context.next = delegate.nextLoc;

	      // If context.method was "throw" but the delegate handled the
	      // exception, let the outer generator proceed normally. If
	      // context.method was "next", forget context.arg since it has been
	      // "consumed" by the delegate iterator. If context.method was
	      // "return", allow the original .return call to continue in the
	      // outer generator.
	      if (context.method !== "return") {
	        context.method = "next";
	        context.arg = undefined$1;
	      }

	    } else {
	      // Re-yield the result returned by the delegate method.
	      return info;
	    }

	    // The delegate iterator is finished, so forget it and continue with
	    // the outer generator.
	    context.delegate = null;
	    return ContinueSentinel;
	  }

	  // Define Generator.prototype.{next,throw,return} in terms of the
	  // unified ._invoke helper method.
	  defineIteratorMethods(Gp);

	  Gp[toStringTagSymbol] = "Generator";

	  // A Generator should always return itself as the iterator object when the
	  // @@iterator function is called on it. Some browsers' implementations of the
	  // iterator prototype chain incorrectly implement this, causing the Generator
	  // object to not be returned from this call. This ensures that doesn't happen.
	  // See https://github.com/facebook/regenerator/issues/274 for more details.
	  Gp[iteratorSymbol] = function() {
	    return this;
	  };

	  Gp.toString = function() {
	    return "[object Generator]";
	  };

	  function pushTryEntry(locs) {
	    var entry = { tryLoc: locs[0] };

	    if (1 in locs) {
	      entry.catchLoc = locs[1];
	    }

	    if (2 in locs) {
	      entry.finallyLoc = locs[2];
	      entry.afterLoc = locs[3];
	    }

	    this.tryEntries.push(entry);
	  }

	  function resetTryEntry(entry) {
	    var record = entry.completion || {};
	    record.type = "normal";
	    delete record.arg;
	    entry.completion = record;
	  }

	  function Context(tryLocsList) {
	    // The root entry object (effectively a try statement without a catch
	    // or a finally block) gives us a place to store values thrown from
	    // locations where there is no enclosing try statement.
	    this.tryEntries = [{ tryLoc: "root" }];
	    tryLocsList.forEach(pushTryEntry, this);
	    this.reset(true);
	  }

	  exports.keys = function(object) {
	    var keys = [];
	    for (var key in object) {
	      keys.push(key);
	    }
	    keys.reverse();

	    // Rather than returning an object with a next method, we keep
	    // things simple and return the next function itself.
	    return function next() {
	      while (keys.length) {
	        var key = keys.pop();
	        if (key in object) {
	          next.value = key;
	          next.done = false;
	          return next;
	        }
	      }

	      // To avoid creating an additional object, we just hang the .value
	      // and .done properties off the next function object itself. This
	      // also ensures that the minifier will not anonymize the function.
	      next.done = true;
	      return next;
	    };
	  };

	  function values(iterable) {
	    if (iterable) {
	      var iteratorMethod = iterable[iteratorSymbol];
	      if (iteratorMethod) {
	        return iteratorMethod.call(iterable);
	      }

	      if (typeof iterable.next === "function") {
	        return iterable;
	      }

	      if (!isNaN(iterable.length)) {
	        var i = -1, next = function next() {
	          while (++i < iterable.length) {
	            if (hasOwn.call(iterable, i)) {
	              next.value = iterable[i];
	              next.done = false;
	              return next;
	            }
	          }

	          next.value = undefined$1;
	          next.done = true;

	          return next;
	        };

	        return next.next = next;
	      }
	    }

	    // Return an iterator with no values.
	    return { next: doneResult };
	  }
	  exports.values = values;

	  function doneResult() {
	    return { value: undefined$1, done: true };
	  }

	  Context.prototype = {
	    constructor: Context,

	    reset: function(skipTempReset) {
	      this.prev = 0;
	      this.next = 0;
	      // Resetting context._sent for legacy support of Babel's
	      // function.sent implementation.
	      this.sent = this._sent = undefined$1;
	      this.done = false;
	      this.delegate = null;

	      this.method = "next";
	      this.arg = undefined$1;

	      this.tryEntries.forEach(resetTryEntry);

	      if (!skipTempReset) {
	        for (var name in this) {
	          // Not sure about the optimal order of these conditions:
	          if (name.charAt(0) === "t" &&
	              hasOwn.call(this, name) &&
	              !isNaN(+name.slice(1))) {
	            this[name] = undefined$1;
	          }
	        }
	      }
	    },

	    stop: function() {
	      this.done = true;

	      var rootEntry = this.tryEntries[0];
	      var rootRecord = rootEntry.completion;
	      if (rootRecord.type === "throw") {
	        throw rootRecord.arg;
	      }

	      return this.rval;
	    },

	    dispatchException: function(exception) {
	      if (this.done) {
	        throw exception;
	      }

	      var context = this;
	      function handle(loc, caught) {
	        record.type = "throw";
	        record.arg = exception;
	        context.next = loc;

	        if (caught) {
	          // If the dispatched exception was caught by a catch block,
	          // then let that catch block handle the exception normally.
	          context.method = "next";
	          context.arg = undefined$1;
	        }

	        return !! caught;
	      }

	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        var record = entry.completion;

	        if (entry.tryLoc === "root") {
	          // Exception thrown outside of any try block that could handle
	          // it, so set the completion value of the entire function to
	          // throw the exception.
	          return handle("end");
	        }

	        if (entry.tryLoc <= this.prev) {
	          var hasCatch = hasOwn.call(entry, "catchLoc");
	          var hasFinally = hasOwn.call(entry, "finallyLoc");

	          if (hasCatch && hasFinally) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            } else if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else if (hasCatch) {
	            if (this.prev < entry.catchLoc) {
	              return handle(entry.catchLoc, true);
	            }

	          } else if (hasFinally) {
	            if (this.prev < entry.finallyLoc) {
	              return handle(entry.finallyLoc);
	            }

	          } else {
	            throw new Error("try statement without catch or finally");
	          }
	        }
	      }
	    },

	    abrupt: function(type, arg) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc <= this.prev &&
	            hasOwn.call(entry, "finallyLoc") &&
	            this.prev < entry.finallyLoc) {
	          var finallyEntry = entry;
	          break;
	        }
	      }

	      if (finallyEntry &&
	          (type === "break" ||
	           type === "continue") &&
	          finallyEntry.tryLoc <= arg &&
	          arg <= finallyEntry.finallyLoc) {
	        // Ignore the finally entry if control is not jumping to a
	        // location outside the try/catch block.
	        finallyEntry = null;
	      }

	      var record = finallyEntry ? finallyEntry.completion : {};
	      record.type = type;
	      record.arg = arg;

	      if (finallyEntry) {
	        this.method = "next";
	        this.next = finallyEntry.finallyLoc;
	        return ContinueSentinel;
	      }

	      return this.complete(record);
	    },

	    complete: function(record, afterLoc) {
	      if (record.type === "throw") {
	        throw record.arg;
	      }

	      if (record.type === "break" ||
	          record.type === "continue") {
	        this.next = record.arg;
	      } else if (record.type === "return") {
	        this.rval = this.arg = record.arg;
	        this.method = "return";
	        this.next = "end";
	      } else if (record.type === "normal" && afterLoc) {
	        this.next = afterLoc;
	      }

	      return ContinueSentinel;
	    },

	    finish: function(finallyLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.finallyLoc === finallyLoc) {
	          this.complete(entry.completion, entry.afterLoc);
	          resetTryEntry(entry);
	          return ContinueSentinel;
	        }
	      }
	    },

	    "catch": function(tryLoc) {
	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
	        var entry = this.tryEntries[i];
	        if (entry.tryLoc === tryLoc) {
	          var record = entry.completion;
	          if (record.type === "throw") {
	            var thrown = record.arg;
	            resetTryEntry(entry);
	          }
	          return thrown;
	        }
	      }

	      // The context.catch method must only be called with a location
	      // argument that corresponds to a known catch block.
	      throw new Error("illegal catch attempt");
	    },

	    delegateYield: function(iterable, resultName, nextLoc) {
	      this.delegate = {
	        iterator: values(iterable),
	        resultName: resultName,
	        nextLoc: nextLoc
	      };

	      if (this.method === "next") {
	        // Deliberately forget the last sent value so that we don't
	        // accidentally pass it on to the delegate.
	        this.arg = undefined$1;
	      }

	      return ContinueSentinel;
	    }
	  };

	  // Regardless of whether this script is executing as a CommonJS module
	  // or not, return the runtime object so that we can declare the variable
	  // regeneratorRuntime in the outer scope, which allows this module to be
	  // injected easily by `bin/regenerator --include-runtime script.js`.
	  return exports;

	}(
	  // If this script is executing as a CommonJS module, use module.exports
	  // as the regeneratorRuntime namespace. Otherwise create a new empty
	  // object. Either way, the resulting object will be used to initialize
	  // the regeneratorRuntime variable at the top of this file.
	   module.exports
	));
	});

	var regenerator = runtime;

	var DirectAnswerType_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.DirectAnswerType = void 0;
	  /**
	   * Represents the type of direct answer.
	   *
	   * @public
	   */

	  var DirectAnswerType;

	  (function (DirectAnswerType) {
	    /** Indicates that the DirectAnswer is a {@link FeaturedSnippetDirectAnswer}. */
	    DirectAnswerType["FeaturedSnippet"] = "FEATURED_SNIPPET";
	    /** Indicates that the DirectAnswer is a {@link FieldValueDirectAnswer}. */

	    DirectAnswerType["FieldValue"] = "FIELD_VALUE";
	  })(DirectAnswerType = exports.DirectAnswerType || (exports.DirectAnswerType = {}));
	});
	unwrapExports(DirectAnswerType_1);
	var DirectAnswerType_2 = DirectAnswerType_1.DirectAnswerType;

	var Source_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.Source = void 0;
	  /**
	   * Represents the source of a {@link Result}.
	   *
	   * @public
	   */

	  var Source;

	  (function (Source) {
	    /** The result is from an Answers Knowledge Graph. */
	    Source["KnowledgeManager"] = "KNOWLEDGE_MANAGER";
	    /** The result is from Google Custom Search Engine. */

	    Source["Google"] = "GOOGLE_CSE";
	    /** The result is from Bing Search Engine. */

	    Source["Bing"] = "BING_CSE";
	    /** The result is from Zendesk. */

	    Source["Zendesk"] = "ZENDESK";
	    /** The result is from Algolia. */

	    Source["Algolia"] = "ALGOLIA";
	    /** The result was from a generic source. */

	    Source["Generic"] = "GENERIC";
	  })(Source = exports.Source || (exports.Source = {}));
	});
	unwrapExports(Source_1);
	var Source_2 = Source_1.Source;

	var ResultsFactory_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.ResultsFactory = void 0;
	  /**
	   * A factory which creates results from different sources
	   */

	  var ResultsFactory = /*#__PURE__*/function () {
	    function ResultsFactory() {}

	    ResultsFactory.create = function create(results, source) {
	      var _this = this;

	      if (!results) {
	        return [];
	      }

	      return map$2(results).call(results, function (result, index) {
	        var resultIndex = index + 1;

	        switch (source) {
	          case Source_1.Source.KnowledgeManager:
	            return _this.fromKnowledgeManager(result, resultIndex);

	          case Source_1.Source.Google:
	            return _this.fromGoogleCustomSearchEngine(result, resultIndex);

	          case Source_1.Source.Bing:
	            return _this.fromBingCustomSearchEngine(result, resultIndex);

	          case Source_1.Source.Zendesk:
	            return _this.fromZendeskSearchEngine(result, resultIndex);

	          case Source_1.Source.Algolia:
	            return _this.fromAlgoliaSearchEngine(result, resultIndex);

	          default:
	            return _this.fromGeneric(result, resultIndex);
	        }
	      });
	    };

	    ResultsFactory.fromKnowledgeManager = function fromKnowledgeManager(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.KnowledgeManager,
	        index: index,
	        name: rawData.name,
	        description: rawData.description,
	        link: rawData.website,
	        id: rawData.id,
	        distance: result.distance,
	        distanceFromFilter: result.distanceFromFilter,
	        highlightedFields: result.highlightedFields,
	        entityType: rawData.type
	      };
	    };

	    ResultsFactory.fromGoogleCustomSearchEngine = function fromGoogleCustomSearchEngine(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.Google,
	        index: index,
	        name: rawData.htmlTitle.replace(/(<([^>]+)>)/ig, ''),
	        description: rawData.htmlSnippet,
	        link: rawData.link
	      };
	    };

	    ResultsFactory.fromBingCustomSearchEngine = function fromBingCustomSearchEngine(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.Bing,
	        index: index,
	        name: rawData.name,
	        description: rawData.snippet,
	        link: rawData.url
	      };
	    };

	    ResultsFactory.fromZendeskSearchEngine = function fromZendeskSearchEngine(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.Zendesk,
	        index: index,
	        name: rawData.title,
	        description: rawData.snippet,
	        link: rawData.html_url
	      };
	    };

	    ResultsFactory.fromAlgoliaSearchEngine = function fromAlgoliaSearchEngine(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.Algolia,
	        index: index,
	        name: rawData.name,
	        id: rawData.objectID
	      };
	    };

	    ResultsFactory.fromGeneric = function fromGeneric(result, index) {
	      var _a;

	      var rawData = (_a = result.data) !== null && _a !== void 0 ? _a : result;
	      return {
	        rawData: rawData,
	        source: Source_1.Source.Generic,
	        index: index,
	        name: rawData.name,
	        description: rawData.description,
	        link: rawData.website,
	        id: rawData.id
	      };
	    };

	    ResultsFactory.fromDirectAnswer = function fromDirectAnswer(result) {
	      var _a;

	      var rawData = (_a = result.fieldValues) !== null && _a !== void 0 ? _a : {};
	      return {
	        rawData: rawData,
	        source: Source_1.Source.KnowledgeManager,
	        name: rawData.name,
	        description: rawData.description,
	        link: result.website,
	        id: result.id,
	        entityType: result.type
	      };
	    };

	    return ResultsFactory;
	  }();

	  exports.ResultsFactory = ResultsFactory;
	});
	unwrapExports(ResultsFactory_1);
	var ResultsFactory_2 = ResultsFactory_1.ResultsFactory;

	var createDirectAnswer_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createDirectAnswer = void 0;

	  function createDirectAnswer(data) {
	    var isFieldValueDirectAnswer = (data === null || data === void 0 ? void 0 : data.type) === DirectAnswerType_1.DirectAnswerType.FieldValue;
	    var isFeaturedSnippetDirectAnswer = (data === null || data === void 0 ? void 0 : data.type) === DirectAnswerType_1.DirectAnswerType.FeaturedSnippet;
	    var commonDirectAnswerData = {
	      value: data.answer.value,
	      relatedResult: ResultsFactory_1.ResultsFactory.fromDirectAnswer(data.relatedItem.data),
	      verticalKey: data.relatedItem.verticalConfigId,
	      fieldType: data.answer.fieldType
	    };

	    if (isFieldValueDirectAnswer) {
	      return _extends(_extends({
	        type: DirectAnswerType_1.DirectAnswerType.FieldValue
	      }, commonDirectAnswerData), {
	        entityName: data.answer.entityName,
	        fieldName: data.answer.fieldName,
	        fieldApiName: data.answer.fieldApiName
	      });
	    } else if (isFeaturedSnippetDirectAnswer) {
	      return _extends(_extends({
	        type: DirectAnswerType_1.DirectAnswerType.FeaturedSnippet
	      }, commonDirectAnswerData), {
	        snippet: data.answer.snippet
	      });
	    } else {
	      throw new Error('The Answers API returned an unknown direct answer type');
	    }
	  }

	  exports.createDirectAnswer = createDirectAnswer;
	});
	unwrapExports(createDirectAnswer_1);
	var createDirectAnswer_2 = createDirectAnswer_1.createDirectAnswer;

	var createFilter_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createFilter = void 0;

	  function createFilter(filter) {
	    var fieldId = keys$3(filter)[0];

	    var matcher = keys$3(filter[fieldId])[0];

	    return {
	      fieldId: fieldId,
	      matcher: matcher,
	      value: filter[fieldId][matcher]
	    };
	  }

	  exports.createFilter = createFilter;
	});
	unwrapExports(createFilter_1);
	var createFilter_2 = createFilter_1.createFilter;

	var createFacets_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createFacets = void 0;

	  function createFacets(facets) {
	    if (!facets) {
	      return [];
	    }

	    return map$2(facets).call(facets, function (facet) {
	      return {
	        fieldId: facet.fieldId,
	        displayName: facet.displayName,
	        options: createFacetOptions(facet.options)
	      };
	    });
	  }

	  exports.createFacets = createFacets;

	  function createFacetOptions(options) {
	    return map$2(options).call(options, function (option) {
	      var filter = createFilter_1.createFilter(filter$2(option));
	      return {
	        displayName: option.displayName,
	        count: option.count,
	        selected: option.selected,
	        matcher: filter.matcher,
	        value: filter.value
	      };
	    });
	  }
	});
	unwrapExports(createFacets_1);
	var createFacets_2 = createFacets_1.createFacets;

	var createLocationBias_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createLocationBias = void 0;

	  function createLocationBias(data) {
	    return {
	      latitude: data.latitude,
	      longitude: data.longitude,
	      displayName: data.locationDisplayName,
	      method: data.accuracy
	    };
	  }

	  exports.createLocationBias = createLocationBias;
	});
	unwrapExports(createLocationBias_1);
	var createLocationBias_2 = createLocationBias_1.createLocationBias;

	var createSpellCheck_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createSpellCheck = void 0;

	  function createSpellCheck(data) {
	    return {
	      originalQuery: data.originalQuery,
	      correctedQuery: data.correctedQuery.value,
	      type: data.type
	    };
	  }

	  exports.createSpellCheck = createSpellCheck;
	});
	unwrapExports(createSpellCheck_1);
	var createSpellCheck_2 = createSpellCheck_1.createSpellCheck;

	var createAppliedQueryFilter_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createAppliedQueryFilter = void 0;

	  function createAppliedQueryFilter(data) {
	    return {
	      displayKey: data.displayKey,
	      displayValue: data.displayValue,
	      filter: createFilter_1.createFilter(filter$2(data))
	    };
	  }

	  exports.createAppliedQueryFilter = createAppliedQueryFilter;
	});
	unwrapExports(createAppliedQueryFilter_1);
	var createAppliedQueryFilter_2 = createAppliedQueryFilter_1.createAppliedQueryFilter;

	var createVerticalResults_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createVerticalResults = void 0;

	  function createVerticalResults(data) {
	    var _context;

	    var appliedQueryFilters = data.appliedQueryFilters ? map$2(_context = data.appliedQueryFilters).call(_context, createAppliedQueryFilter_1.createAppliedQueryFilter) : [];
	    return {
	      appliedQueryFilters: appliedQueryFilters,
	      queryDurationMillis: data.queryDurationMillis,
	      results: ResultsFactory_1.ResultsFactory.create(data.results, data.source),
	      resultsCount: data.resultsCount,
	      source: data.source,
	      verticalKey: data.verticalConfigId
	    };
	  }

	  exports.createVerticalResults = createVerticalResults;
	});
	unwrapExports(createVerticalResults_1);
	var createVerticalResults_2 = createVerticalResults_1.createVerticalResults;

	var createVerticalSearchResponse_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createVerticalSearchResponse = void 0;

	  function createVerticalSearchResponse(data) {
	    var _context;

	    var _a;

	    return {
	      verticalResults: createVerticalResults_1.createVerticalResults(data.response),
	      queryId: data.response.queryId,
	      directAnswer: data.response.directAnswer && createDirectAnswer_1.createDirectAnswer(data.response.directAnswer),
	      searchIntents: data.response.searchIntents,
	      facets: createFacets_1.createFacets(data.response.facets),
	      spellCheck: data.response.spellCheck && createSpellCheck_1.createSpellCheck(data.response.spellCheck),
	      locationBias: data.response.locationBias && createLocationBias_1.createLocationBias(data.response.locationBias),
	      allResultsForVertical: data.response.allResultsForVertical && createVerticalSearchResponse({
	        response: data.response.allResultsForVertical
	      }),
	      alternativeVerticals: data.response.alternativeVerticals && data.response.alternativeVerticals.modules && map$2(_context = data.response.alternativeVerticals.modules).call(_context, createVerticalResults_1.createVerticalResults),
	      uuid: (_a = data.meta) === null || _a === void 0 ? void 0 : _a.uuid
	    };
	  }

	  exports.createVerticalSearchResponse = createVerticalSearchResponse;
	});
	unwrapExports(createVerticalSearchResponse_1);
	var createVerticalSearchResponse_2 = createVerticalSearchResponse_1.createVerticalSearchResponse;

	var constants = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.defaultEndpoints = exports.defaultApiVersion = void 0;
	  exports.defaultApiVersion = 20190101;
	  exports.defaultEndpoints = {
	    universalSearch: 'https://liveapi.yext.com/v2/accounts/me/answers/query',
	    verticalSearch: 'https://liveapi.yext.com/v2/accounts/me/answers/vertical/query',
	    questionSubmission: 'https://api.yext.com/v2/accounts/me/createQuestion',
	    status: 'https://answersstatus.pagescdn.com',
	    universalAutocomplete: 'https://liveapi-cached.yext.com/v2/accounts/me/answers/autocomplete',
	    verticalAutocomplete: 'https://liveapi-cached.yext.com/v2/accounts/me/answers/vertical/autocomplete',
	    filterSearch: 'https://liveapi-cached.yext.com/v2/accounts/me/answers/filtersearch'
	  };
	});
	unwrapExports(constants);
	var constants_1 = constants.defaultEndpoints;
	var constants_2 = constants.defaultApiVersion;

	var QuerySource_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.QuerySource = void 0;
	  /**
	   * The source of the search request.
	   *
	   * @public
	   */

	  var QuerySource;

	  (function (QuerySource) {
	    /**
	     * Indicates that the query was initiated from a standard Answers integration.
	     */
	    QuerySource["Standard"] = "STANDARD";
	    /**
	     * Indicates that the query was initaited from an Answers Overlay.
	     */

	    QuerySource["Overlay"] = "OVERLAY";
	  })(QuerySource = exports.QuerySource || (exports.QuerySource = {}));
	});
	unwrapExports(QuerySource_1);
	var QuerySource_2 = QuerySource_1.QuerySource;

	var createUniversalSearchResponse_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createUniversalSearchResponse = void 0;

	  function createUniversalSearchResponse(data) {
	    var _context;

	    var verticalResults = isArray$3(data.response.modules) ? map$2(_context = data.response.modules).call(_context, createVerticalResults_1.createVerticalResults) : [];
	    return {
	      verticalResults: verticalResults,
	      queryId: data.response.queryId,
	      directAnswer: data.response.directAnswer && createDirectAnswer_1.createDirectAnswer(data.response.directAnswer),
	      searchIntents: data.response.searchIntents,
	      spellCheck: data.response.spellCheck && createSpellCheck_1.createSpellCheck(data.response.spellCheck),
	      locationBias: data.response.locationBias && createLocationBias_1.createLocationBias(data.response.locationBias),
	      uuid: data.meta.uuid
	    };
	  }

	  exports.createUniversalSearchResponse = createUniversalSearchResponse;
	});
	unwrapExports(createUniversalSearchResponse_1);
	var createUniversalSearchResponse_2 = createUniversalSearchResponse_1.createUniversalSearchResponse;

	var getIterator_1 = getIterator;

	var getIterator$1 = getIterator_1;

	var getIteratorMethod_1 = getIteratorMethod;

	var getIteratorMethod$1 = getIteratorMethod_1;

	var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
	var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

	// We can't use this feature detection in V8 since it causes
	// deoptimization and serious performance degradation
	// https://github.com/zloirock/core-js/issues/679
	var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version >= 51 || !fails(function () {
	  var array = [];
	  array[IS_CONCAT_SPREADABLE] = false;
	  return array.concat()[0] !== array;
	});

	var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

	var isConcatSpreadable = function (O) {
	  if (!isObject(O)) return false;
	  var spreadable = O[IS_CONCAT_SPREADABLE];
	  return spreadable !== undefined ? !!spreadable : isArray(O);
	};

	var FORCED$4 = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

	// `Array.prototype.concat` method
	// https://tc39.es/ecma262/#sec-array.prototype.concat
	// with adding support of @@isConcatSpreadable and @@species
	_export({ target: 'Array', proto: true, forced: FORCED$4 }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  concat: function concat(arg) {
	    var O = toObject(this);
	    var A = arraySpeciesCreate(O, 0);
	    var n = 0;
	    var i, k, length, len, E;
	    for (i = -1, length = arguments.length; i < length; i++) {
	      E = i === -1 ? O : arguments[i];
	      if (isConcatSpreadable(E)) {
	        len = toLength(E.length);
	        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
	      } else {
	        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
	        createProperty(A, n++, E);
	      }
	    }
	    A.length = n;
	    return A;
	  }
	});

	// `Symbol.asyncIterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.asynciterator
	defineWellKnownSymbol('asyncIterator');

	// `Symbol.hasInstance` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.hasinstance
	defineWellKnownSymbol('hasInstance');

	// `Symbol.isConcatSpreadable` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.isconcatspreadable
	defineWellKnownSymbol('isConcatSpreadable');

	// `Symbol.iterator` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.iterator
	defineWellKnownSymbol('iterator');

	// `Symbol.match` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.match
	defineWellKnownSymbol('match');

	// `Symbol.matchAll` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.matchall
	defineWellKnownSymbol('matchAll');

	// `Symbol.replace` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.replace
	defineWellKnownSymbol('replace');

	// `Symbol.search` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.search
	defineWellKnownSymbol('search');

	// `Symbol.species` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.species
	defineWellKnownSymbol('species');

	// `Symbol.split` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.split
	defineWellKnownSymbol('split');

	// `Symbol.toPrimitive` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.toprimitive
	defineWellKnownSymbol('toPrimitive');

	// `Symbol.toStringTag` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.tostringtag
	defineWellKnownSymbol('toStringTag');

	// `Symbol.unscopables` well-known symbol
	// https://tc39.es/ecma262/#sec-symbol.unscopables
	defineWellKnownSymbol('unscopables');

	// JSON[@@toStringTag] property
	// https://tc39.es/ecma262/#sec-json-@@tostringtag
	setToStringTag(global_1.JSON, 'JSON', true);

	var symbol = path.Symbol;

	var symbol$1 = symbol;

	var symbol$2 = symbol$1;

	var INCORRECT_ITERATION$1 = !checkCorrectnessOfIteration(function (iterable) {
	  Array.from(iterable);
	});

	// `Array.from` method
	// https://tc39.es/ecma262/#sec-array.from
	_export({ target: 'Array', stat: true, forced: INCORRECT_ITERATION$1 }, {
	  from: arrayFrom
	});

	var from_1 = path.Array.from;

	var from_1$1 = from_1;

	var from_1$2 = from_1$1;

	var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport('slice');

	var SPECIES$5 = wellKnownSymbol('species');
	var nativeSlice = [].slice;
	var max$1 = Math.max;

	// `Array.prototype.slice` method
	// https://tc39.es/ecma262/#sec-array.prototype.slice
	// fallback for not array-like ES3 strings and DOM objects
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$2 }, {
	  slice: function slice(start, end) {
	    var O = toIndexedObject(this);
	    var length = toLength(O.length);
	    var k = toAbsoluteIndex(start, length);
	    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
	    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
	    var Constructor, result, n;
	    if (isArray(O)) {
	      Constructor = O.constructor;
	      // cross-realm fallback
	      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
	        Constructor = undefined;
	      } else if (isObject(Constructor)) {
	        Constructor = Constructor[SPECIES$5];
	        if (Constructor === null) Constructor = undefined;
	      }
	      if (Constructor === Array || Constructor === undefined) {
	        return nativeSlice.call(O, k, fin);
	      }
	    }
	    result = new (Constructor === undefined ? Array : Constructor)(max$1(fin - k, 0));
	    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
	    result.length = n;
	    return result;
	  }
	});

	var slice$2 = entryVirtual('Array').slice;

	var ArrayPrototype$6 = Array.prototype;

	var slice_1 = function (it) {
	  var own = it.slice;
	  return it === ArrayPrototype$6 || (it instanceof Array && own === ArrayPrototype$6.slice) ? slice$2 : own;
	};

	var slice$3 = slice_1;

	var slice$4 = slice$3;

	function _createForOfIteratorHelperLoose(o, allowArrayLike) { var _context2; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context2 = it.next).call(_context2, it); }

	function _unsupportedIterableToArray(o, minLen) { var _context; if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

	function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var serializeStaticFilters_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.shapeFilterForApi = exports.serializeStaticFilters = void 0;

	  function serializeStaticFilters(filter) {
	    if (isCombinedFilter(filter)) {
	      return stringify$2(shapeCombinedFilterForApi(filter));
	    }

	    return stringify$2(shapeFilterForApi(filter));
	  }

	  exports.serializeStaticFilters = serializeStaticFilters;

	  function shapeCombinedFilterForApi(combinedFilter) {
	    var _ref;

	    var shapedFilters = [];

	    for (var _iterator = _createForOfIteratorHelperLoose(combinedFilter.filters), _step; !(_step = _iterator()).done;) {
	      var filter = _step.value;

	      if (isCombinedFilter(filter)) {
	        shapedFilters.push(shapeCombinedFilterForApi(filter));
	      } else {
	        shapedFilters.push(shapeFilterForApi(filter));
	      }
	    }

	    return shapedFilters.length === 1 ? shapedFilters[0] : (_ref = {}, _ref[combinedFilter.combinator] = shapedFilters, _ref);
	  }

	  function shapeFilterForApi(filter) {
	    var _filter$fieldId, _ref2;

	    return _ref2 = {}, _ref2[filter.fieldId] = (_filter$fieldId = {}, _filter$fieldId[filter.matcher] = filter.value, _filter$fieldId), _ref2;
	  }

	  exports.shapeFilterForApi = shapeFilterForApi;

	  function isCombinedFilter(filter) {
	    return filter.filters !== undefined && filter.combinator !== undefined;
	  }
	});
	unwrapExports(serializeStaticFilters_1);
	var serializeStaticFilters_2 = serializeStaticFilters_1.shapeFilterForApi;
	var serializeStaticFilters_3 = serializeStaticFilters_1.serializeStaticFilters;

	var serializeFacets_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.serializeFacets = void 0;

	  function serializeFacets(filters) {
	    return stringify$2(reduce$2(filters).call(filters, function (obj, facet) {
	      var fieldId = facet.fieldId;
	      var shapedFacets = shapeFacetOptionArrayForApi(facet.options, fieldId);
	      obj[fieldId] = shapedFacets;
	      return obj;
	    }, {}));
	  }

	  exports.serializeFacets = serializeFacets;

	  function shapeFacetOptionArrayForApi(options, fieldId) {
	    return map$2(options).call(options, function (option) {
	      return serializeStaticFilters_1.shapeFilterForApi(_extends(_extends({}, option), {
	        fieldId: fieldId
	      }));
	    });
	  }
	});
	unwrapExports(serializeFacets_1);
	var serializeFacets_2 = serializeFacets_1.serializeFacets;

	var SearchServiceImpl_1 = createCommonjsModule(function (module, exports) {

	  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = promise$3))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.SearchServiceImpl = void 0;
	  /**
	   * The implementation of SearchService which hits LiveAPI.
	   *
	   * @internal
	   */

	  var SearchServiceImpl = /*#__PURE__*/function () {
	    function SearchServiceImpl(config, httpService, apiResponseValidator) {
	      var _a, _b, _c, _d;

	      this.config = config;
	      this.httpService = httpService;
	      this.apiResponseValidator = apiResponseValidator;
	      this.universalSearchEndpoint = (_b = (_a = config.endpoints) === null || _a === void 0 ? void 0 : _a.universalSearch) !== null && _b !== void 0 ? _b : constants.defaultEndpoints.universalSearch;
	      this.verticalSearchEndpoint = (_d = (_c = config.endpoints) === null || _c === void 0 ? void 0 : _c.verticalSearch) !== null && _d !== void 0 ? _d : constants.defaultEndpoints.verticalSearch;
	    }

	    var _proto = SearchServiceImpl.prototype;

	    _proto.universalSearch = function universalSearch(request) {
	      var _a, _b;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
	        var queryParams, response, validationResult;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                this.injectToStringMethods(request);
	                queryParams = _extends({
	                  input: request.query,
	                  experienceKey: this.config.experienceKey,
	                  api_key: this.config.apiKey,
	                  v: constants.defaultApiVersion,
	                  version: this.config.experienceVersion,
	                  limit: stringify$2(request.limit || undefined),
	                  location: (_a = request.location) === null || _a === void 0 ? void 0 : _a.toString(),
	                  locale: this.config.locale,
	                  skipSpellCheck: request.skipSpellCheck,
	                  session_id: request.sessionId,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled,
	                  queryTrigger: request.queryTrigger,
	                  context: stringify$2(request.context || undefined),
	                  referrerPageUrl: request.referrerPageUrl,
	                  source: request.querySource || QuerySource_1.QuerySource.Standard
	                }, (_b = this.config) === null || _b === void 0 ? void 0 : _b.additionalQueryParams);
	                _context.next = 4;
	                return this.httpService.get(this.universalSearchEndpoint, queryParams);

	              case 4:
	                response = _context.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context.next = 8;
	                  break;
	                }

	                return _context.abrupt("return", promise$3.reject(validationResult));

	              case 8:
	                return _context.abrupt("return", createUniversalSearchResponse_1.createUniversalSearchResponse(response));

	              case 9:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    };

	    _proto.verticalSearch = function verticalSearch(request) {
	      var _a, _b, _c;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
	        var queryParams, response, validationResult;
	        return regenerator.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                this.injectToStringMethods(request);
	                queryParams = _extends({
	                  experienceKey: this.config.experienceKey,
	                  api_key: this.config.apiKey,
	                  v: constants.defaultApiVersion,
	                  version: this.config.experienceVersion,
	                  locale: this.config.locale,
	                  input: request.query,
	                  location: (_a = request.location) === null || _a === void 0 ? void 0 : _a.toString(),
	                  verticalKey: request.verticalKey,
	                  filters: request.staticFilters && serializeStaticFilters_1.serializeStaticFilters(request.staticFilters),
	                  limit: request.limit,
	                  offset: request.offset,
	                  retrieveFacets: request.retrieveFacets,
	                  facetFilters: request.facets && serializeFacets_1.serializeFacets(request.facets),
	                  skipSpellCheck: request.skipSpellCheck,
	                  queryTrigger: request.queryTrigger,
	                  session_id: request.sessionId,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled,
	                  sortBys: stringify$2(request.sortBys || []),
	                  context: stringify$2(request.context || undefined),
	                  referrerPageUrl: request.referrerPageUrl,
	                  source: request.querySource || QuerySource_1.QuerySource.Standard,
	                  locationRadius: (_b = request.locationRadius) === null || _b === void 0 ? void 0 : _b.toString(),
	                  queryId: request.queryId
	                }, (_c = this.config) === null || _c === void 0 ? void 0 : _c.additionalQueryParams);
	                _context2.next = 4;
	                return this.httpService.get(this.verticalSearchEndpoint, queryParams);

	              case 4:
	                response = _context2.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context2.next = 8;
	                  break;
	                }

	                return _context2.abrupt("return", promise$3.reject(validationResult));

	              case 8:
	                return _context2.abrupt("return", createVerticalSearchResponse_1.createVerticalSearchResponse(response));

	              case 9:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	    }
	    /**
	     * Injects toString() methods into the request objects that require them
	     */
	    ;

	    _proto.injectToStringMethods = function injectToStringMethods(request) {
	      if (request.location) {
	        request.location.toString = function () {
	          return this.latitude + "," + this.longitude;
	        };
	      }
	    };

	    return SearchServiceImpl;
	  }();

	  exports.SearchServiceImpl = SearchServiceImpl;
	});
	unwrapExports(SearchServiceImpl_1);
	var SearchServiceImpl_2 = SearchServiceImpl_1.SearchServiceImpl;

	var QuestionSubmissionServiceImpl_1 = createCommonjsModule(function (module, exports) {

	  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = promise$3))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.QuestionSubmissionServiceImpl = void 0;
	  /**
	   * An implementation of QuestionSubmissionService which hits LiveAPI.
	   *
	   * @internal
	   */

	  var QuestionSubmissionServiceImpl = /*#__PURE__*/function () {
	    function QuestionSubmissionServiceImpl(config, httpService, apiResponseValidator) {
	      var _a, _b;

	      this.config = config;
	      this.httpService = httpService;
	      this.apiResponseValidator = apiResponseValidator;
	      this.endpoint = (_b = (_a = this.config.endpoints) === null || _a === void 0 ? void 0 : _a.questionSubmission) !== null && _b !== void 0 ? _b : constants.defaultEndpoints.questionSubmission;
	    }

	    var _proto = QuestionSubmissionServiceImpl.prototype;

	    _proto.submitQuestion = function submitQuestion(request) {
	      var _a;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
	        var queryParams, body, response, validationResult;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                queryParams = _extends({
	                  v: constants.defaultApiVersion,
	                  api_key: this.config.apiKey,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled
	                }, (_a = this.config) === null || _a === void 0 ? void 0 : _a.additionalQueryParams);
	                body = {
	                  email: request.email,
	                  entityId: request.entityId,
	                  name: request.name,
	                  questionDescription: request.questionDescription,
	                  questionLanguage: this.config.locale,
	                  questionText: request.questionText,
	                  site: 'FIRSTPARTY'
	                };
	                _context.next = 4;
	                return this.httpService.post(this.endpoint, queryParams, body);

	              case 4:
	                response = _context.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context.next = 8;
	                  break;
	                }

	                return _context.abrupt("return", promise$3.reject(validationResult));

	              case 8:
	                return _context.abrupt("return", {
	                  uuid: response.meta.uuid
	                });

	              case 9:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    };

	    return QuestionSubmissionServiceImpl;
	  }();

	  exports.QuestionSubmissionServiceImpl = QuestionSubmissionServiceImpl;
	});
	unwrapExports(QuestionSubmissionServiceImpl_1);
	var QuestionSubmissionServiceImpl_2 = QuestionSubmissionServiceImpl_1.QuestionSubmissionServiceImpl;

	var non = '\u200B\u0085\u180E';

	// check that a method works with the correct list
	// of whitespaces and has a correct name
	var stringTrimForced = function (METHOD_NAME) {
	  return fails(function () {
	    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
	  });
	};

	var $trim = stringTrim.trim;


	// `String.prototype.trim` method
	// https://tc39.es/ecma262/#sec-string.prototype.trim
	_export({ target: 'String', proto: true, forced: stringTrimForced('trim') }, {
	  trim: function trim() {
	    return $trim(this);
	  }
	});

	var trim$1 = entryVirtual('String').trim;

	var StringPrototype$1 = String.prototype;

	var trim_1 = function (it) {
	  var own = it.trim;
	  return typeof it === 'string' || it === StringPrototype$1
	    || (it instanceof String && own === StringPrototype$1.trim) ? trim$1 : own;
	};

	var trim$2 = trim_1;

	var trim$3 = trim$2;

	var urlSearchParams = path.URLSearchParams;

	var urlSearchParams$1 = urlSearchParams;

	var urlSearchParams$2 = urlSearchParams$1;

	var entries = entryVirtual('Array').entries;

	var entries$1 = entries;

	var ArrayPrototype$7 = Array.prototype;

	var DOMIterables$1 = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var entries_1 = function (it) {
	  var own = it.entries;
	  return it === ArrayPrototype$7 || (it instanceof Array && own === ArrayPrototype$7.entries)
	    // eslint-disable-next-line no-prototype-builtins -- safe
	    || DOMIterables$1.hasOwnProperty(classof(it)) ? entries$1 : own;
	};

	var entries$2 = entries_1;

	var nativeGetOwnPropertyNames$2 = objectGetOwnPropertyNamesExternal.f;

	var FAILS_ON_PRIMITIVES$2 = fails(function () { return !Object.getOwnPropertyNames(1); });

	// `Object.getOwnPropertyNames` method
	// https://tc39.es/ecma262/#sec-object.getownpropertynames
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$2 }, {
	  getOwnPropertyNames: nativeGetOwnPropertyNames$2
	});

	var Object$2 = path.Object;

	var getOwnPropertyNames = function getOwnPropertyNames(it) {
	  return Object$2.getOwnPropertyNames(it);
	};

	var getOwnPropertyNames$1 = getOwnPropertyNames;

	var getOwnPropertyNames$2 = getOwnPropertyNames$1;

	var iterator = wellKnownSymbolWrapped.f('iterator');

	var iterator$1 = iterator;

	var iterator$2 = iterator$1;

	var $indexOf = arrayIncludes.indexOf;


	var nativeIndexOf = [].indexOf;

	var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
	var STRICT_METHOD$2 = arrayMethodIsStrict('indexOf');

	// `Array.prototype.indexOf` method
	// https://tc39.es/ecma262/#sec-array.prototype.indexof
	_export({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD$2 }, {
	  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
	    return NEGATIVE_ZERO
	      // convert -0 to +0
	      ? nativeIndexOf.apply(this, arguments) || 0
	      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var indexOf$1 = entryVirtual('Array').indexOf;

	var ArrayPrototype$8 = Array.prototype;

	var indexOf_1 = function (it) {
	  var own = it.indexOf;
	  return it === ArrayPrototype$8 || (it instanceof Array && own === ArrayPrototype$8.indexOf) ? indexOf$1 : own;
	};

	var indexOf$2 = indexOf_1;

	var indexOf$3 = indexOf$2;

	var browserPonyfill = createCommonjsModule(function (module, exports) {
	  var global = typeof self !== 'undefined' ? self : commonjsGlobal;

	  var __self__ = function () {
	    function F() {
	      this.fetch = false;
	      this.DOMException = global.DOMException;
	    }

	    F.prototype = global;
	    return new F();
	  }();

	  (function (self) {
	    var irrelevant = function (exports) {
	      var support = {
	        searchParams: 'URLSearchParams' in self,
	        iterable: 'Symbol' in self && 'iterator' in symbol$2,
	        blob: 'FileReader' in self && 'Blob' in self && function () {
	          try {
	            new Blob();
	            return true;
	          } catch (e) {
	            return false;
	          }
	        }(),
	        formData: 'FormData' in self,
	        arrayBuffer: 'ArrayBuffer' in self
	      };

	      function isDataView(obj) {
	        return obj && DataView.prototype.isPrototypeOf(obj);
	      }

	      if (support.arrayBuffer) {
	        var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

	        var isArrayBufferView = ArrayBuffer.isView || function (obj) {
	          return obj && indexOf$3(viewClasses).call(viewClasses, Object.prototype.toString.call(obj)) > -1;
	        };
	      }

	      function normalizeName(name) {
	        if (typeof name !== 'string') {
	          name = String(name);
	        }

	        if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
	          throw new TypeError('Invalid character in header field name');
	        }

	        return name.toLowerCase();
	      }

	      function normalizeValue(value) {
	        if (typeof value !== 'string') {
	          value = String(value);
	        }

	        return value;
	      } // Build a destructive iterator for the value list


	      function iteratorFor(items) {
	        var iterator = {
	          next: function next() {
	            var value = items.shift();
	            return {
	              done: value === undefined,
	              value: value
	            };
	          }
	        };

	        if (support.iterable) {
	          iterator[iterator$2] = function () {
	            return iterator;
	          };
	        }

	        return iterator;
	      }

	      function Headers(headers) {
	        this.map = {};

	        if (headers instanceof Headers) {
	          forEach$2(headers).call(headers, function (value, name) {
	            this.append(name, value);
	          }, this);
	        } else if (isArray$3(headers)) {
	          forEach$2(headers).call(headers, function (header) {
	            this.append(header[0], header[1]);
	          }, this);
	        } else if (headers) {
	          var _context;

	          forEach$2(_context = getOwnPropertyNames$2(headers)).call(_context, function (name) {
	            this.append(name, headers[name]);
	          }, this);
	        }
	      }

	      Headers.prototype.append = function (name, value) {
	        name = normalizeName(name);
	        value = normalizeValue(value);

	        var oldValue = map$2(this)[name];

	        map$2(this)[name] = oldValue ? oldValue + ', ' + value : value;
	      };

	      Headers.prototype['delete'] = function (name) {
	        delete map$2(this)[normalizeName(name)];
	      };

	      Headers.prototype.get = function (name) {
	        name = normalizeName(name);
	        return this.has(name) ? map$2(this)[name] : null;
	      };

	      Headers.prototype.has = function (name) {
	        return map$2(this).hasOwnProperty(normalizeName(name));
	      };

	      Headers.prototype.set = function (name, value) {
	        map$2(this)[normalizeName(name)] = normalizeValue(value);
	      };

	      Headers.prototype.forEach = function (callback, thisArg) {
	        for (var name in map$2(this)) {
	          if (map$2(this).hasOwnProperty(name)) {
	            callback.call(thisArg, map$2(this)[name], name, this);
	          }
	        }
	      };

	      Headers.prototype.keys = function () {
	        var _context2;

	        var items = [];

	        forEach$2(_context2 = this).call(_context2, function (value, name) {
	          items.push(name);
	        });

	        return iteratorFor(items);
	      };

	      Headers.prototype.values = function () {
	        var _context3;

	        var items = [];

	        forEach$2(_context3 = this).call(_context3, function (value) {
	          items.push(value);
	        });

	        return iteratorFor(items);
	      };

	      Headers.prototype.entries = function () {
	        var _context4;

	        var items = [];

	        forEach$2(_context4 = this).call(_context4, function (value, name) {
	          items.push([name, value]);
	        });

	        return iteratorFor(items);
	      };

	      if (support.iterable) {
	        Headers.prototype[iterator$2] = entries$2(Headers.prototype);
	      }

	      function consumed(body) {
	        if (body.bodyUsed) {
	          return promise$3.reject(new TypeError('Already read'));
	        }

	        body.bodyUsed = true;
	      }

	      function fileReaderReady(reader) {
	        return new promise$3(function (resolve, reject) {
	          reader.onload = function () {
	            resolve(reader.result);
	          };

	          reader.onerror = function () {
	            reject(reader.error);
	          };
	        });
	      }

	      function readBlobAsArrayBuffer(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsArrayBuffer(blob);
	        return promise;
	      }

	      function readBlobAsText(blob) {
	        var reader = new FileReader();
	        var promise = fileReaderReady(reader);
	        reader.readAsText(blob);
	        return promise;
	      }

	      function readArrayBufferAsText(buf) {
	        var view = new Uint8Array(buf);
	        var chars = new Array(view.length);

	        for (var i = 0; i < view.length; i++) {
	          chars[i] = String.fromCharCode(view[i]);
	        }

	        return chars.join('');
	      }

	      function bufferClone(buf) {
	        if (slice$4(buf)) {
	          return slice$4(buf).call(buf, 0);
	        } else {
	          var view = new Uint8Array(buf.byteLength);
	          view.set(new Uint8Array(buf));
	          return view.buffer;
	        }
	      }

	      function Body() {
	        this.bodyUsed = false;

	        this._initBody = function (body) {
	          this._bodyInit = body;

	          if (!body) {
	            this._bodyText = '';
	          } else if (typeof body === 'string') {
	            this._bodyText = body;
	          } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	            this._bodyBlob = body;
	          } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	            this._bodyFormData = body;
	          } else if (support.searchParams && urlSearchParams$2.prototype.isPrototypeOf(body)) {
	            this._bodyText = body.toString();
	          } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	            this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

	            this._bodyInit = new Blob([this._bodyArrayBuffer]);
	          } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	            this._bodyArrayBuffer = bufferClone(body);
	          } else {
	            this._bodyText = body = Object.prototype.toString.call(body);
	          }

	          if (!this.headers.get('content-type')) {
	            if (typeof body === 'string') {
	              this.headers.set('content-type', 'text/plain;charset=UTF-8');
	            } else if (this._bodyBlob && this._bodyBlob.type) {
	              this.headers.set('content-type', this._bodyBlob.type);
	            } else if (support.searchParams && urlSearchParams$2.prototype.isPrototypeOf(body)) {
	              this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
	            }
	          }
	        };

	        if (support.blob) {
	          this.blob = function () {
	            var rejected = consumed(this);

	            if (rejected) {
	              return rejected;
	            }

	            if (this._bodyBlob) {
	              return promise$3.resolve(this._bodyBlob);
	            } else if (this._bodyArrayBuffer) {
	              return promise$3.resolve(new Blob([this._bodyArrayBuffer]));
	            } else if (this._bodyFormData) {
	              throw new Error('could not read FormData body as blob');
	            } else {
	              return promise$3.resolve(new Blob([this._bodyText]));
	            }
	          };

	          this.arrayBuffer = function () {
	            if (this._bodyArrayBuffer) {
	              return consumed(this) || promise$3.resolve(this._bodyArrayBuffer);
	            } else {
	              return this.blob().then(readBlobAsArrayBuffer);
	            }
	          };
	        }

	        this.text = function () {
	          var rejected = consumed(this);

	          if (rejected) {
	            return rejected;
	          }

	          if (this._bodyBlob) {
	            return readBlobAsText(this._bodyBlob);
	          } else if (this._bodyArrayBuffer) {
	            return promise$3.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
	          } else if (this._bodyFormData) {
	            throw new Error('could not read FormData body as text');
	          } else {
	            return promise$3.resolve(this._bodyText);
	          }
	        };

	        if (support.formData) {
	          this.formData = function () {
	            return this.text().then(decode);
	          };
	        }

	        this.json = function () {
	          return this.text().then(JSON.parse);
	        };

	        return this;
	      } // HTTP methods whose capitalization should be normalized


	      var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

	      function normalizeMethod(method) {
	        var upcased = method.toUpperCase();
	        return indexOf$3(methods).call(methods, upcased) > -1 ? upcased : method;
	      }

	      function Request(input, options) {
	        options = options || {};
	        var body = options.body;

	        if (input instanceof Request) {
	          if (input.bodyUsed) {
	            throw new TypeError('Already read');
	          }

	          this.url = input.url;
	          this.credentials = input.credentials;

	          if (!options.headers) {
	            this.headers = new Headers(input.headers);
	          }

	          this.method = input.method;
	          this.mode = input.mode;
	          this.signal = input.signal;

	          if (!body && input._bodyInit != null) {
	            body = input._bodyInit;
	            input.bodyUsed = true;
	          }
	        } else {
	          this.url = String(input);
	        }

	        this.credentials = options.credentials || this.credentials || 'same-origin';

	        if (options.headers || !this.headers) {
	          this.headers = new Headers(options.headers);
	        }

	        this.method = normalizeMethod(options.method || this.method || 'GET');
	        this.mode = options.mode || this.mode || null;
	        this.signal = options.signal || this.signal;
	        this.referrer = null;

	        if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	          throw new TypeError('Body not allowed for GET or HEAD requests');
	        }

	        this._initBody(body);
	      }

	      Request.prototype.clone = function () {
	        return new Request(this, {
	          body: this._bodyInit
	        });
	      };

	      function decode(body) {
	        var _context5;

	        var form = new FormData();

	        forEach$2(_context5 = trim$3(body).call(body).split('&')).call(_context5, function (bytes) {
	          if (bytes) {
	            var split = bytes.split('=');
	            var name = split.shift().replace(/\+/g, ' ');
	            var value = split.join('=').replace(/\+/g, ' ');
	            form.append(decodeURIComponent(name), decodeURIComponent(value));
	          }
	        });

	        return form;
	      }

	      function parseHeaders(rawHeaders) {
	        var _context6;

	        var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
	        // https://tools.ietf.org/html/rfc7230#section-3.2

	        var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');

	        forEach$2(_context6 = preProcessedHeaders.split(/\r?\n/)).call(_context6, function (line) {
	          var _context7;

	          var parts = line.split(':');

	          var key = trim$3(_context7 = parts.shift()).call(_context7);

	          if (key) {
	            var _context8;

	            var value = trim$3(_context8 = parts.join(':')).call(_context8);

	            headers.append(key, value);
	          }
	        });

	        return headers;
	      }

	      Body.call(Request.prototype);

	      function Response(bodyInit, options) {
	        if (!options) {
	          options = {};
	        }

	        this.type = 'default';
	        this.status = options.status === undefined ? 200 : options.status;
	        this.ok = this.status >= 200 && this.status < 300;
	        this.statusText = 'statusText' in options ? options.statusText : 'OK';
	        this.headers = new Headers(options.headers);
	        this.url = options.url || '';

	        this._initBody(bodyInit);
	      }

	      Body.call(Response.prototype);

	      Response.prototype.clone = function () {
	        return new Response(this._bodyInit, {
	          status: this.status,
	          statusText: this.statusText,
	          headers: new Headers(this.headers),
	          url: this.url
	        });
	      };

	      Response.error = function () {
	        var response = new Response(null, {
	          status: 0,
	          statusText: ''
	        });
	        response.type = 'error';
	        return response;
	      };

	      var redirectStatuses = [301, 302, 303, 307, 308];

	      Response.redirect = function (url, status) {
	        if (indexOf$3(redirectStatuses).call(redirectStatuses, status) === -1) {
	          throw new RangeError('Invalid status code');
	        }

	        return new Response(null, {
	          status: status,
	          headers: {
	            location: url
	          }
	        });
	      };

	      exports.DOMException = self.DOMException;

	      try {
	        new exports.DOMException();
	      } catch (err) {
	        exports.DOMException = function (message, name) {
	          this.message = message;
	          this.name = name;
	          var error = Error(message);
	          this.stack = error.stack;
	        };

	        exports.DOMException.prototype = create$2(Error.prototype);
	        exports.DOMException.prototype.constructor = exports.DOMException;
	      }

	      function fetch(input, init) {
	        return new promise$3(function (resolve, reject) {
	          var _context9;

	          var request = new Request(input, init);

	          if (request.signal && request.signal.aborted) {
	            return reject(new exports.DOMException('Aborted', 'AbortError'));
	          }

	          var xhr = new XMLHttpRequest();

	          function abortXhr() {
	            xhr.abort();
	          }

	          xhr.onload = function () {
	            var options = {
	              status: xhr.status,
	              statusText: xhr.statusText,
	              headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	            };
	            options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
	            var body = 'response' in xhr ? xhr.response : xhr.responseText;
	            resolve(new Response(body, options));
	          };

	          xhr.onerror = function () {
	            reject(new TypeError('Network request failed'));
	          };

	          xhr.ontimeout = function () {
	            reject(new TypeError('Network request failed'));
	          };

	          xhr.onabort = function () {
	            reject(new exports.DOMException('Aborted', 'AbortError'));
	          };

	          xhr.open(request.method, request.url, true);

	          if (request.credentials === 'include') {
	            xhr.withCredentials = true;
	          } else if (request.credentials === 'omit') {
	            xhr.withCredentials = false;
	          }

	          if ('responseType' in xhr && support.blob) {
	            xhr.responseType = 'blob';
	          }

	          forEach$2(_context9 = request.headers).call(_context9, function (value, name) {
	            xhr.setRequestHeader(name, value);
	          });

	          if (request.signal) {
	            request.signal.addEventListener('abort', abortXhr);

	            xhr.onreadystatechange = function () {
	              // DONE (success or failure)
	              if (xhr.readyState === 4) {
	                request.signal.removeEventListener('abort', abortXhr);
	              }
	            };
	          }

	          xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
	        });
	      }

	      fetch.polyfill = true;

	      if (!self.fetch) {
	        self.fetch = fetch;
	        self.Headers = Headers;
	        self.Request = Request;
	        self.Response = Response;
	      }

	      exports.Headers = Headers;
	      exports.Request = Request;
	      exports.Response = Response;
	      exports.fetch = fetch;

	      defineProperty$3(exports, '__esModule', {
	        value: true
	      });

	      return exports;
	    }({});
	  })(__self__);

	  __self__.fetch.ponyfill = true; // Remove "polyfill" property added by whatwg-fetch

	  delete __self__.fetch.polyfill; // Choose between native implementation (global) or custom implementation (__self__)
	  // var ctx = global.fetch ? global : __self__;

	  var ctx = __self__; // this line disable service worker support temporarily

	  exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'

	  exports["default"] = ctx.fetch; // For TypeScript consumers without esModuleInterop.

	  exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'

	  exports.Headers = ctx.Headers;
	  exports.Request = ctx.Request;
	  exports.Response = ctx.Response;
	  module.exports = exports;
	});
	unwrapExports(browserPonyfill);
	var browserPonyfill_1 = browserPonyfill.fetch;
	var browserPonyfill_2 = browserPonyfill.Headers;
	var browserPonyfill_3 = browserPonyfill.Request;
	var browserPonyfill_4 = browserPonyfill.Response;

	var urlutils = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.sanitizeQueryParams = exports.addParamsToURL = void 0;
	  /**
	   * Updates a url with the given params.
	   */

	  function addParamsToURL(url, params) {
	    var parsedUrl = new url$2(url);
	    var urlParams = new urlSearchParams$2(parsedUrl.search.substring(1));
	    var sanitizedParams = sanitizeQueryParams(params);

	    for (var key in sanitizedParams) {
	      urlParams.append(key, sanitizedParams[key].toString());
	    }

	    var updatedUrl = parsedUrl.origin + parsedUrl.pathname;
	    var paramsString = urlParams.toString();

	    if (paramsString) {
	      updatedUrl += '?' + paramsString;
	    }

	    return updatedUrl;
	  }

	  exports.addParamsToURL = addParamsToURL;

	  function sanitizeQueryParams(params) {
	    var _context;

	    forEach$2(_context = keys$3(params)).call(_context, function (key) {
	      if (params[key] === undefined || params[key] === null) {
	        delete params[key];
	      }
	    });

	    return params;
	  }

	  exports.sanitizeQueryParams = sanitizeQueryParams;
	});
	unwrapExports(urlutils);
	var urlutils_1 = urlutils.sanitizeQueryParams;
	var urlutils_2 = urlutils.addParamsToURL;

	var HttpServiceImpl_1 = createCommonjsModule(function (module, exports) {

	  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
	    return mod && mod.__esModule ? mod : {
	      "default": mod
	    };
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.HttpServiceImpl = void 0;

	  var cross_fetch_1 = __importDefault(browserPonyfill);
	  /**
	   * Available HTTP request methods
	   */


	  var RequestMethods;

	  (function (RequestMethods) {
	    RequestMethods["GET"] = "get";
	    RequestMethods["POST"] = "post";
	  })(RequestMethods || (RequestMethods = {}));
	  /**
	   * HttpServiceImpl is a wrapper around the native implementation of AJAX
	   * related matters.
	   */


	  var HttpServiceImpl = /*#__PURE__*/function () {
	    function HttpServiceImpl() {}

	    var _proto = HttpServiceImpl.prototype;

	    /**
	     * Perform a GET request
	     */
	    _proto.get = function get(url, queryParams) {
	      return this.fetch(url, queryParams, {
	        method: RequestMethods.GET,
	        credentials: 'include'
	      }).then(function (res) {
	        return res.json();
	      });
	    }
	    /**
	     * Perform a POST request
	     */
	    ;

	    _proto.post = function post(url, queryParams, body) {
	      var sanitizedBodyParams = urlutils.sanitizeQueryParams(body);
	      return this.fetch(url, queryParams, {
	        method: RequestMethods.POST,
	        body: stringify$2(sanitizedBodyParams),
	        mode: 'cors',
	        headers: {
	          'Content-Type': 'application/json'
	        }
	      }).then(function (res) {
	        return res.json();
	      });
	    }
	    /**
	     * Perform a fetch, using the polyfill if needed.
	     */
	    ;

	    _proto.fetch = function fetch(url, queryParams, reqInit) {
	      var urlWithParams = urlutils.addParamsToURL(url, queryParams);

	      if (window.fetch) {
	        return window.fetch(urlWithParams, reqInit);
	      }

	      return cross_fetch_1["default"](urlWithParams, reqInit);
	    };

	    return HttpServiceImpl;
	  }();

	  exports.HttpServiceImpl = HttpServiceImpl;
	});
	unwrapExports(HttpServiceImpl_1);
	var HttpServiceImpl_2 = HttpServiceImpl_1.HttpServiceImpl;

	var createAutocompleteResult_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createAutocompleteResult = void 0;

	  function createAutocompleteResult(result) {
	    var relatedItem = result.relatedItem ? ResultsFactory_1.ResultsFactory.create([result.relatedItem], Source_1.Source.KnowledgeManager)[0] : result.relatedItem;
	    return {
	      filter: filter$2(result) && createFilter_1.createFilter(filter$2(result)),
	      key: result.key,
	      matchedSubstrings: result.matchedSubstrings || [],
	      value: result.value,
	      relatedItem: relatedItem
	    };
	  }

	  exports.createAutocompleteResult = createAutocompleteResult;
	});
	unwrapExports(createAutocompleteResult_1);
	var createAutocompleteResult_2 = createAutocompleteResult_1.createAutocompleteResult;

	var createAutocompleteResponse_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.createFilterSearchResponse = exports.createAutocompleteResponse = void 0;

	  function createAutocompleteResponse(data) {
	    var _context;

	    if (!data.response) {
	      throw new Error('The autocomplete data does not contain a response property');
	    }

	    if (!keys$3(data.response).length) {
	      throw new Error('The autocomplete response is empty');
	    }

	    var response = data.response;

	    var responseResults = map$2(_context = response.results).call(_context, createAutocompleteResult_1.createAutocompleteResult);

	    var inputIntents = response.input ? response.input.queryIntents : [];
	    return {
	      results: responseResults,
	      queryId: response.queryId,
	      inputIntents: inputIntents || [],
	      uuid: data.meta.uuid
	    };
	  }

	  exports.createAutocompleteResponse = createAutocompleteResponse;

	  function createFilterSearchResponse(data) {
	    if (!data.response) {
	      throw new Error('The autocomplete data does not contain a response property');
	    }

	    if (!keys$3(data.response).length) {
	      throw new Error('The autocomplete response is empty');
	    }

	    var response = data.response;
	    var isSectioned = false;
	    var sections = [];
	    var responseResults = []; // a filtersearch response may have a sections object

	    if (response.sections) {
	      var _context2;

	      isSectioned = true;
	      sections = map$2(_context2 = response.sections).call(_context2, function (section) {
	        var _context3;

	        return {
	          label: section.label,
	          results: map$2(_context3 = section.results).call(_context3, createAutocompleteResult_1.createAutocompleteResult)
	        };
	      });
	    } else {
	      var _context4;

	      responseResults = map$2(_context4 = response.results).call(_context4, createAutocompleteResult_1.createAutocompleteResult);
	    }

	    var inputIntents = response.input ? response.input.queryIntents : [];
	    return {
	      sectioned: isSectioned,
	      sections: sections,
	      results: responseResults,
	      queryId: response.queryId,
	      inputIntents: inputIntents || [],
	      uuid: data.meta.uuid
	    };
	  }

	  exports.createFilterSearchResponse = createFilterSearchResponse;
	});
	unwrapExports(createAutocompleteResponse_1);
	var createAutocompleteResponse_2 = createAutocompleteResponse_1.createFilterSearchResponse;
	var createAutocompleteResponse_3 = createAutocompleteResponse_1.createAutocompleteResponse;

	var AutocompleteServiceImpl_1 = createCommonjsModule(function (module, exports) {

	  var __awaiter = commonjsGlobal && commonjsGlobal.__awaiter || function (thisArg, _arguments, P, generator) {
	    function adopt(value) {
	      return value instanceof P ? value : new P(function (resolve) {
	        resolve(value);
	      });
	    }

	    return new (P || (P = promise$3))(function (resolve, reject) {
	      function fulfilled(value) {
	        try {
	          step(generator.next(value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function rejected(value) {
	        try {
	          step(generator["throw"](value));
	        } catch (e) {
	          reject(e);
	        }
	      }

	      function step(result) {
	        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
	      }

	      step((generator = generator.apply(thisArg, _arguments || [])).next());
	    });
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.AutocompleteServiceImpl = void 0;
	  /**
	  * A service that performs query suggestions.
	  */

	  var AutocompleteServiceImpl = /*#__PURE__*/function () {
	    function AutocompleteServiceImpl(config, httpRequester, apiResponseValidator) {
	      var _a, _b, _c, _d, _e, _f;

	      this.config = config;
	      this.httpService = httpRequester;
	      this.apiResponseValidator = apiResponseValidator;
	      this.universalEndpoint = (_b = (_a = this.config.endpoints) === null || _a === void 0 ? void 0 : _a.universalAutocomplete) !== null && _b !== void 0 ? _b : constants.defaultEndpoints.universalAutocomplete;
	      this.verticalEndpoint = (_d = (_c = this.config.endpoints) === null || _c === void 0 ? void 0 : _c.verticalAutocomplete) !== null && _d !== void 0 ? _d : constants.defaultEndpoints.verticalAutocomplete;
	      this.filterEndpoint = (_f = (_e = this.config.endpoints) === null || _e === void 0 ? void 0 : _e.filterSearch) !== null && _f !== void 0 ? _f : constants.defaultEndpoints.filterSearch;
	    }
	    /**
	     * Retrieves query suggestions for universal.
	     *
	     * @param {AutocompleteRequest} request
	     * @returns {Promise<AutocompleteResponse>}
	     */


	    var _proto = AutocompleteServiceImpl.prototype;

	    _proto.universalAutocomplete = function universalAutocomplete(request) {
	      var _a;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee() {
	        var queryParams, response, validationResult;
	        return regenerator.wrap(function _callee$(_context) {
	          while (1) {
	            switch (_context.prev = _context.next) {
	              case 0:
	                queryParams = _extends({
	                  input: request.input,
	                  experienceKey: this.config.experienceKey,
	                  api_key: this.config.apiKey,
	                  v: constants.defaultApiVersion,
	                  version: this.config.experienceVersion,
	                  locale: this.config.locale,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled
	                }, (_a = this.config) === null || _a === void 0 ? void 0 : _a.additionalQueryParams);
	                _context.next = 3;
	                return this.httpService.get(this.universalEndpoint, queryParams);

	              case 3:
	                response = _context.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context.next = 7;
	                  break;
	                }

	                return _context.abrupt("return", promise$3.reject(validationResult));

	              case 7:
	                return _context.abrupt("return", createAutocompleteResponse_1.createAutocompleteResponse(response));

	              case 8:
	              case "end":
	                return _context.stop();
	            }
	          }
	        }, _callee, this);
	      }));
	    }
	    /**
	     * Retrieves query suggestions for a vertical.
	     *
	     * @param {VerticalAutocompleteRequest} request
	     * @returns {Promise<AutocompleteResponse>}
	     */
	    ;

	    _proto.verticalAutocomplete = function verticalAutocomplete(request) {
	      var _a;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee2() {
	        var queryParams, response, validationResult;
	        return regenerator.wrap(function _callee2$(_context2) {
	          while (1) {
	            switch (_context2.prev = _context2.next) {
	              case 0:
	                queryParams = _extends({
	                  input: request.input,
	                  experienceKey: this.config.experienceKey,
	                  api_key: this.config.apiKey,
	                  v: constants.defaultApiVersion,
	                  version: this.config.experienceVersion,
	                  locale: this.config.locale,
	                  verticalKey: request.verticalKey,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled
	                }, (_a = this.config) === null || _a === void 0 ? void 0 : _a.additionalQueryParams);
	                _context2.next = 3;
	                return this.httpService.get(this.verticalEndpoint, queryParams);

	              case 3:
	                response = _context2.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context2.next = 7;
	                  break;
	                }

	                return _context2.abrupt("return", promise$3.reject(validationResult));

	              case 7:
	                return _context2.abrupt("return", createAutocompleteResponse_1.createAutocompleteResponse(response));

	              case 8:
	              case "end":
	                return _context2.stop();
	            }
	          }
	        }, _callee2, this);
	      }));
	    }
	    /**
	     * Retrieves query suggestions for filter search.
	     *
	     * @param {FilterSearchRequest} request
	     * @returns {Promise<AutocompleteResponse>}
	     */
	    ;

	    _proto.filterSearch = function filterSearch(request) {
	      var _a;

	      return __awaiter(this, void 0, void 0, /*#__PURE__*/regenerator.mark(function _callee3() {
	        var searchParams, queryParams, response, validationResult;
	        return regenerator.wrap(function _callee3$(_context3) {
	          while (1) {
	            switch (_context3.prev = _context3.next) {
	              case 0:
	                searchParams = {
	                  sectioned: request.sectioned,
	                  fields: this.serializeSearchParameterFields(request.fields)
	                };
	                queryParams = _extends({
	                  input: request.input,
	                  experienceKey: this.config.experienceKey,
	                  api_key: this.config.apiKey,
	                  v: constants.defaultApiVersion,
	                  version: this.config.experienceVersion,
	                  locale: this.config.locale,
	                  search_parameters: stringify$2(searchParams),
	                  verticalKey: request.verticalKey,
	                  sessionTrackingEnabled: request.sessionTrackingEnabled
	                }, (_a = this.config) === null || _a === void 0 ? void 0 : _a.additionalQueryParams);
	                _context3.next = 4;
	                return this.httpService.get(this.filterEndpoint, queryParams);

	              case 4:
	                response = _context3.sent;
	                validationResult = this.apiResponseValidator.validate(response);

	                if (!(validationResult instanceof Error)) {
	                  _context3.next = 8;
	                  break;
	                }

	                return _context3.abrupt("return", promise$3.reject(validationResult));

	              case 8:
	                return _context3.abrupt("return", createAutocompleteResponse_1.createFilterSearchResponse(response));

	              case 9:
	              case "end":
	                return _context3.stop();
	            }
	          }
	        }, _callee3, this);
	      }));
	    };

	    _proto.serializeSearchParameterFields = function serializeSearchParameterFields(fields) {
	      return map$2(fields).call(fields, function (_ref) {
	        var fieldApiName = _ref.fieldApiName,
	            entityType = _ref.entityType,
	            fetchEntities = _ref.fetchEntities;
	        return {
	          fieldId: fieldApiName,
	          entityTypeId: entityType,
	          shouldFetchEntities: fetchEntities
	        };
	      });
	    };

	    return AutocompleteServiceImpl;
	  }();

	  exports.AutocompleteServiceImpl = AutocompleteServiceImpl;
	});
	unwrapExports(AutocompleteServiceImpl_1);
	var AutocompleteServiceImpl_2 = AutocompleteServiceImpl_1.AutocompleteServiceImpl;

	var $find = arrayIteration.find;


	var FIND = 'find';
	var SKIPS_HOLES = true;

	// Shouldn't skip holes
	if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

	// `Array.prototype.find` method
	// https://tc39.es/ecma262/#sec-array.prototype.find
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
	  find: function find(callbackfn /* , that = undefined */) {
	    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var find$1 = entryVirtual('Array').find;

	var ArrayPrototype$9 = Array.prototype;

	var find_1 = function (it) {
	  var own = it.find;
	  return it === ArrayPrototype$9 || (it instanceof Array && own === ArrayPrototype$9.find) ? find$1 : own;
	};

	var find$2 = find_1;

	var find$3 = find$2;

	var create$3 = create;

	var create$4 = create$3;

	// `Object.setPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.setprototypeof
	_export({ target: 'Object', stat: true }, {
	  setPrototypeOf: objectSetPrototypeOf
	});

	var setPrototypeOf = path.Object.setPrototypeOf;

	var setPrototypeOf$1 = setPrototypeOf;

	var setPrototypeOf$2 = setPrototypeOf$1;

	var setPrototypeOf$3 = createCommonjsModule(function (module) {
	function _setPrototypeOf(o, p) {
	  module.exports = _setPrototypeOf = setPrototypeOf$2 || function _setPrototypeOf(o, p) {
	    o.__proto__ = p;
	    return o;
	  };

	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	  return _setPrototypeOf(o, p);
	}

	module.exports = _setPrototypeOf;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	unwrapExports(setPrototypeOf$3);

	var inheritsLoose = createCommonjsModule(function (module) {
	function _inheritsLoose(subClass, superClass) {
	  subClass.prototype = create$4(superClass.prototype);
	  subClass.prototype.constructor = subClass;
	  setPrototypeOf$3(subClass, superClass);
	}

	module.exports = _inheritsLoose;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _inheritsLoose = unwrapExports(inheritsLoose);

	var freezing = !fails(function () {
	  return Object.isExtensible(Object.preventExtensions({}));
	});

	var internalMetadata = createCommonjsModule(function (module) {
	var defineProperty = objectDefineProperty.f;



	var METADATA = uid('meta');
	var id = 0;

	var isExtensible = Object.isExtensible || function () {
	  return true;
	};

	var setMetadata = function (it) {
	  defineProperty(it, METADATA, { value: {
	    objectID: 'O' + ++id, // object ID
	    weakData: {}          // weak collections IDs
	  } });
	};

	var fastKey = function (it, create) {
	  // return a primitive with prefix
	  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return 'F';
	    // not necessary to add metadata
	    if (!create) return 'E';
	    // add missing metadata
	    setMetadata(it);
	  // return object ID
	  } return it[METADATA].objectID;
	};

	var getWeakData = function (it, create) {
	  if (!has(it, METADATA)) {
	    // can't set metadata to uncaught frozen object
	    if (!isExtensible(it)) return true;
	    // not necessary to add metadata
	    if (!create) return false;
	    // add missing metadata
	    setMetadata(it);
	  // return the store of weak collections IDs
	  } return it[METADATA].weakData;
	};

	// add metadata on freeze-family methods calling
	var onFreeze = function (it) {
	  if (freezing && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
	  return it;
	};

	var meta = module.exports = {
	  REQUIRED: false,
	  fastKey: fastKey,
	  getWeakData: getWeakData,
	  onFreeze: onFreeze
	};

	hiddenKeys[METADATA] = true;
	});
	var internalMetadata_1 = internalMetadata.REQUIRED;
	var internalMetadata_2 = internalMetadata.fastKey;
	var internalMetadata_3 = internalMetadata.getWeakData;
	var internalMetadata_4 = internalMetadata.onFreeze;

	var defineProperty$8 = objectDefineProperty.f;
	var forEach$3 = arrayIteration.forEach;



	var setInternalState$6 = internalState.set;
	var internalStateGetterFor = internalState.getterFor;

	var collection = function (CONSTRUCTOR_NAME, wrapper, common) {
	  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
	  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
	  var ADDER = IS_MAP ? 'set' : 'add';
	  var NativeConstructor = global_1[CONSTRUCTOR_NAME];
	  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
	  var exported = {};
	  var Constructor;

	  if (!descriptors || typeof NativeConstructor != 'function'
	    || !(IS_WEAK || NativePrototype.forEach && !fails(function () { new NativeConstructor().entries().next(); }))
	  ) {
	    // create collection constructor
	    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
	    internalMetadata.REQUIRED = true;
	  } else {
	    Constructor = wrapper(function (target, iterable) {
	      setInternalState$6(anInstance(target, Constructor, CONSTRUCTOR_NAME), {
	        type: CONSTRUCTOR_NAME,
	        collection: new NativeConstructor()
	      });
	      if (iterable != undefined) iterate(iterable, target[ADDER], { that: target, AS_ENTRIES: IS_MAP });
	    });

	    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

	    forEach$3(['add', 'clear', 'delete', 'forEach', 'get', 'has', 'set', 'keys', 'values', 'entries'], function (KEY) {
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if (KEY in NativePrototype && !(IS_WEAK && KEY == 'clear')) {
	        createNonEnumerableProperty(Constructor.prototype, KEY, function (a, b) {
	          var collection = getInternalState(this).collection;
	          if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
	          var result = collection[KEY](a === 0 ? 0 : a, b);
	          return IS_ADDER ? this : result;
	        });
	      }
	    });

	    IS_WEAK || defineProperty$8(Constructor.prototype, 'size', {
	      configurable: true,
	      get: function () {
	        return getInternalState(this).collection.size;
	      }
	    });
	  }

	  setToStringTag(Constructor, CONSTRUCTOR_NAME, false, true);

	  exported[CONSTRUCTOR_NAME] = Constructor;
	  _export({ global: true, forced: true }, exported);

	  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

	  return Constructor;
	};

	var defineProperty$9 = objectDefineProperty.f;








	var fastKey = internalMetadata.fastKey;


	var setInternalState$7 = internalState.set;
	var internalStateGetterFor$1 = internalState.getterFor;

	var collectionStrong = {
	  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
	    var C = wrapper(function (that, iterable) {
	      anInstance(that, C, CONSTRUCTOR_NAME);
	      setInternalState$7(that, {
	        type: CONSTRUCTOR_NAME,
	        index: objectCreate(null),
	        first: undefined,
	        last: undefined,
	        size: 0
	      });
	      if (!descriptors) that.size = 0;
	      if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP });
	    });

	    var getInternalState = internalStateGetterFor$1(CONSTRUCTOR_NAME);

	    var define = function (that, key, value) {
	      var state = getInternalState(that);
	      var entry = getEntry(that, key);
	      var previous, index;
	      // change existing entry
	      if (entry) {
	        entry.value = value;
	      // create new entry
	      } else {
	        state.last = entry = {
	          index: index = fastKey(key, true),
	          key: key,
	          value: value,
	          previous: previous = state.last,
	          next: undefined,
	          removed: false
	        };
	        if (!state.first) state.first = entry;
	        if (previous) previous.next = entry;
	        if (descriptors) state.size++;
	        else that.size++;
	        // add to index
	        if (index !== 'F') state.index[index] = entry;
	      } return that;
	    };

	    var getEntry = function (that, key) {
	      var state = getInternalState(that);
	      // fast case
	      var index = fastKey(key);
	      var entry;
	      if (index !== 'F') return state.index[index];
	      // frozen object case
	      for (entry = state.first; entry; entry = entry.next) {
	        if (entry.key == key) return entry;
	      }
	    };

	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear() {
	        var that = this;
	        var state = getInternalState(that);
	        var data = state.index;
	        var entry = state.first;
	        while (entry) {
	          entry.removed = true;
	          if (entry.previous) entry.previous = entry.previous.next = undefined;
	          delete data[entry.index];
	          entry = entry.next;
	        }
	        state.first = state.last = undefined;
	        if (descriptors) state.size = 0;
	        else that.size = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function (key) {
	        var that = this;
	        var state = getInternalState(that);
	        var entry = getEntry(that, key);
	        if (entry) {
	          var next = entry.next;
	          var prev = entry.previous;
	          delete state.index[entry.index];
	          entry.removed = true;
	          if (prev) prev.next = next;
	          if (next) next.previous = prev;
	          if (state.first == entry) state.first = next;
	          if (state.last == entry) state.last = prev;
	          if (descriptors) state.size--;
	          else that.size--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /* , that = undefined */) {
	        var state = getInternalState(this);
	        var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	        var entry;
	        while (entry = entry ? entry.next : state.first) {
	          boundFunction(entry.value, entry.key, this);
	          // revert to the last existing entry
	          while (entry && entry.removed) entry = entry.previous;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key) {
	        return !!getEntry(this, key);
	      }
	    });

	    redefineAll(C.prototype, IS_MAP ? {
	      // 23.1.3.6 Map.prototype.get(key)
	      get: function get(key) {
	        var entry = getEntry(this, key);
	        return entry && entry.value;
	      },
	      // 23.1.3.9 Map.prototype.set(key, value)
	      set: function set(key, value) {
	        return define(this, key === 0 ? 0 : key, value);
	      }
	    } : {
	      // 23.2.3.1 Set.prototype.add(value)
	      add: function add(value) {
	        return define(this, value = value === 0 ? 0 : value, value);
	      }
	    });
	    if (descriptors) defineProperty$9(C.prototype, 'size', {
	      get: function () {
	        return getInternalState(this).size;
	      }
	    });
	    return C;
	  },
	  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
	    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
	    var getInternalCollectionState = internalStateGetterFor$1(CONSTRUCTOR_NAME);
	    var getInternalIteratorState = internalStateGetterFor$1(ITERATOR_NAME);
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
	      setInternalState$7(this, {
	        type: ITERATOR_NAME,
	        target: iterated,
	        state: getInternalCollectionState(iterated),
	        kind: kind,
	        last: undefined
	      });
	    }, function () {
	      var state = getInternalIteratorState(this);
	      var kind = state.kind;
	      var entry = state.last;
	      // revert to the last existing entry
	      while (entry && entry.removed) entry = entry.previous;
	      // get next entry
	      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
	        // or finish the iteration
	        state.target = undefined;
	        return { value: undefined, done: true };
	      }
	      // return step by kind
	      if (kind == 'keys') return { value: entry.key, done: false };
	      if (kind == 'values') return { value: entry.value, done: false };
	      return { value: [entry.key, entry.value], done: false };
	    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(CONSTRUCTOR_NAME);
	  }
	};

	// `Map` constructor
	// https://tc39.es/ecma262/#sec-map-objects
	var es_map = collection('Map', function (init) {
	  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var map$3 = path.Map;

	// https://tc39.github.io/proposal-setmap-offrom/




	var collectionFrom = function from(source /* , mapFn, thisArg */) {
	  var length = arguments.length;
	  var mapFn = length > 1 ? arguments[1] : undefined;
	  var mapping, array, n, boundFunction;
	  aFunction(this);
	  mapping = mapFn !== undefined;
	  if (mapping) aFunction(mapFn);
	  if (source == undefined) return new this();
	  array = [];
	  if (mapping) {
	    n = 0;
	    boundFunction = functionBindContext(mapFn, length > 2 ? arguments[2] : undefined, 2);
	    iterate(source, function (nextItem) {
	      array.push(boundFunction(nextItem, n++));
	    });
	  } else {
	    iterate(source, array.push, { that: array });
	  }
	  return new this(array);
	};

	// `Map.from` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
	_export({ target: 'Map', stat: true }, {
	  from: collectionFrom
	});

	// https://tc39.github.io/proposal-setmap-offrom/
	var collectionOf = function of() {
	  var length = arguments.length;
	  var A = new Array(length);
	  while (length--) A[length] = arguments[length];
	  return new this(A);
	};

	// `Map.of` method
	// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
	_export({ target: 'Map', stat: true }, {
	  of: collectionOf
	});

	// https://github.com/tc39/collection-methods
	var collectionDeleteAll = function (/* ...elements */) {
	  var collection = anObject(this);
	  var remover = aFunction(collection['delete']);
	  var allDeleted = true;
	  var wasDeleted;
	  for (var k = 0, len = arguments.length; k < len; k++) {
	    wasDeleted = remover.call(collection, arguments[k]);
	    allDeleted = allDeleted && wasDeleted;
	  }
	  return !!allDeleted;
	};

	// `Map.prototype.deleteAll` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  deleteAll: function deleteAll(/* ...elements */) {
	    return collectionDeleteAll.apply(this, arguments);
	  }
	});

	// `Map.prototype.emplace` method
	// https://github.com/thumbsupep/proposal-upsert
	var mapEmplace = function emplace(key, handler) {
	  var map = anObject(this);
	  var value = (map.has(key) && 'update' in handler)
	    ? handler.update(map.get(key), key, map)
	    : handler.insert(key, map);
	  map.set(key, value);
	  return value;
	};

	// `Map.prototype.emplace` method
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  emplace: mapEmplace
	});

	var getMapIterator =  getIterator ;

	// `Map.prototype.every` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  every: function every(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return !iterate(iterator, function (key, value, stop) {
	      if (!boundFunction(value, key, map)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Map.prototype.filter` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  filter: function filter(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction(newMap.set);
	    iterate(iterator, function (key, value) {
	      if (boundFunction(value, key, map)) setter.call(newMap, key, value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.find` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  find: function find(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop(value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Map.prototype.findKey` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  findKey: function findKey(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop(key);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Map.groupBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true }, {
	  groupBy: function groupBy(iterable, keyDerivative) {
	    var newMap = new this();
	    aFunction(keyDerivative);
	    var has = aFunction(newMap.has);
	    var get = aFunction(newMap.get);
	    var set = aFunction(newMap.set);
	    iterate(iterable, function (element) {
	      var derivedKey = keyDerivative(element);
	      if (!has.call(newMap, derivedKey)) set.call(newMap, derivedKey, [element]);
	      else get.call(newMap, derivedKey).push(element);
	    });
	    return newMap;
	  }
	});

	// `SameValueZero` abstract operation
	// https://tc39.es/ecma262/#sec-samevaluezero
	var sameValueZero = function (x, y) {
	  // eslint-disable-next-line no-self-compare -- NaN check
	  return x === y || x != x && y != y;
	};

	// `Map.prototype.includes` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  includes: function includes(searchElement) {
	    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
	      if (sameValueZero(value, searchElement)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Map.keyBy` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', stat: true }, {
	  keyBy: function keyBy(iterable, keyDerivative) {
	    var newMap = new this();
	    aFunction(keyDerivative);
	    var setter = aFunction(newMap.set);
	    iterate(iterable, function (element) {
	      setter.call(newMap, keyDerivative(element), element);
	    });
	    return newMap;
	  }
	});

	// `Map.prototype.includes` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  keyOf: function keyOf(searchElement) {
	    return iterate(getMapIterator(anObject(this)), function (key, value, stop) {
	      if (value === searchElement) return stop(key);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).result;
	  }
	});

	// `Map.prototype.mapKeys` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  mapKeys: function mapKeys(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction(newMap.set);
	    iterate(iterator, function (key, value) {
	      setter.call(newMap, boundFunction(value, key, map), value);
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.mapValues` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  mapValues: function mapValues(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    var newMap = new (speciesConstructor(map, getBuiltIn('Map')))();
	    var setter = aFunction(newMap.set);
	    iterate(iterator, function (key, value) {
	      setter.call(newMap, key, boundFunction(value, key, map));
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    return newMap;
	  }
	});

	// `Map.prototype.merge` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  // eslint-disable-next-line no-unused-vars -- required for `.length`
	  merge: function merge(iterable /* ...iterbles */) {
	    var map = anObject(this);
	    var setter = aFunction(map.set);
	    var i = 0;
	    while (i < arguments.length) {
	      iterate(arguments[i++], setter, { that: map, AS_ENTRIES: true });
	    }
	    return map;
	  }
	});

	// `Map.prototype.reduce` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  reduce: function reduce(callbackfn /* , initialValue */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var noInitial = arguments.length < 2;
	    var accumulator = noInitial ? undefined : arguments[1];
	    aFunction(callbackfn);
	    iterate(iterator, function (key, value) {
	      if (noInitial) {
	        noInitial = false;
	        accumulator = value;
	      } else {
	        accumulator = callbackfn(accumulator, value, key, map);
	      }
	    }, { AS_ENTRIES: true, IS_ITERATOR: true });
	    if (noInitial) throw TypeError('Reduce of empty map with no initial value');
	    return accumulator;
	  }
	});

	// `Set.prototype.some` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  some: function some(callbackfn /* , thisArg */) {
	    var map = anObject(this);
	    var iterator = getMapIterator(map);
	    var boundFunction = functionBindContext(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
	    return iterate(iterator, function (key, value, stop) {
	      if (boundFunction(value, key, map)) return stop();
	    }, { AS_ENTRIES: true, IS_ITERATOR: true, INTERRUPTED: true }).stopped;
	  }
	});

	// `Set.prototype.update` method
	// https://github.com/tc39/proposal-collection-methods
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  update: function update(key, callback /* , thunk */) {
	    var map = anObject(this);
	    var length = arguments.length;
	    aFunction(callback);
	    var isPresentInMap = map.has(key);
	    if (!isPresentInMap && length < 3) {
	      throw TypeError('Updating absent value');
	    }
	    var value = isPresentInMap ? map.get(key) : aFunction(length > 2 ? arguments[2] : undefined)(key, map);
	    map.set(key, callback(value, key, map));
	    return map;
	  }
	});

	// `Map.prototype.upsert` method
	// https://github.com/thumbsupep/proposal-upsert
	var mapUpsert = function upsert(key, updateFn /* , insertFn */) {
	  var map = anObject(this);
	  var insertFn = arguments.length > 2 ? arguments[2] : undefined;
	  var value;
	  if (typeof updateFn != 'function' && typeof insertFn != 'function') {
	    throw TypeError('At least one callback required');
	  }
	  if (map.has(key)) {
	    value = map.get(key);
	    if (typeof updateFn == 'function') {
	      value = updateFn(value);
	      map.set(key, value);
	    }
	  } else if (typeof insertFn == 'function') {
	    value = insertFn();
	    map.set(key, value);
	  } return value;
	};

	// TODO: remove from `core-js@4`




	// `Map.prototype.upsert` method (replaced by `Map.prototype.emplace`)
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  upsert: mapUpsert
	});

	// TODO: remove from `core-js@4`




	// `Map.prototype.updateOrInsert` method (replaced by `Map.prototype.emplace`)
	// https://github.com/thumbsupep/proposal-upsert
	_export({ target: 'Map', proto: true, real: true, forced: isPure }, {
	  updateOrInsert: mapUpsert
	});

	// TODO: remove from `core-js@4`

	// TODO: remove from `core-js@4`


	var map$4 = map$3;

	var map$5 = map$4;

	var FAILS_ON_PRIMITIVES$3 = fails(function () { objectGetPrototypeOf(1); });

	// `Object.getPrototypeOf` method
	// https://tc39.es/ecma262/#sec-object.getprototypeof
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$3, sham: !correctPrototypeGetter }, {
	  getPrototypeOf: function getPrototypeOf(it) {
	    return objectGetPrototypeOf(toObject(it));
	  }
	});

	var getPrototypeOf = path.Object.getPrototypeOf;

	var getPrototypeOf$1 = getPrototypeOf;

	var getPrototypeOf$2 = getPrototypeOf$1;

	var getPrototypeOf$3 = createCommonjsModule(function (module) {
	function _getPrototypeOf(o) {
	  module.exports = _getPrototypeOf = setPrototypeOf$2 ? getPrototypeOf$2 : function _getPrototypeOf(o) {
	    return o.__proto__ || getPrototypeOf$2(o);
	  };
	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	  return _getPrototypeOf(o);
	}

	module.exports = _getPrototypeOf;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	unwrapExports(getPrototypeOf$3);

	var indexOf$4 = indexOf_1;

	var indexOf$5 = indexOf$4;

	var isNativeFunction = createCommonjsModule(function (module) {
	function _isNativeFunction(fn) {
	  var _context;

	  return indexOf$5(_context = Function.toString.call(fn)).call(_context, "[native code]") !== -1;
	}

	module.exports = _isNativeFunction;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	unwrapExports(isNativeFunction);

	var nativeConstruct = getBuiltIn('Reflect', 'construct');

	// `Reflect.construct` method
	// https://tc39.es/ecma262/#sec-reflect.construct
	// MS Edge supports only 2 arguments and argumentsList argument is optional
	// FF Nightly sets third argument as `new.target`, but does not create `this` from it
	var NEW_TARGET_BUG = fails(function () {
	  function F() { /* empty */ }
	  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
	});
	var ARGS_BUG = !fails(function () {
	  nativeConstruct(function () { /* empty */ });
	});
	var FORCED$5 = NEW_TARGET_BUG || ARGS_BUG;

	_export({ target: 'Reflect', stat: true, forced: FORCED$5, sham: FORCED$5 }, {
	  construct: function construct(Target, args /* , newTarget */) {
	    aFunction(Target);
	    anObject(args);
	    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
	    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
	    if (Target == newTarget) {
	      // w/o altered newTarget, optimization for 0-4 arguments
	      switch (args.length) {
	        case 0: return new Target();
	        case 1: return new Target(args[0]);
	        case 2: return new Target(args[0], args[1]);
	        case 3: return new Target(args[0], args[1], args[2]);
	        case 4: return new Target(args[0], args[1], args[2], args[3]);
	      }
	      // w/o altered newTarget, lot of arguments case
	      var $args = [null];
	      $args.push.apply($args, args);
	      return new (functionBind.apply(Target, $args))();
	    }
	    // with altered newTarget, not support built-in constructors
	    var proto = newTarget.prototype;
	    var instance = objectCreate(isObject(proto) ? proto : Object.prototype);
	    var result = Function.apply.call(Target, instance, args);
	    return isObject(result) ? result : instance;
	  }
	});

	var construct$1 = path.Reflect.construct;

	var construct$2 = construct$1;

	var construct$3 = construct$2;

	var bind$4 = bind_1;

	var bind$5 = bind$4;

	var isNativeReflectConstruct = createCommonjsModule(function (module) {
	function _isNativeReflectConstruct() {
	  if (typeof Reflect === "undefined" || !construct$3) return false;
	  if (construct$3.sham) return false;
	  if (typeof Proxy === "function") return true;

	  try {
	    Boolean.prototype.valueOf.call(construct$3(Boolean, [], function () {}));
	    return true;
	  } catch (e) {
	    return false;
	  }
	}

	module.exports = _isNativeReflectConstruct;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	unwrapExports(isNativeReflectConstruct);

	var construct$4 = createCommonjsModule(function (module) {
	function _construct(Parent, args, Class) {
	  if (isNativeReflectConstruct()) {
	    module.exports = _construct = construct$3;
	    module.exports["default"] = module.exports, module.exports.__esModule = true;
	  } else {
	    module.exports = _construct = function _construct(Parent, args, Class) {
	      var a = [null];
	      a.push.apply(a, args);

	      var Constructor = bind$5(Function).apply(Parent, a);

	      var instance = new Constructor();
	      if (Class) setPrototypeOf$3(instance, Class.prototype);
	      return instance;
	    };

	    module.exports["default"] = module.exports, module.exports.__esModule = true;
	  }

	  return _construct.apply(null, arguments);
	}

	module.exports = _construct;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	unwrapExports(construct$4);

	var wrapNativeSuper = createCommonjsModule(function (module) {
	function _wrapNativeSuper(Class) {
	  var _cache = typeof map$5 === "function" ? new map$5() : undefined;

	  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
	    if (Class === null || !isNativeFunction(Class)) return Class;

	    if (typeof Class !== "function") {
	      throw new TypeError("Super expression must either be null or a function");
	    }

	    if (typeof _cache !== "undefined") {
	      if (_cache.has(Class)) return _cache.get(Class);

	      _cache.set(Class, Wrapper);
	    }

	    function Wrapper() {
	      return construct$4(Class, arguments, getPrototypeOf$3(this).constructor);
	    }

	    Wrapper.prototype = create$4(Class.prototype, {
	      constructor: {
	        value: Wrapper,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	    return setPrototypeOf$3(Wrapper, Class);
	  };

	  module.exports["default"] = module.exports, module.exports.__esModule = true;
	  return _wrapNativeSuper(Class);
	}

	module.exports = _wrapNativeSuper;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _wrapNativeSuper = unwrapExports(wrapNativeSuper);

	var AnswersError_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.AnswersError = void 0;
	  /**
	   * Represents an error
	   *
	   * @remarks
	   * If the error originates from the Answer API, the code and type property will be present.
	   *
	   * @public
	   */

	  var AnswersError = /*#__PURE__*/function (_Error) {
	    _inheritsLoose(AnswersError, _Error);

	    /** @internal */
	    function AnswersError(message, code, type) {
	      var _this;

	      _this = _Error.call(this, message) || this;
	      _this.message = message;
	      _this.code = code;
	      _this.type = type;
	      return _this;
	    }

	    return AnswersError;
	  }( /*#__PURE__*/_wrapNativeSuper(Error));

	  exports.AnswersError = AnswersError;
	});
	unwrapExports(AnswersError_1);
	var AnswersError_2 = AnswersError_1.AnswersError;

	var ApiResponseValidator_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.ApiResponseValidator = void 0;
	  /**
	   * Determines whether or not an API response can be used to construct an answers-core response
	   *
	   * @internal
	   */

	  var ApiResponseValidator = /*#__PURE__*/function () {
	    function ApiResponseValidator() {}

	    var _proto = ApiResponseValidator.prototype;

	    _proto.validate = function validate(apiResponse) {
	      var testFunctions = [this.validateResponseProp, this.validateMetaProp, this.checkForApiErrors];

	      var testResults = map$2(testFunctions).call(testFunctions, function (testFn) {
	        return testFn(apiResponse);
	      });

	      return find$3(testResults).call(testResults, function (result) {
	        return result instanceof AnswersError_1.AnswersError;
	      });
	    };

	    _proto.validateResponseProp = function validateResponseProp(apiResponse) {
	      if (!apiResponse.response) {
	        return new AnswersError_1.AnswersError('Malformed Answers API response: missing response property.');
	      }
	    };

	    _proto.validateMetaProp = function validateMetaProp(apiResponse) {
	      if (!apiResponse.meta) {
	        return new AnswersError_1.AnswersError('Malformed Answers API response: missing meta property.');
	      }
	    };

	    _proto.checkForApiErrors = function checkForApiErrors(apiResponse) {
	      var _a, _b;

	      if (((_b = (_a = apiResponse.meta) === null || _a === void 0 ? void 0 : _a.errors) === null || _b === void 0 ? void 0 : _b.length) >= 1) {
	        var error = apiResponse.meta.errors[0];
	        return new AnswersError_1.AnswersError(error.message, error.code, error.type);
	      }
	    };

	    return ApiResponseValidator;
	  }();

	  exports.ApiResponseValidator = ApiResponseValidator;
	});
	unwrapExports(ApiResponseValidator_1);
	var ApiResponseValidator_2 = ApiResponseValidator_1.ApiResponseValidator;

	var AutocompleteRequest = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });
	});
	unwrapExports(AutocompleteRequest);

	var AutocompleteResponse = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });
	});
	unwrapExports(AutocompleteResponse);

	var CombinedFilter = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.FilterCombinator = void 0;
	  /**
	   * Indicates how the filters in a {@link CombinedFilter} should be combined.
	   *
	   * @public
	   */

	  var FilterCombinator;

	  (function (FilterCombinator) {
	    /** Indicates that filters should be combined with a logical AND. */
	    FilterCombinator["AND"] = "$and";
	    /** Indicates that filters should be combined with a logical OR. */

	    FilterCombinator["OR"] = "$or";
	  })(FilterCombinator = exports.FilterCombinator || (exports.FilterCombinator = {}));
	});
	unwrapExports(CombinedFilter);
	var CombinedFilter_1 = CombinedFilter.FilterCombinator;

	var QueryTrigger_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.QueryTrigger = void 0;
	  /**
	   * Describes the ways a search can be executed besides user input.
	   *
	   * @remarks
	   * Used for search analytics. If a user supplied the search query, do not include a QueryTrigger.
	   *
	   * @example
	   * An answers site may be configured to perform a search for 'What services do you offer?' when the page
	   * loads. Because that query is a default query rather than a user-supplied query, the Initialize QueryTrigger
	   * should be included in the request.
	   *
	   * @public
	   */

	  var QueryTrigger;

	  (function (QueryTrigger) {
	    /** Indicates that the query was triggered by a default initial search. */
	    QueryTrigger["Initialize"] = "initialize";
	    /** Indicates that the query was suggested by a {@link SpellCheck} response. */

	    QueryTrigger["Suggest"] = "suggest";
	  })(QueryTrigger = exports.QueryTrigger || (exports.QueryTrigger = {}));
	});
	unwrapExports(QueryTrigger_1);
	var QueryTrigger_2 = QueryTrigger_1.QueryTrigger;

	var SortType_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.SortType = void 0;
	  /**
	   * The method of sorting.
	   *
	   * @public
	   */

	  var SortType;

	  (function (SortType) {
	    /**
	     * Sorts based on a field with the direction specified.
	     */
	    SortType["Field"] = "FIELD";
	    /**
	     * Sorts based on entity distance alone.
	     */

	    SortType["EntityDistance"] = "ENTITY_DISTANCE";
	    /**
	     * Sorts based on relevance according to the algorithm and, when relevant, location bias.
	     */

	    SortType["Relevance"] = "RELEVANCE";
	  })(SortType = exports.SortType || (exports.SortType = {}));
	});
	unwrapExports(SortType_1);
	var SortType_2 = SortType_1.SortType;

	var Direction_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.Direction = void 0;
	  /**
	   * The direction of a sort.
	   *
	   * @public
	   */

	  var Direction;

	  (function (Direction) {
	    /**
	     *  An ascending sort
	     *
	     * @remarks
	     * For numbers this sort is low to high. For text it is alphabetical. For dates it is chronological order.
	     */
	    Direction["Ascending"] = "ASC";
	    /**
	     * A descending soft
	     *
	     * @remarks
	     * For numbers this sort is high to low. For text it is reverse alphabetical. For dates it is reverse
	     * chronological order.
	     */

	    Direction["Descending"] = "DESC";
	  })(Direction = exports.Direction || (exports.Direction = {}));
	});
	unwrapExports(Direction_1);
	var Direction_2 = Direction_1.Direction;

	var LocationBias = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.LocationBiasMethod = void 0;
	  /**
	   * The method used to determine the location.
	   *
	   * @public
	   */

	  var LocationBiasMethod;

	  (function (LocationBiasMethod) {
	    /** Location was determined by IP address. */
	    LocationBiasMethod["Ip"] = "IP";
	    /**
	     * Location was supplied by the user's device.
	     *
	     * @remarks
	     * This location bias method is set when a location is supplied in search requests.
	     * */

	    LocationBiasMethod["Device"] = "DEVICE";
	    /**
	     * Location is unknown.
	     */

	    LocationBiasMethod["Unknown"] = "UNKNOWN";
	  })(LocationBiasMethod = exports.LocationBiasMethod || (exports.LocationBiasMethod = {}));
	});
	unwrapExports(LocationBias);
	var LocationBias_1 = LocationBias.LocationBiasMethod;

	var SearchIntent_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.SearchIntent = void 0;
	  /**
	   * Represents intents from the Answers API.
	   *
	   * @public
	   */

	  var SearchIntent;

	  (function (SearchIntent) {
	    /** The Answers API is requesting a prompt for the user's location. */
	    SearchIntent["NearMe"] = "NEAR_ME";
	  })(SearchIntent = exports.SearchIntent || (exports.SearchIntent = {}));
	});
	unwrapExports(SearchIntent_1);
	var SearchIntent_2 = SearchIntent_1.SearchIntent;

	var SpellCheck = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.SpellCheckType = void 0;
	  /**
	   * Represents the type of spell check performed.
	   *
	   * @public
	   */

	  var SpellCheckType;

	  (function (SpellCheckType) {
	    /** The API is suggesting an alternative query. */
	    SpellCheckType["Suggest"] = "SUGGEST";
	    /** The API is autocorrecting the original query. */

	    SpellCheckType["AutoCorrect"] = "AUTOCORRECT";
	    /** The API may be doing some combination of suggesting or autocorrecting. */

	    SpellCheckType["Combine"] = "COMBINE";
	  })(SpellCheckType = exports.SpellCheckType || (exports.SpellCheckType = {}));
	});
	unwrapExports(SpellCheck);
	var SpellCheck_1 = SpellCheck.SpellCheckType;

	var Matcher_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.Matcher = void 0;
	  /**
	   * A Matcher is a filtering operation.
	   *
	   * @public
	   */

	  var Matcher;

	  (function (Matcher) {
	    /**
	     * An equals comparison.
	     *
	     * @remarks
	     * Compatible with all field types.
	     */
	    Matcher["Equals"] = "$eq";
	    /**
	     * A not equals comparison.
	     *
	     * @remarks
	     * Compatible with all field types.
	     */

	    Matcher["NotEquals"] = "!$eq";
	    /**
	     * A less than comparison.
	     *
	     * @remarks
	     * Compatible with integer, float, date, datetime, and time fields.
	     */

	    Matcher["LessThan"] = "$lt";
	    /**
	     * A less than or equal to comparison.
	     *
	     * @remarks
	     * Compatible with integer, float, date, datetime, and time fields.
	     */

	    Matcher["LessThanOrEqualTo"] = "$le";
	    /**
	     * A greater than comparison.
	     *
	     * @remarks
	     * Compatible with integer, float, date, datetime, and time fields.
	     */

	    Matcher["GreaterThan"] = "$gt";
	    /**
	     * A greater than or equal to comparison.
	     *
	     * @remarks
	     * Compatible with integer, float, date, datetime, and time fields.
	     */

	    Matcher["GreaterThanOrEqualTo"] = "$ge";
	    /**
	     * A comparison of whether an entity is within a certain radius of a certain location.
	     *
	     * @remarks
	     * Only compatible with the builtin.location field.
	     */

	    Matcher["Near"] = "$near";
	  })(Matcher = exports.Matcher || (exports.Matcher = {}));
	});
	unwrapExports(Matcher_1);
	var Matcher_2 = Matcher_1.Matcher;

	var models = createCommonjsModule(function (module, exports) {

	  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (create$2 ? function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;

	    defineProperty$3(o, k2, {
	      enumerable: true,
	      get: function get() {
	        return m[k];
	      }
	    });
	  } : function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	  });

	  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
	    for (var p in m) {
	      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	    }
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.Matcher = exports.SpellCheckType = exports.Source = exports.SearchIntent = exports.LocationBiasMethod = exports.DirectAnswerType = exports.Direction = exports.SortType = exports.QueryTrigger = exports.QuerySource = exports.FilterCombinator = exports.AnswersError = void 0; // Answers API models

	  defineProperty$3(exports, "AnswersError", {
	    enumerable: true,
	    get: function get() {
	      return AnswersError_1.AnswersError;
	    }
	  }); // Autocomplete service


	  __exportStar(AutocompleteRequest, exports);

	  __exportStar(AutocompleteResponse, exports); // Search service request models


	  defineProperty$3(exports, "FilterCombinator", {
	    enumerable: true,
	    get: function get() {
	      return CombinedFilter.FilterCombinator;
	    }
	  });

	  defineProperty$3(exports, "QuerySource", {
	    enumerable: true,
	    get: function get() {
	      return QuerySource_1.QuerySource;
	    }
	  });

	  defineProperty$3(exports, "QueryTrigger", {
	    enumerable: true,
	    get: function get() {
	      return QueryTrigger_1.QueryTrigger;
	    }
	  });

	  defineProperty$3(exports, "SortType", {
	    enumerable: true,
	    get: function get() {
	      return SortType_1.SortType;
	    }
	  });

	  defineProperty$3(exports, "Direction", {
	    enumerable: true,
	    get: function get() {
	      return Direction_1.Direction;
	    }
	  });

	  defineProperty$3(exports, "DirectAnswerType", {
	    enumerable: true,
	    get: function get() {
	      return DirectAnswerType_1.DirectAnswerType;
	    }
	  });

	  defineProperty$3(exports, "LocationBiasMethod", {
	    enumerable: true,
	    get: function get() {
	      return LocationBias.LocationBiasMethod;
	    }
	  });

	  defineProperty$3(exports, "SearchIntent", {
	    enumerable: true,
	    get: function get() {
	      return SearchIntent_1.SearchIntent;
	    }
	  });

	  defineProperty$3(exports, "Source", {
	    enumerable: true,
	    get: function get() {
	      return Source_1.Source;
	    }
	  });

	  defineProperty$3(exports, "SpellCheckType", {
	    enumerable: true,
	    get: function get() {
	      return SpellCheck.SpellCheckType;
	    }
	  }); // Search service common models


	  defineProperty$3(exports, "Matcher", {
	    enumerable: true,
	    get: function get() {
	      return Matcher_1.Matcher;
	    }
	  });
	});
	unwrapExports(models);
	var models_1 = models.Matcher;
	var models_2 = models.SpellCheckType;
	var models_3 = models.Source;
	var models_4 = models.SearchIntent;
	var models_5 = models.LocationBiasMethod;
	var models_6 = models.DirectAnswerType;
	var models_7 = models.Direction;
	var models_8 = models.SortType;
	var models_9 = models.QueryTrigger;
	var models_10 = models.QuerySource;
	var models_11 = models.FilterCombinator;
	var models_12 = models.AnswersError;

	var commonjs = createCommonjsModule(function (module, exports) {

	  var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (create$2 ? function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;

	    defineProperty$3(o, k2, {
	      enumerable: true,
	      get: function get() {
	        return m[k];
	      }
	    });
	  } : function (o, m, k, k2) {
	    if (k2 === undefined) k2 = k;
	    o[k2] = m[k];
	  });

	  var __exportStar = commonjsGlobal && commonjsGlobal.__exportStar || function (m, exports) {
	    for (var p in m) {
	      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
	    }
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.AnswersCore = exports.provideCore = void 0;

	  defineProperty$3(exports, "AnswersCore", {
	    enumerable: true,
	    get: function get() {
	      return AnswersCore_1.AnswersCore;
	    }
	  });
	  /**
	   * The entrypoint to the answers-core library.
	   *
	   * @remarks
	   * Returns an {@link AnswersCore} instance.
	   *
	   * @param config - The answers-core config
	   *
	   * @public
	   */


	  function provideCore(config) {
	    var httpService = new HttpServiceImpl_1.HttpServiceImpl();
	    var apiResponseValidator = new ApiResponseValidator_1.ApiResponseValidator();
	    var searchService = new SearchServiceImpl_1.SearchServiceImpl(config, httpService, apiResponseValidator);
	    var questionSubmissionService = new QuestionSubmissionServiceImpl_1.QuestionSubmissionServiceImpl(config, httpService, apiResponseValidator);
	    var autoCompleteService = new AutocompleteServiceImpl_1.AutocompleteServiceImpl(config, httpService, apiResponseValidator);
	    return new AnswersCore_1.AnswersCore(searchService, questionSubmissionService, autoCompleteService);
	  }

	  exports.provideCore = provideCore;

	  __exportStar(models, exports);
	});
	unwrapExports(commonjs);
	var commonjs_1 = commonjs.AnswersCore;
	var commonjs_2 = commonjs.provideCore;

	/** @module SearchStates */

	/**
	 * @typedef {string} SearchState
	 */

	/**
	 * SearchStates is an ENUM for the various stages of searching,
	 * used to show different templates
	 * @enum {string}
	 */
	var SearchStates = {
	  PRE_SEARCH: 'pre-search',
	  SEARCH_LOADING: 'search-loading',
	  SEARCH_COMPLETE: 'search-complete'
	};

	var concat = entryVirtual('Array').concat;

	var ArrayPrototype$a = Array.prototype;

	var concat_1 = function (it) {
	  var own = it.concat;
	  return it === ArrayPrototype$a || (it instanceof Array && own === ArrayPrototype$a.concat) ? concat : own;
	};

	var concat$1 = concat_1;

	var concat$2 = concat$1;

	var onFreeze = internalMetadata.onFreeze;

	var nativeFreeze = Object.freeze;
	var FAILS_ON_PRIMITIVES$4 = fails(function () { nativeFreeze(1); });

	// `Object.freeze` method
	// https://tc39.es/ecma262/#sec-object.freeze
	_export({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES$4, sham: !freezing }, {
	  freeze: function freeze(it) {
	    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
	  }
	});

	var freeze = path.Object.freeze;

	var freeze$1 = freeze;

	var freeze$2 = freeze$1;

	/** @module Errors */

	/**
	 * AnswersBaseError is an extension of the base Error object.
	 * This is the object that is used to when reporting to the server.
	 * @extends Error
	 *
	 * Error codes fall into one of four categories:
	 * 1XX errors: Basic errors
	 * 2XX errors: UI errors
	 * 3XX errors: Endpoint errors
	 * 4XX errors: Core errors
	 */
	var AnswersBaseError = /*#__PURE__*/function (_Error) {
	  _inheritsLoose(AnswersBaseError, _Error);

	  function AnswersBaseError(errorCode, message, boundary, causedBy) {
	    var _this;

	    if (boundary === void 0) {
	      boundary = 'unknown';
	    }

	    if (causedBy === void 0) {
	      causedBy = undefined;
	    }

	    _this = _Error.call(this, message) || this;
	    _this.errorCode = errorCode;
	    _this.errorMessage = message;
	    _this.boundary = boundary;
	    _this.reported = false;

	    if (causedBy) {
	      _this.causedBy = causedBy instanceof AnswersBaseError ? causedBy : AnswersBaseError.from(causedBy);
	      _this.stack = _this.stack + "\nCaused By: " + _this.causedBy.stack;
	    }

	    return _this;
	  }

	  var _proto = AnswersBaseError.prototype;

	  _proto.toJson = function toJson() {
	    return stringify$2(this);
	  };

	  _proto.toString = function toString() {
	    var string = this.errorMessage + " (" + this.boundary + ")";

	    if (this.causedBy) {
	      string += "\n  Caused By: " + this.causedBy.toString();
	    }

	    return string;
	  };

	  AnswersBaseError.from = function from(builtinError, boundary) {
	    var error = new AnswersBasicError(builtinError.message, boundary);
	    error.stack = builtinError.stack;
	    return error;
	  };

	  return AnswersBaseError;
	}( /*#__PURE__*/_wrapNativeSuper(Error));
	/**
	 * AnswersBasicError is a wrapper around all the built-in errors
	 * e.g. undefined variables, incorrect syntax, types, missing methods, etc.
	 * @extends AnswersBaseError
	 */

	var AnswersBasicError = /*#__PURE__*/function (_AnswersBaseError) {
	  _inheritsLoose(AnswersBasicError, _AnswersBaseError);

	  function AnswersBasicError(message, boundary, causedBy) {
	    return _AnswersBaseError.call(this, 100, message, boundary, causedBy) || this;
	  }

	  return AnswersBasicError;
	}(AnswersBaseError);
	/**
	 * AnswersUiError used for things like DOM errors.
	 * @extends AnswersBaseError
	 */

	var AnswersConfigError = /*#__PURE__*/function (_AnswersBaseError2) {
	  _inheritsLoose(AnswersConfigError, _AnswersBaseError2);

	  function AnswersConfigError(message, boundary, causedBy) {
	    return _AnswersBaseError2.call(this, 101, message, boundary, causedBy) || this;
	  }

	  return AnswersConfigError;
	}(AnswersBaseError);
	/**
	 * AnswersComponentError is used for Component oriented errors
	 * e.g. failure to render, or catching unknowns.
	 * @extends AnswersBaseError
	 */

	var AnswersComponentError = /*#__PURE__*/function (_AnswersBaseError4) {
	  _inheritsLoose(AnswersComponentError, _AnswersBaseError4);

	  function AnswersComponentError(message, component, causedBy) {
	    return _AnswersBaseError4.call(this, 201, message, component, causedBy) || this;
	  }

	  return AnswersComponentError;
	}(AnswersBaseError);
	/**
	 * AnswersCoreError represents errors for precondition failures in the core library
	 * @extends AnswersBaseError
	 */

	var AnswersCoreError = /*#__PURE__*/function (_AnswersBaseError6) {
	  _inheritsLoose(AnswersCoreError, _AnswersBaseError6);

	  function AnswersCoreError(message, boundary, causedBy) {
	    return _AnswersBaseError6.call(this, 400, message, boundary, causedBy) || this;
	  }

	  return AnswersCoreError;
	}(AnswersBaseError);
	/**
	 * AnswersStorageError represents storage related errors
	 * @extends AnswersBaseError
	 */

	var AnswersStorageError = /*#__PURE__*/function (_AnswersBaseError7) {
	  _inheritsLoose(AnswersStorageError, _AnswersBaseError7);

	  function AnswersStorageError(message, storageKey, data, causedBy) {
	    var _this2;

	    _this2 = _AnswersBaseError7.call(this, 401, message, 'Storage', causedBy) || this;
	    _this2.storageKey = storageKey;
	    _this2.data = data;
	    return _this2;
	  }

	  return AnswersStorageError;
	}(AnswersBaseError);
	/**
	 * AnswersAnalyticsError is used for errors when reporting analytics
	 * @extends AnswersBaseError
	 */

	var AnswersAnalyticsError = /*#__PURE__*/function (_AnswersBaseError8) {
	  _inheritsLoose(AnswersAnalyticsError, _AnswersBaseError8);

	  function AnswersAnalyticsError(message, event, causedBy) {
	    var _this3;

	    _this3 = _AnswersBaseError8.call(this, 402, message, 'Analytics', causedBy) || this;
	    _this3.event = event;
	    return _this3;
	  }

	  return AnswersAnalyticsError;
	}(AnswersBaseError);

	/** @module Section */

	var Section = /*#__PURE__*/function () {
	  function Section(data, url, resultsContext) {
	    if (data === void 0) {
	      data = {};
	    }

	    if (url === void 0) {
	      url = null;
	    }

	    if (resultsContext === void 0) {
	      resultsContext = undefined;
	    }

	    this.searchState = SearchStates.SEARCH_COMPLETE;
	    this.verticalConfigId = data.verticalConfigId || null;
	    this.resultsCount = data.resultsCount || 0;
	    this.encodedState = data.encodedState || '';
	    this.appliedQueryFilters = data.appliedQueryFilters;
	    this.facets = data.facets || null;
	    this.results = data.results;
	    this.map = Section.parseMap(data.results);
	    this.verticalURL = url || null;
	    this.resultsContext = resultsContext;
	  }

	  Section.parseMap = function parseMap(results) {
	    if (!results) {
	      return {};
	    }

	    var mapMarkers = [];
	    var centerCoordinates = {};

	    for (var j = 0; j < results.length; j++) {
	      var result = results[j]._raw;

	      if (result && result.yextDisplayCoordinate) {
	        if (!centerCoordinates.latitude) {
	          centerCoordinates = {
	            latitude: result.yextDisplayCoordinate.latitude,
	            longitude: result.yextDisplayCoordinate.longitude
	          };
	        }

	        mapMarkers.push({
	          item: result,
	          label: mapMarkers.length + 1,
	          latitude: result.yextDisplayCoordinate.latitude,
	          longitude: result.yextDisplayCoordinate.longitude
	        });
	      }
	    }

	    return {
	      mapCenter: centerCoordinates,
	      mapMarkers: mapMarkers
	    };
	  };

	  return Section;
	}();

	var $every = arrayIteration.every;


	var STRICT_METHOD$3 = arrayMethodIsStrict('every');

	// `Array.prototype.every` method
	// https://tc39.es/ecma262/#sec-array.prototype.every
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$3 }, {
	  every: function every(callbackfn /* , thisArg */) {
	    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var every = entryVirtual('Array').every;

	var ArrayPrototype$b = Array.prototype;

	var every_1 = function (it) {
	  var own = it.every;
	  return it === ArrayPrototype$b || (it instanceof Array && own === ArrayPrototype$b.every) ? every : own;
	};

	var every$1 = every_1;

	var every$2 = every$1;

	// `Set` constructor
	// https://tc39.es/ecma262/#sec-set-objects
	var es_set = collection('Set', function (init) {
	  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
	}, collectionStrong);

	var set$2 = path.Set;

	var set$3 = set$2;

	var set$4 = set$3;

	/** @module FilterCombinators */

	/**
	 * FilterCombinators are enums for valid ways to combine {@link Filter}s.
	 */
	var FilterCombinators = {
	  AND: '$and',
	  OR: '$or'
	};

	/**
	 * A Matcher is a filtering operation for {@link Filter}s.
	 */
	var Matcher = {
	  Equals: '$eq',
	  NotEquals: '!$eq',
	  LessThan: '$lt',
	  LessThanOrEqualTo: '$le',
	  GreaterThan: '$gt',
	  GreaterThanOrEqualTo: '$ge',
	  Near: '$near'
	};

	var RANGE_MATCHERS = new set$4([Matcher.GreaterThan, Matcher.GreaterThanOrEqualTo, Matcher.LessThanOrEqualTo, Matcher.LessThan]);
	/**
	 * Represents an api filter and provides static methods for easily constructing Filters.
	 * See https://developer.yext.com/docs/api-reference/#operation/listEntities for structure details
	 */

	var Filter = /*#__PURE__*/function () {
	  function Filter(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    _extends(this, data);

	    freeze$2(this);
	  }
	  /**
	   * A filter should have exactly ONE key. That key is EITHER the field name to filter by, or
	   * a special string such as $or or $and.
	   * @type {string}
	   */


	  var _proto = Filter.prototype;

	  _proto.getFilterKey = function getFilterKey() {
	    if (keys$3(this).length > 0) {
	      return keys$3(this)[0];
	    }
	  }
	  /**
	   * Whether this filter is a range filter.
	   *
	   * @returns {boolean}
	   */
	  ;

	  _proto.isRangeFilter = function isRangeFilter() {
	    var filterKey = this.getFilterKey();

	    if (!filterKey) {
	      return false;
	    }

	    var matchers = keys$3(this[filterKey]);

	    return every$2(matchers).call(matchers, function (m) {
	      return RANGE_MATCHERS.has(m);
	    });
	  }
	  /**
	   * Create an empty filter
	   */
	  ;

	  Filter.empty = function empty() {
	    return new Filter();
	  }
	  /**
	   * Wrap filter data in a Filter class
	   * @param {Object} filter
	   */
	  ;

	  Filter.from = function from(filter) {
	    return new Filter(filter);
	  }
	  /**
	   * Constructs an SDK Filter model from an answers-core SimpleFilter model
	   *
	   * @param {SimpleFilter} filter from answers-core
	   * @returns {Filter}
	   */
	  ;

	  Filter.fromCoreSimpleFilter = function fromCoreSimpleFilter(filter) {
	    var _filter$fieldId, _Filter;

	    if (!filter) {
	      return this.empty();
	    }

	    return new Filter((_Filter = {}, _Filter[filter.fieldId] = (_filter$fieldId = {}, _filter$fieldId[filter.matcher] = filter.value, _filter$fieldId), _Filter));
	  }
	  /**
	   * Parse a JSON format filter returned from the server into a Filter
	   * @param {*} responseFilter A filter in JSON format returned from the backend
	   * @returns {Filter}
	   */
	  ;

	  Filter.fromResponse = function fromResponse(responseFilter) {
	    return new Filter(JSON.parse(responseFilter));
	  }
	  /**
	   * Return a new Filter representing the OR of all provided filters
	   * @param  {...Filter} filters The filters to OR together
	   * @returns {Filter}
	   */
	  ;

	  Filter.or = function or() {
	    var _Filter2;

	    for (var _len = arguments.length, filters = new Array(_len), _key = 0; _key < _len; _key++) {
	      filters[_key] = arguments[_key];
	    }

	    return new Filter((_Filter2 = {}, _Filter2[FilterCombinators.OR] = filters, _Filter2));
	  }
	  /**
	   * Return a new Filter representing the AND of all provided filters
	   * @param  {...Filter} filters The filters to AND together
	   * @returns {Filter}
	   */
	  ;

	  Filter.and = function and() {
	    var _Filter3;

	    for (var _len2 = arguments.length, filters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      filters[_key2] = arguments[_key2];
	    }

	    return new Filter((_Filter3 = {}, _Filter3[FilterCombinators.AND] = filters, _Filter3));
	  }
	  /**
	   * Helper method for creating a range filter
	   * @param {string} field field id of the filter
	   * @param {number|string} min minimum value
	   * @param {number|string} max maximum value
	   * @param {boolean} isExclusive whether this is an inclusive or exclusive range
	   * @returns {Filter}
	   */
	  ;

	  Filter.range = function range(field, min, max, isExclusive) {
	    var falsyMin = min === null || min === undefined || min === '';
	    var falsyMax = max === null || max === undefined || max === '';

	    if (falsyMin && falsyMax) {
	      return Filter.empty();
	    } else if (falsyMax) {
	      return isExclusive ? Filter.greaterThan(field, min) : Filter.greaterThanEqual(field, min);
	    } else if (falsyMin) {
	      return isExclusive ? Filter.lessThan(field, max) : Filter.lessThanEqual(field, max);
	    } else if (min === max) {
	      return isExclusive ? Filter.empty() : Filter.equal(field, min);
	    }

	    return isExclusive ? Filter.exclusiveRange(field, min, max) : Filter.inclusiveRange(field, min, max);
	  }
	  /**
	   * Create a new "equal to" filter for a field
	   * @param {string} field The subject field of the filter
	   * @param {*} value The value the field should be equal to
	   * @returns {Filter}
	   */
	  ;

	  Filter.equal = function equal(field, value) {
	    return Filter._fromMatcher(field, Matcher.Equals, value);
	  }
	  /**
	   * Create a new "less than" filter for a field
	   * @param {string} field The subject field of the filter
	   * @param {*} value The value the field should be less than
	   * @returns {Filter}
	   */
	  ;

	  Filter.lessThan = function lessThan(field, value) {
	    return Filter._fromMatcher(field, Matcher.LessThan, value);
	  }
	  /**
	   * Create a new "less than or equal to" filter for a field
	   * @param {string} field The subject field of the filter
	   * @param {*} value The value the field should be less than or equal to
	   * @returns {Filter}
	   */
	  ;

	  Filter.lessThanEqual = function lessThanEqual(field, value) {
	    return Filter._fromMatcher(field, Matcher.LessThanOrEqualTo, value);
	  }
	  /**
	   * Create a new "greater than" filter for a field
	   * @param {string} field The subject field of the filter
	   * @param {*} value The value the field should be greater than
	   * @returns {Filter}
	   */
	  ;

	  Filter.greaterThan = function greaterThan(field, value) {
	    return Filter._fromMatcher(field, Matcher.GreaterThan, value);
	  }
	  /**
	   * Create a new "greater than or equal to" filter for a field
	   * @param {string} field The subject field of the filter
	   * @param {*} value The value the field should be greater than or equal to
	   * @returns {Filter}
	   */
	  ;

	  Filter.greaterThanEqual = function greaterThanEqual(field, value) {
	    return Filter._fromMatcher(field, Matcher.GreaterThanOrEqualTo, value);
	  }
	  /**
	   * Create a new inclusive range filter
	   * @param {string} field The subject field of the filter
	   * @param {*} min The minimum value
	   * @param {*} max The maximum value
	   * @returns {Filter}
	   */
	  ;

	  Filter.inclusiveRange = function inclusiveRange(field, min, max) {
	    var _field, _Filter4;

	    return new Filter((_Filter4 = {}, _Filter4[field] = (_field = {}, _field[Matcher.GreaterThanOrEqualTo] = min, _field[Matcher.LessThanOrEqualTo] = max, _field), _Filter4));
	  }
	  /**
	   * Create a new exclusive range filter
	   * @param {string} field The subject field of the filter
	   * @param {*} min The minimum value
	   * @param {*} max The maximum value
	   * @returns {Filter}
	   */
	  ;

	  Filter.exclusiveRange = function exclusiveRange(field, min, max) {
	    var _field2, _Filter5;

	    return new Filter((_Filter5 = {}, _Filter5[field] = (_field2 = {}, _field2[Matcher.GreaterThan] = min, _field2[Matcher.LessThan] = max, _field2), _Filter5));
	  }
	  /**
	   * Create a new position filter
	   * @param {number} lat The latitude of the position
	   * @param {number} lng The longitude of the position
	   * @param {number} radius The search radius (in meters)
	   */
	  ;

	  Filter.position = function position(lat, lng, radius) {
	    return Filter._fromMatcher('builtin.location', Matcher.Near, {
	      lat: lat,
	      lng: lng,
	      radius: radius
	    });
	  }
	  /**
	   * Create a new filter with the given matcher
	   * @private
	   * @param {string} field The subject field of the filter
	   * @param {string} matcher The matcher for the filer
	   * @param {*} value The value for the filter
	   * @returns {Filter}
	   */
	  ;

	  Filter._fromMatcher = function _fromMatcher(field, matcher, value) {
	    var _field3, _Filter6;

	    return new Filter((_Filter6 = {}, _Filter6[field] = (_field3 = {}, _field3[matcher] = value, _field3), _Filter6));
	  };

	  return Filter;
	}();

	/**
	 * A model that represents a filter that the backend applied to a search
	 */

	var AppliedQueryFilter = /*#__PURE__*/function () {
	  function AppliedQueryFilter(appliedQueryFilter) {
	    if (appliedQueryFilter === void 0) {
	      appliedQueryFilter = {};
	    }

	    this.key = appliedQueryFilter.key;
	    this.value = appliedQueryFilter.value;
	    this.filter = filter$2(appliedQueryFilter);
	    this.fieldId = appliedQueryFilter.fieldId;
	  }
	  /**
	   * Constructs an SDK AppliedQueryFilter from an answers-core AppliedQueryFilter
	   *
	   * @param {AppliedQueryFilter} appliedFilter from answers-core
	   * @returns {@link AppliedQueryFilter}
	   */


	  AppliedQueryFilter.fromCore = function fromCore(appliedFilter) {
	    if (!appliedFilter) {
	      return new AppliedQueryFilter();
	    }

	    return new AppliedQueryFilter({
	      key: appliedFilter.displayKey,
	      value: appliedFilter.displayValue,
	      filter: Filter.fromCoreSimpleFilter(filter$2(appliedFilter)),
	      fieldId: filter$2(appliedFilter).fieldId
	    });
	  };

	  return AppliedQueryFilter;
	}();

	var propertyIsEnumerable = objectPropertyIsEnumerable.f;

	// `Object.{ entries, values }` methods implementation
	var createMethod$5 = function (TO_ENTRIES) {
	  return function (it) {
	    var O = toIndexedObject(it);
	    var keys = objectKeys(O);
	    var length = keys.length;
	    var i = 0;
	    var result = [];
	    var key;
	    while (length > i) {
	      key = keys[i++];
	      if (!descriptors || propertyIsEnumerable.call(O, key)) {
	        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
	      }
	    }
	    return result;
	  };
	};

	var objectToArray = {
	  // `Object.entries` method
	  // https://tc39.es/ecma262/#sec-object.entries
	  entries: createMethod$5(true),
	  // `Object.values` method
	  // https://tc39.es/ecma262/#sec-object.values
	  values: createMethod$5(false)
	};

	var $entries = objectToArray.entries;

	// `Object.entries` method
	// https://tc39.es/ecma262/#sec-object.entries
	_export({ target: 'Object', stat: true }, {
	  entries: function entries(O) {
	    return $entries(O);
	  }
	});

	var entries$3 = path.Object.entries;

	var entries$4 = entries$3;

	var entries$5 = entries$4;

	var test$1 = [];
	var nativeSort = test$1.sort;

	// IE8-
	var FAILS_ON_UNDEFINED = fails(function () {
	  test$1.sort(undefined);
	});
	// V8 bug
	var FAILS_ON_NULL = fails(function () {
	  test$1.sort(null);
	});
	// Old WebKit
	var STRICT_METHOD$4 = arrayMethodIsStrict('sort');

	var FORCED$6 = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD$4;

	// `Array.prototype.sort` method
	// https://tc39.es/ecma262/#sec-array.prototype.sort
	_export({ target: 'Array', proto: true, forced: FORCED$6 }, {
	  sort: function sort(comparefn) {
	    return comparefn === undefined
	      ? nativeSort.call(toObject(this))
	      : nativeSort.call(toObject(this), aFunction(comparefn));
	  }
	});

	var sort = entryVirtual('Array').sort;

	var ArrayPrototype$c = Array.prototype;

	var sort_1 = function (it) {
	  var own = it.sort;
	  return it === ArrayPrototype$c || (it instanceof Array && own === ArrayPrototype$c.sort) ? sort : own;
	};

	var sort$1 = sort_1;

	var sort$2 = sort$1;

	/** @module HighlightedValue */

	/**
	 * Model representing a highlighted value.
	 */
	var HighlightedValue = /*#__PURE__*/function () {
	  function HighlightedValue(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    this.value = data.value || data.shortValue || '';
	    this.matchedSubstrings = data.matchedSubstrings || [];
	  }
	  /**
	   * get highlighted value string
	   * @returns {string}
	   */


	  var _proto = HighlightedValue.prototype;

	  _proto.get = function get() {
	    this._sortMatchedSubstrings();

	    return this.buildHighlightedValue(this.value, this.matchedSubstrings);
	  }
	  /**
	   * get highlighted value string
	   * @param {Function} transformFunction takes a string and returns the transformed string
	   * @returns {string} The value interpolated with highlighting markup and transformed in between
	   */
	  ;

	  _proto.getWithTransformFunction = function getWithTransformFunction(transformFunction) {
	    this._sortMatchedSubstrings();

	    return this.buildHighlightedValue(this.value, this.matchedSubstrings, transformFunction);
	  }
	  /**
	   * get inverted highlighted value string
	   * @returns {string}
	   */
	  ;

	  _proto.getInverted = function getInverted() {
	    this._sortMatchedSubstrings();

	    var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

	    return this.buildHighlightedValue(this.value, invertedSubstrings);
	  }
	  /**
	   * get inverted highlighted value string
	   * @param {Function} transformFunction takes a string and returns the transformed string
	   * @returns {string} The value interpolated with highlighting markup and transformed in between
	   */
	  ;

	  _proto.getInvertedWithTransformFunction = function getInvertedWithTransformFunction(transformFunction) {
	    this._sortMatchedSubstrings();

	    var invertedSubstrings = this._getInvertedSubstrings(this.matchedSubstrings, this.value.length);

	    return this.buildHighlightedValue(this.value, invertedSubstrings, transformFunction);
	  }
	  /**
	   * introduces highlighting to input data according to highlighting specifiers
	   *
	   * @param {Object} val input object to apply highlighting to
	   *
	   *  example object :
	   *  {
	   *    name: 'ATM',
	   *    featuredMessage: {
	   *      description: 'Save time & bank on your terms at over 1,800 ATMs'
	   *    }
	   *  }
	   *
	   * @param {Object} highlightedSubstrings highlighting specifiers to apply to input object
	   *
	   *  example object :
	   *  {
	   *    name: {
	   *      matchedSubstrings: [{
	   *        length: 3,
	   *        offset: 0
	   *      }],
	   *      value: 'ATM'
	   *    },
	   *    featuredMessage: {
	   *      description: {
	   *        matchedSubstrings: [{
	   *          length: 4,
	   *          offset: 45
	   *        }],
	   *        value: 'Save time & bank on your terms at over 1,800 ATMs'
	   *      }
	   *    }
	   *  }
	   *
	   * @param {Function} transformFunction function to apply to strings in between highlighting markup
	   *
	   *  example function :
	   *  function (string) {
	   *    return handlebars.escapeExpression(string);
	   *  }
	   *
	   * @returns {string} copy of input value with highlighting applied
	   *
	   *  example object :
	   *  {
	   *    name: '<strong>ATM</strong>',
	   *    featuredMessage: {
	   *      description: 'Save time & bank on your terms at over 1,800 <strong>ATMs</strong>'
	   *    }
	   *  }
	   *
	   */
	  ;

	  _proto.buildHighlightedValue = function buildHighlightedValue(val, highlightedSubstrings, transformFunction) {
	    if (transformFunction === void 0) {
	      transformFunction = function transformFunction(x) {
	        return x;
	      };
	    }

	    var highlightedValue = '';
	    var nextStart = 0;

	    if (highlightedSubstrings.length === 0) {
	      return transformFunction(val);
	    }

	    for (var j = 0; j < highlightedSubstrings.length; j++) {
	      var start = Number(highlightedSubstrings[j].offset);
	      var end = start + highlightedSubstrings[j].length;
	      highlightedValue += [transformFunction(slice$4(val).call(val, nextStart, start)), '<strong>', transformFunction(slice$4(val).call(val, start, end)), '</strong>'].join('');

	      if (j === highlightedSubstrings.length - 1 && end < val.length) {
	        highlightedValue += transformFunction(slice$4(val).call(val, end));
	      }

	      nextStart = end;
	    }

	    return highlightedValue;
	  };

	  _proto._sortMatchedSubstrings = function _sortMatchedSubstrings() {
	    var _context;

	    sort$2(_context = this.matchedSubstrings).call(_context, function (a, b) {
	      if (a.offset < b.offset) {
	        return -1;
	      }

	      if (a.offset > b.offset) {
	        return 1;
	      }

	      return 0;
	    });
	  };

	  _proto._getInvertedSubstrings = function _getInvertedSubstrings(matchedSubstrings, valueLength) {
	    var invertedSubstrings = [];

	    for (var i = 0; i < matchedSubstrings.length; i++) {
	      var substring = matchedSubstrings[i];
	      var nextOffset = substring.offset + substring.length;

	      if (i === 0 && substring.offset !== 0) {
	        invertedSubstrings.push({
	          offset: 0,
	          length: substring.offset
	        });
	      }

	      if (valueLength > nextOffset) {
	        invertedSubstrings.push({
	          offset: nextOffset,
	          length: i < matchedSubstrings.length - 1 ? matchedSubstrings[i + 1].offset - nextOffset : valueLength - nextOffset
	        });
	      }
	    }

	    return invertedSubstrings;
	  };

	  return HighlightedValue;
	}();

	/**
	 * Represents highlighted fields with the highlighting applied
	 */

	var AppliedHighlightedFields = /*#__PURE__*/function () {
	  /**
	   * Constructs a highlighted field map which consists of mappings from fields to highlighted
	   * value strings.
	   *
	   * @param {Object<string, string|object|array>} data Keyed by fieldName. It may consist of nested fields
	   *
	   * Example object:
	   *
	   * {
	   *   description: 'likes <strong>apple</strong> pie and green <strong>apple</strong>s',
	   *   c_favoriteFruits: [
	   *     {
	   *       apples: ['Granny Smith','Upton Pyne <strong>Apple</strong>'],
	   *       pears: ['Callery Pear']
	   *     }
	   *   ]
	   * }
	   */
	  function AppliedHighlightedFields(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    _extends(this, data);
	  }
	  /**
	   * Constructs an AppliedHighlightedFields object from an answers-core HighlightedField
	   *
	   * @param {import('@yext/answers-core').HighlightedFields} highlightedFields
	   * @returns {AppliedHighlightedFields}
	   */


	  AppliedHighlightedFields.fromCore = function fromCore(highlightedFields) {
	    if (!highlightedFields || typeof highlightedFields !== 'object') {
	      return {};
	    }

	    var appliedHighlightedFields = this.computeHighlightedDataRecursively(highlightedFields);
	    return new AppliedHighlightedFields(appliedHighlightedFields);
	  }
	  /**
	   * Given an answers-core HighlightedFields tree, returns a new tree
	   * with highlighting applied to the leaf nodes.
	   *
	   * @param {import('@yext/answers-core').HighlightedFields} highlightedFields
	   * @returns {AppliedHighlightedFields}
	   */
	  ;

	  AppliedHighlightedFields.computeHighlightedDataRecursively = function computeHighlightedDataRecursively(highlightedFields) {
	    var _this = this,
	        _context;

	    if (this.isHighlightedFieldLeafNode(highlightedFields)) {
	      var value = highlightedFields.value,
	          matchedSubstrings = highlightedFields.matchedSubstrings;
	      return new HighlightedValue().buildHighlightedValue(value, matchedSubstrings);
	    }

	    if (isArray$3(highlightedFields)) {
	      return map$2(highlightedFields).call(highlightedFields, function (childFields) {
	        return _this.computeHighlightedDataRecursively(childFields);
	      });
	    }

	    return reduce$2(_context = entries$5(highlightedFields)).call(_context, function (computedFields, _ref) {
	      var fieldName = _ref[0],
	          childFields = _ref[1];
	      computedFields[fieldName] = _this.computeHighlightedDataRecursively(childFields);
	      return computedFields;
	    }, {});
	  };

	  AppliedHighlightedFields.isHighlightedFieldLeafNode = function isHighlightedFieldLeafNode(_ref2) {
	    var matchedSubstrings = _ref2.matchedSubstrings,
	        value = _ref2.value;
	    return matchedSubstrings !== undefined && value !== undefined;
	  };

	  return AppliedHighlightedFields;
	}();

	/**
	 * Represents highlighted fields without the highlighting applied
	*/
	var HighlightedFields =
	/**
	 * Constructs a highlighted fields object which consists of fields mapping to HighlightedValues
	 *
	 * @param {import('@yext/answers-core').HighlightedFields} highlightedFields
	 *
	 * Example object:
	 *
	 * {
	 *   description: {
	 *     value: 'likes apple pie and green apples',
	 *     matchedSubstrings: [
	 *       { offset: 6, length: 5 },
	 *       { offset: 26, length: 5 }
	 *     ]
	 *   },
	 *   c_favoriteFruits: [
	 *     {
	 *       apples: [
	 *         {
	 *           value: 'Granny Smith',
	 *           matchedSubstrings: []
	 *         },
	 *         {
	 *           value: 'Upton Pyne Apple',
	 *           matchedSubstrings: [{ offset: 11, length: 5}]
	 *         }
	 *       ],
	 *       pears: [
	 *         {
	 *           value: 'Callery Pear',
	 *           matchedSubstrings: []
	 *         }
	 *       ]
	 *     }
	 *   ]
	 * }
	 */
	function HighlightedFields(highlightedFields) {
	  if (highlightedFields === void 0) {
	    highlightedFields = {};
	  }

	  _extends(this, highlightedFields);
	};

	/**
	   * Truncates strings to 250 characters, attempting to preserve whole words
	   * @param str {string} the string to truncate
	   * @param limit {Number} the maximum character length to return
	   * @param trailing {string} a trailing string to denote truncation, e.g. '...'
	   * @param sep {string} the word separator
	   * @returns {string}
	   */
	function truncate(str, limit, trailing, sep) {
	  if (limit === void 0) {
	    limit = 250;
	  }

	  if (trailing === void 0) {
	    trailing = '...';
	  }

	  if (sep === void 0) {
	    sep = ' ';
	  }

	  if (!str || str.length <= limit) {
	    return str;
	  } // TODO (bmcginnis): split punctuation too so we don't end up with "foo,..."


	  var words = str.split(sep);
	  var max = limit - trailing.length;
	  var truncated = '';

	  for (var i = 0; i < words.length; i++) {
	    var word = words[i];

	    if (truncated.length + word.length > max || i !== 0 && truncated.length + word.length + sep.length > max) {
	      truncated += trailing;
	      break;
	    }

	    truncated += i === 0 ? word : sep + word;
	  }

	  return truncated;
	}

	var Result$1 = /*#__PURE__*/function () {
	  function Result(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    /**
	     * The raw profile data
	     * @type {Object}
	     * @private
	     */
	    this._raw = data.raw || null;
	    /**
	     * The formatted profile data
	     * @type {Object}
	     * @private
	     */

	    this._formatted = data.formatted;
	    /**
	     * The highlighted profile data with highlights applied to applicable fields
	     * @type {Object}
	     * @private
	     */

	    this._highlighted = data.highlighted;
	    /**
	     * An object that lists the substrings to highlight for each applicable field.
	     * @type {Object}
	     */

	    this.highlightedFields = data.highlightedFields;
	    /**
	     * The index number of the result
	     * @type {Number}
	     */

	    this.ordinal = data.ordinal || null;
	    /**
	     * The title of the result card
	     * @type {string|null}
	     */

	    this.title = data.title || null;
	    /**
	     * The body of the details section of the result card, can contain HTML
	     * @type {string| null}
	     */

	    this.details = data.details || null;
	    /**
	     * The destination link for the title of the result card
	     * @type {string|null}
	     */

	    this.link = data.link || null;
	    /**
	     * The Entity ID, or other unique identifier, used for to power interactivity
	     * @type {string|null}
	     */

	    this.id = data.id || null;
	    /**
	     * The subtitle on the result card
	     * @type {string|null}
	     */

	    this.subtitle = data.subtitle || null;
	    /**
	     * The class modifier, usually derived from the vertical configuration ID
	     * Used to apply different styling to different result card types
	     * @type {string|null}
	     */

	    this.modifier = data.modifier || null;
	    /**
	     * A large date, of the format { month: 'Jan', day: '01' }
	     * @type {Object|null}
	     */

	    this.bigDate = data.bigDate || null;
	    /**
	     * An image profile object, expected to have a url property
	     * @type {Object|null}
	     */

	    this.image = data.image || null;
	    /**
	     * An array of calls to action, of the format:
	     * { icon: '', url: '', text: '', eventType: '', eventOptions: {}}
	     * @type {Array}
	     */

	    this.callsToAction = data.callsToAction || [];
	    /**
	     * Determines if an accordian result should be collapsed by default
	     * @type {boolean}
	     */

	    this.collapsed = data.collapsed === undefined ? true : data.collapsed;
	    /**
	     * @type {number}
	     */

	    this.distance = data.distance || null;
	    /**
	     * @type {number}
	     */

	    this.distanceFromFilter = data.distanceFromFilter || null;
	  }
	  /**
	   * Constructs an SDK Result from an answers-core Result
	   *
	   * @param {Result} result from answers-core
	   * @param {Object<string, function>} formatters applied to the result fields
	   * @param {string} verticalKey the verticalKey associated with the result
	   * @returns {@link Result}
	   */


	  Result.fromCore = function fromCore(result, formatters, verticalKey) {
	    var highlightedFields = new HighlightedFields(result.highlightedFields);
	    var appliedHighlightedFields = AppliedHighlightedFields.fromCore(result.highlightedFields);
	    var details = appliedHighlightedFields.description || result.description;
	    var truncatedDetails = truncate(details);
	    var resultData = {
	      raw: result.rawData,
	      ordinal: result.index,
	      title: result.name,
	      details: truncatedDetails,
	      link: result.link,
	      id: result.id,
	      distance: result.distance,
	      distanceFromFilter: result.distanceFromFilter,
	      highlighted: appliedHighlightedFields,
	      highlightedFields: highlightedFields
	    };

	    if (result.source !== 'KNOWLEDGE_MANAGER') {
	      return new Result(resultData);
	    }

	    var formattedData = this._getFormattedData(resultData, formatters, verticalKey);

	    resultData.formatted = formattedData;

	    if (formattedData.description !== undefined) {
	      resultData.details = formattedData.description;
	    }

	    return new Result(resultData);
	  }
	  /**
	   * Returns an object which contains formatted fields
	   *
	   * @param {Object} resultData the same shape as the input to the Result constructor
	   * @param {Object<string, function>} formatters to apply to the result fields
	   * @param {string} verticalKey the verticalKey associated with the result
	   * @returns {Object<string, string>} keys are field names and values are the formatted data
	   */
	  ;

	  Result._getFormattedData = function _getFormattedData(resultData, formatters, verticalKey) {
	    var _context;

	    var formattedData = {};

	    if (!formatters || !resultData.raw) {
	      return formattedData;
	    }

	    if (keys$3(formatters).length === 0) {
	      return formattedData;
	    }

	    forEach$2(_context = entries$5(resultData.raw)).call(_context, function (_ref) {
	      var fieldName = _ref[0],
	          fieldVal = _ref[1];

	      // check if a field formatter exists for the current entity profile field
	      if (formatters[fieldName] === undefined) {
	        return;
	      } // verify the field formatter provided is a formatter function as expected


	      if (typeof formatters[fieldName] !== 'function') {
	        throw new AnswersCoreError('Field formatter is not of expected type function', 'Result');
	      } // if highlighted version of field value is available, make it available to field formatter


	      var highlightedFieldVal = null;

	      if (resultData.highlighted && resultData.highlighted[fieldName]) {
	        highlightedFieldVal = resultData.highlighted[fieldName];
	      } // call formatter function associated with the field name
	      // the input object defines the interface that field formatter functions work with


	      formattedData[fieldName] = formatters[fieldName]({
	        entityProfileData: resultData.raw,
	        entityFieldValue: fieldVal,
	        highlightedEntityFieldValue: highlightedFieldVal,
	        verticalId: verticalKey,
	        isDirectAnswer: false
	      });
	    });

	    return formattedData;
	  };

	  return Result;
	}();

	/** @module ResultsContext */

	/**
	 * ResultsContext is an ENUM that provides context
	 * for the results that we are storing from server
	 * data
	 * @enum {string}
	 */
	var ResultsContext = {
	  NORMAL: 'normal',
	  NO_RESULTS: 'no-results'
	};

	function ownKeys$1(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context5; forEach$2(_context5 = ownKeys$1(Object(source), true)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context6; forEach$2(_context6 = ownKeys$1(Object(source))).call(_context6, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var VerticalResults = /*#__PURE__*/function () {
	  function VerticalResults(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    _extends(this, {
	      searchState: SearchStates.SEARCH_COMPLETE
	    }, data);
	    /**
	     * The context of the results, used to provide more information about why
	     * these specific results were returned.
	     * @type {ResultsContext}
	     */


	    this.resultsContext = data.resultsContext;

	    freeze$2(this);
	  }
	  /**
	   * Append the provided results to the current results
	   * @param {VerticalResults} results the results to append to the current results
	   */


	  var _proto = VerticalResults.prototype;

	  _proto.append = function append(results) {
	    var _context, _context2;

	    if (results.resultsContext !== this.resultsContext) {
	      throw new AnswersCoreError('Cannot merge results with different contexts', 'VerticalResults');
	    }

	    var merged = _objectSpread({}, this);

	    merged.resultsContext = this.resultsContext;
	    merged.results = concat$2(_context = this.results).call(_context, results.results);
	    map$2(merged).mapMarkers = concat$2(_context2 = map$2(this).mapMarkers).call(_context2, map$2(results).mapMarkers);
	    return new VerticalResults(merged);
	  }
	  /**
	   * Constructs an SDK Section model from an answers-core VerticalResult
	   *
	   * @param {VerticalResults} verticalResults
	   * @param {Object<string, string>} urls keyed by vertical key
	   * @param {Object<string, function>} formatters applied to the result fields
	   * @param {ResultsContext} resultsContext
	   * @param {string} verticalKeyFromRequest
	   * @returns {@link Section}
	   */
	  ;

	  VerticalResults.fromCore = function fromCore(verticalResults, urls, formatters, resultsContext, verticalKeyFromRequest) {
	    var _context3, _context4;

	    if (urls === void 0) {
	      urls = {};
	    }

	    if (formatters === void 0) {
	      formatters = undefined;
	    }

	    if (resultsContext === void 0) {
	      resultsContext = ResultsContext.NORMAL;
	    }

	    if (verticalKeyFromRequest === void 0) {
	      verticalKeyFromRequest = undefined;
	    }

	    if (!verticalResults) {
	      return new Section();
	    }

	    var verticalKey = verticalResults.verticalKey || verticalKeyFromRequest;
	    return new Section({
	      verticalConfigId: verticalKey,
	      resultsCount: verticalResults.resultsCount,
	      appliedQueryFilters: map$2(_context3 = verticalResults.appliedQueryFilters).call(_context3, AppliedQueryFilter.fromCore),
	      results: map$2(_context4 = verticalResults.results).call(_context4, function (result) {
	        return Result$1.fromCore(result, formatters, verticalKey);
	      })
	    }, urls[verticalKey], resultsContext);
	  }
	  /**
	   * Construct a VerticalResults object representing loading results
	   * @return {VerticalResults}
	   */
	  ;

	  VerticalResults.searchLoading = function searchLoading() {
	    return new VerticalResults({
	      searchState: SearchStates.SEARCH_LOADING
	    });
	  };

	  VerticalResults.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  return VerticalResults;
	}();

	var UniversalResults = /*#__PURE__*/function () {
	  function UniversalResults(data) {
	    this.queryId = data.queryId || null;
	    this.sections = data.sections || [];
	    /**
	     * The current state of the search, used to render different templates before, during,
	     * and after loading
	     * @type {SearchState}
	     */

	    this.searchState = data.searchState || SearchStates.SEARCH_COMPLETE;
	  }
	  /**
	   * Construct a UniversalResults object representing loading results
	   * @return {UniversalResults}
	   */


	  UniversalResults.searchLoading = function searchLoading() {
	    return new UniversalResults({
	      searchState: SearchStates.SEARCH_LOADING
	    });
	  }
	  /**
	   * Constructs an SDK UniversalResults model from an answers-core UniversalSearchResponse
	   *
	   * @param {UniversalSearchResponse} response from answers-core
	   * @param {Object<string, string>} urls keyed by vertical key
	   * @param {Object<string, function>} formatters applied to the result fields
	   * @returns {@link UniversalResults}
	   */
	  ;

	  UniversalResults.fromCore = function fromCore(response, urls, formatters) {
	    var _context;

	    if (!response) {
	      return new UniversalResults();
	    }

	    return new UniversalResults({
	      queryId: response.queryId,
	      sections: map$2(_context = response.verticalResults).call(_context, function (verticalResults) {
	        return VerticalResults.fromCore(verticalResults, urls, formatters);
	      })
	    });
	  };

	  return UniversalResults;
	}();

	/** @module DirectAnswer */
	var DirectAnswer = /*#__PURE__*/function () {
	  function DirectAnswer(directAnswer) {
	    if (directAnswer === void 0) {
	      directAnswer = {};
	    }

	    _extends(this, directAnswer);

	    freeze$2(this);
	  }
	  /**
	   * Constructs an SDK DirectAnswer from an answers-core DirectAnswer and applies formatting
	   *
	   * @param {DirectAnswer} directAnswer from answers-core
	   * @param {Object<string, function>} formatters keyed by fieldApiName. If a formatter matches the fieldApiName
	   * of the direct answer, it will be applied to the direct answer value.
	   * @returns {DirectAnswer}
	   */


	  DirectAnswer.fromCore = function fromCore(directAnswer, formatters) {
	    if (!directAnswer) {
	      return new DirectAnswer();
	    }

	    var relatedResult = directAnswer.relatedResult || {};
	    var directAnswerData = {
	      answer: {
	        snippet: directAnswer.snippet,
	        entityName: directAnswer.entityName,
	        fieldName: directAnswer.fieldName,
	        fieldApiName: directAnswer.fieldApiName,
	        value: directAnswer.value,
	        fieldType: directAnswer.fieldType
	      },
	      relatedItem: {
	        data: {
	          fieldValues: relatedResult.rawData,
	          id: relatedResult.id,
	          type: relatedResult.type,
	          website: relatedResult.link
	        },
	        verticalConfigId: directAnswer.verticalKey
	      },
	      type: directAnswer.type
	    };
	    var directAnswerFieldApiName = directAnswerData.answer.fieldApiName;
	    var formatterExistsForDirectAnswer = formatters && directAnswerFieldApiName in formatters;

	    if (formatterExistsForDirectAnswer) {
	      var formattedValue = this._getFormattedValue(directAnswerData, formatters[directAnswerFieldApiName]);

	      directAnswerData.answer.value = formattedValue || directAnswerData.answer.value;
	    }

	    return new DirectAnswer(directAnswerData);
	  }
	  /**
	   * Applies a formatter to a direct answer value
	   *
	   * @param {Object} data directAnswerData
	   * @param {function} formatter a field formatter to apply to the answer value field
	   * @returns {string|null} the formatted value, or null if the formatter could not be applied
	   */
	  ;

	  DirectAnswer._getFormattedValue = function _getFormattedValue(data, formatter) {
	    if (!data.answer || !data.relatedItem) {
	      return null;
	    }

	    return formatter(data.answer.value, data.relatedItem.data.fieldValues, data.relatedItem.verticalConfigId, true);
	  };

	  return DirectAnswer;
	}();

	/** @module Navigation */
	var Navigation = /*#__PURE__*/function () {
	  function Navigation(tabOrder) {
	    this.tabOrder = tabOrder || [];

	    freeze$2(this);
	  }

	  Navigation.from = function from(modules) {
	    var nav = [];

	    if (!modules || !isArray$3(modules)) {
	      return nav;
	    }

	    for (var i = 0; i < modules.length; i++) {
	      nav.push(modules[i].verticalConfigId);
	    }

	    return new Navigation(nav);
	  }
	  /**
	   * Constructs a Navigation model from an answers-core VerticalResults array
	   *
	   * @param {VerticalResults[]} verticalResults
	   */
	  ;

	  Navigation.fromCore = function fromCore(verticalResults) {
	    var verticalKeys = map$2(verticalResults).call(verticalResults, function (result) {
	      return result.verticalKey;
	    });

	    return new Navigation(verticalKeys);
	  };

	  return Navigation;
	}();

	/** @module SpellCheck */

	/**
	 * SpellCheck is the core state model
	 * to power the SpellCheck component
	 */
	var SpellCheck$1 = /*#__PURE__*/function () {
	  function SpellCheck(data) {
	    /**
	     * The original query
	     * @type {string}
	     */
	    this.query = data.query || null;
	    /**
	     * The corrected query
	     * @type {string}
	     */

	    this.correctedQuery = data.correctedQuery || null;
	    /**
	     * The spell check type
	     * @type {string}
	     */

	    this.type = data.type || null;
	    /**
	     * Should show spell check or not
	     * @type {boolean}
	     */

	    this.shouldShow = this.correctedQuery !== null;
	  }
	  /**
	   * Create a spell check model from the provided data
	   *
	   * @param {Object} response The spell check response
	   */


	  SpellCheck.fromCore = function fromCore(response) {
	    if (!response) {
	      return {};
	    }

	    return new SpellCheck({
	      query: response.originalQuery,
	      correctedQuery: {
	        value: response.correctedQuery
	      },
	      type: response.type
	    });
	  };

	  return SpellCheck;
	}();

	/** @module StorageKeys */

	/**
	 * StorageKeys is an ENUM are considered the root context
	 * for how data is stored and scoped in the storage.
	 *
	 * @enum {string}
	 */
	var StorageKeys = {
	  NAVIGATION: 'navigation',
	  UNIVERSAL_RESULTS: 'universal-results',
	  VERTICAL_RESULTS: 'vertical-results',
	  ALTERNATIVE_VERTICALS: 'alternative-verticals',
	  AUTOCOMPLETE: 'autocomplete',
	  DIRECT_ANSWER: 'direct-answer',
	  FILTER: 'filter',
	  // DEPRECATED
	  PERSISTED_FILTER: 'filters',
	  STATIC_FILTER_NODES: 'static-filter-nodes',
	  LOCATION_RADIUS_FILTER_NODE: 'location-radius-filter-node',
	  PERSISTED_LOCATION_RADIUS: 'locationRadius',
	  QUERY: 'query',
	  QUERY_ID: 'query-id',
	  FACET_FILTER_NODES: 'facet-filter-nodes',
	  PERSISTED_FACETS: 'facetFilters',
	  DYNAMIC_FILTERS: 'dynamic-filters',
	  GEOLOCATION: 'geolocation',
	  QUESTION_SUBMISSION: 'question-submission',
	  SEARCH_CONFIG: 'search-config',
	  SEARCH_OFFSET: 'search-offset',
	  SPELL_CHECK: 'spell-check',
	  SKIP_SPELL_CHECK: 'skipSpellCheck',
	  LOCATION_BIAS: 'location-bias',
	  SESSIONS_OPT_IN: 'sessions-opt-in',
	  VERTICAL_PAGES_CONFIG: 'vertical-pages-config',
	  LOCALE: 'locale',
	  SORT_BYS: 'sortBys',
	  NO_RESULTS_CONFIG: 'no-results-config',
	  RESULTS_HEADER: 'results-header',
	  // DEPRECATED
	  API_CONTEXT: 'context',
	  REFERRER_PAGE_URL: 'referrerPageUrl',
	  QUERY_TRIGGER: 'queryTrigger',
	  FACETS_LOADED: 'facets-loaded',
	  QUERY_SOURCE: 'query-source',
	  HISTORY_POP_STATE: 'history-pop-state'
	};

	/**
	 * Model representing a set of dynamic filters
	 */

	var DynamicFilters = /*#__PURE__*/function () {
	  function DynamicFilters(data) {
	    /**
	     * The list of facets this model holds
	     * @type {DisplayableFacet[]} from answers-core
	     */
	    this.filters = data.filters || [];
	    /**
	     * The {@link ResultsContext} of the facets.
	     * @type {ResultsContext}
	     */

	    this.resultsContext = data.resultsContext;

	    freeze$2(this);
	  }
	  /**
	   * Organize 'facets' from the answers-core into dynamic filters
	   * @param {DisplayableFacet[]} facets from answers-core
	   * @param {ResultsContext} resultsContext
	   * @returns {DynamicFilters}
	   */


	  DynamicFilters.fromCore = function fromCore(facets, resultsContext) {
	    if (facets === void 0) {
	      facets = [];
	    }

	    if (resultsContext === void 0) {
	      resultsContext = ResultsContext.NORMAL;
	    }

	    return new DynamicFilters({
	      filters: facets,
	      resultsContext: resultsContext
	    });
	  };

	  return DynamicFilters;
	}();

	/** @module LocationBias */
	/**
	 * LocationBias is the core state model
	 * to power the LocationBias component
	 */

	var LocationBias$1 = /*#__PURE__*/function () {
	  function LocationBias(data) {
	    /**
	     * The location bias accuracy which are IP, DEVICE and UNKNWON
	     * @type {string}
	     */
	    this.accuracy = data.accuracy || null;
	    /**
	     * The latitude used for location bias
	     * @type {number}
	     */

	    this.latitude = data.latitude || null;
	    /**
	     * The longitude used for location bias
	     * @type {number}
	     */

	    this.longitude = data.longitude || null;
	    /**
	     * The location display name
	     * @type {string}
	     */

	    this.locationDisplayName = data.locationDisplayName || null;
	    /**
	     * Whether the search is loading or completed
	     */

	    this.searchState = data.searchState;
	  }
	  /**
	   * Construct a LocationBias object representing loading results
	   * @return {LocationBias}
	   */


	  LocationBias.searchLoading = function searchLoading() {
	    return new LocationBias({
	      searchState: SearchStates.SEARCH_LOADING
	    });
	  }
	  /*
	  * Constructs an SDK LocationBias model from an answers-core LocationBias
	  *
	  * @param {LocationBias} locationBias from answers-core
	  * @returns {LocationBias}
	  */
	  ;

	  LocationBias.fromCore = function fromCore(locationBias) {
	    if (!locationBias) {
	      return new LocationBias({
	        accuracy: 'UNKNOWN'
	      });
	    }

	    return new LocationBias({
	      accuracy: locationBias.method,
	      latitude: locationBias.latitude,
	      longitude: locationBias.longitude,
	      locationDisplayName: locationBias.displayName,
	      searchState: SearchStates.SEARCH_COMPLETE
	    });
	  };

	  return LocationBias;
	}();

	var AlternativeVerticals = /*#__PURE__*/function () {
	  function AlternativeVerticals(data) {
	    /**
	     * Alternative verticals that have results for the current query
	     * @type {Section}
	     */
	    this.alternativeVerticals = data || [];
	  }
	  /**
	   * Create alternative verticals from server data
	   *
	   * @param {Object[]} alternativeVerticals
	   * @param {Object<string, function>} formatters applied to the result fields
	   */


	  AlternativeVerticals.fromCore = function fromCore(alternativeVerticals, formatters) {
	    if (!alternativeVerticals || alternativeVerticals.length === 0) {
	      return new AlternativeVerticals();
	    }

	    return new AlternativeVerticals(map$2(alternativeVerticals).call(alternativeVerticals, function (alternativeVertical) {
	      return VerticalResults.fromCore(alternativeVertical, {}, formatters);
	    }));
	  };

	  return AlternativeVerticals;
	}();

	function ownKeys$2(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$2(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$2(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * A Data Transformer that takes the response object from a Search request
	 * And transforms in to a front-end oriented data structure that our
	 * component library and core storage understand.
	 */

	var SearchDataTransformer = /*#__PURE__*/function () {
	  function SearchDataTransformer() {}

	  SearchDataTransformer.transformUniversal = function transformUniversal(data, urls, formatters) {
	    var _ref;

	    if (urls === void 0) {
	      urls = {};
	    }

	    if (formatters === void 0) {
	      formatters = undefined;
	    }

	    return _ref = {}, _ref[StorageKeys.QUERY_ID] = data.queryId, _ref[StorageKeys.NAVIGATION] = Navigation.fromCore(data.verticalResults), _ref[StorageKeys.DIRECT_ANSWER] = DirectAnswer.fromCore(data.directAnswer, formatters), _ref[StorageKeys.UNIVERSAL_RESULTS] = UniversalResults.fromCore(data, urls, formatters), _ref[StorageKeys.SPELL_CHECK] = SpellCheck$1.fromCore(data.spellCheck), _ref[StorageKeys.LOCATION_BIAS] = LocationBias$1.fromCore(data.locationBias), _ref;
	  };

	  SearchDataTransformer.transformVertical = function transformVertical(coreResponse, formatters, verticalKey) {
	    var _ref2;

	    var hasResults = coreResponse.verticalResults && coreResponse.verticalResults.results && coreResponse.verticalResults.resultsCount > 0;
	    var resultsContext = ResultsContext.NORMAL;
	    var response = coreResponse;

	    if (!hasResults) {
	      resultsContext = ResultsContext.NO_RESULTS;
	      response = SearchDataTransformer._reshapeForNoResults(coreResponse);
	    }

	    return _ref2 = {}, _ref2[StorageKeys.QUERY_ID] = response.queryId, _ref2[StorageKeys.NAVIGATION] = new Navigation(), _ref2[StorageKeys.VERTICAL_RESULTS] = VerticalResults.fromCore(response.verticalResults, {}, formatters, resultsContext, verticalKey), _ref2[StorageKeys.DYNAMIC_FILTERS] = DynamicFilters.fromCore(response.facets, resultsContext), _ref2[StorageKeys.SPELL_CHECK] = SpellCheck$1.fromCore(response.spellCheck), _ref2[StorageKeys.ALTERNATIVE_VERTICALS] = AlternativeVerticals.fromCore(response.alternativeVerticals, formatters), _ref2[StorageKeys.LOCATION_BIAS] = LocationBias$1.fromCore(response.locationBias), _ref2;
	  }
	  /**
	   * Form response as if the results from `allResultsForVertical` were the actual
	   * results in `results`
	   *
	   * @param {Object} response The server response
	   */
	  ;

	  SearchDataTransformer._reshapeForNoResults = function _reshapeForNoResults(response) {
	    var allResultsForVertical = response.allResultsForVertical || {};

	    var _ref3 = allResultsForVertical.verticalResults || {},
	        results = _ref3.results,
	        resultsCount = _ref3.resultsCount;

	    return _objectSpread$1(_objectSpread$1({}, response), {}, {
	      results: results || [],
	      resultsCount: resultsCount || 0,
	      verticalResults: allResultsForVertical.verticalResults,
	      facets: allResultsForVertical.facets
	    });
	  };

	  return SearchDataTransformer;
	}();

	/** @module QuestionSubmission */

	/**
	 * QuestionSubmission is the core state model
	 * to power the QuestionSubmission component
	 */
	var QuestionSubmission = /*#__PURE__*/function () {
	  function QuestionSubmission(question, errors) {
	    if (question === void 0) {
	      question = {};
	    }

	    if (errors === void 0) {
	      errors = null;
	    }

	    /**
	     * The author of the question
	     * @type {string}
	     */
	    this.name = question.name || null;
	    /**
	     * The email address of the question
	     * @type {string}
	     */

	    this.email = question.email || null;
	    /**
	     * True if the privacy policy was approved
	     * @type {boolean}
	     */

	    this.privacyPolicy = question.privacyPolicy || null;
	    /**
	     * The question to be sent to the server
	     * @type {string}
	     */

	    this.questionText = question.questionText || null;
	    /**
	     * Alternative question meta information
	     * @type {string}
	     */

	    this.questionDescription = question.questionDescription || null;
	    /**
	     * Whether the form is expanded or not. Defaults to true.
	     */

	    this.questionExpanded = typeof question.expanded !== 'boolean' || question.expanded;
	    /**
	     * Contains any errors about the question submission
	     * @type {object}
	     */

	    this.errors = errors || null;
	    /**
	     * Whether the form has been submitted or not. Defaults to false.
	     */

	    this.questionSubmitted = question.submitted || false;

	    freeze$2(this);
	  }

	  QuestionSubmission.submitted = function submitted() {
	    return {
	      questionSubmitted: true,
	      questionExpanded: true
	    };
	  };

	  QuestionSubmission.errors = function errors(question, _errors) {
	    return QuestionSubmission(question, _errors);
	  };

	  return QuestionSubmission;
	}();

	/** @module QueryTriggers */

	/**
	 * QueryTriggers is an ENUM of the possible triggers for a
	 * query update.
	 *
	 * @enum {string}
	 */
	var QueryTriggers = {
	  INITIALIZE: 'initialize',
	  QUERY_PARAMETER: 'query-parameter',
	  SUGGEST: 'suggest',
	  FILTER_COMPONENT: 'filter-component',
	  PAGINATION: 'pagination',
	  SEARCH_BAR: 'search-bar'
	};

	var keys$4 = keys$1;

	var keys$5 = keys$4;

	var objectWithoutPropertiesLoose = createCommonjsModule(function (module) {
	function _objectWithoutPropertiesLoose(source, excluded) {
	  if (source == null) return {};
	  var target = {};

	  var sourceKeys = keys$5(source);

	  var key, i;

	  for (i = 0; i < sourceKeys.length; i++) {
	    key = sourceKeys[i];
	    if (indexOf$5(excluded).call(excluded, key) >= 0) continue;
	    target[key] = source[key];
	  }

	  return target;
	}

	module.exports = _objectWithoutPropertiesLoose;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _objectWithoutPropertiesLoose = unwrapExports(objectWithoutPropertiesLoose);

	/**
	 * Model for the analytics event type
	 */
	var AnalyticsEvent = /*#__PURE__*/function () {
	  function AnalyticsEvent(type, label) {
	    /**
	     * The type of event to report
	     * @type {string}
	     */
	    this.eventType = type.toUpperCase();
	    /**
	     * An optional label to be provided for the event
	     * @type {string}
	     */

	    if (label) {
	      this.label = label;
	    }
	  }
	  /**
	   * Adds the provided options to the event
	   * @param {object} options Additional options for the event
	   */


	  var _proto = AnalyticsEvent.prototype;

	  _proto.addOptions = function addOptions(options) {
	    _extends(this, options);

	    return this;
	  }
	  /**
	   * Return the event in the api format, typically for reporting to the api
	   */
	  ;

	  _proto.toApiEvent = function toApiEvent() {
	    return _extends({}, this);
	  }
	  /**
	   * Creating an analytics event from raw data.
	   * @param {Object} data
	   */
	  ;

	  AnalyticsEvent.fromData = function fromData(data) {
	    var type = data.type,
	        label = data.label,
	        eventOptions = _objectWithoutPropertiesLoose(data, ["type", "label"]);

	    var analyticsEvent = new AnalyticsEvent(type, label);
	    analyticsEvent.addOptions(eventOptions);
	    return analyticsEvent;
	  };

	  return AnalyticsEvent;
	}();

	// `FlattenIntoArray` abstract operation
	// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
	var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
	  var targetIndex = start;
	  var sourceIndex = 0;
	  var mapFn = mapper ? functionBindContext(mapper, thisArg, 3) : false;
	  var element;

	  while (sourceIndex < sourceLen) {
	    if (sourceIndex in source) {
	      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

	      if (depth > 0 && isArray(element)) {
	        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
	      } else {
	        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
	        target[targetIndex] = element;
	      }

	      targetIndex++;
	    }
	    sourceIndex++;
	  }
	  return targetIndex;
	};

	var flattenIntoArray_1 = flattenIntoArray;

	// `Array.prototype.flatMap` method
	// https://tc39.es/ecma262/#sec-array.prototype.flatmap
	_export({ target: 'Array', proto: true }, {
	  flatMap: function flatMap(callbackfn /* , thisArg */) {
	    var O = toObject(this);
	    var sourceLen = toLength(O.length);
	    var A;
	    aFunction(callbackfn);
	    A = arraySpeciesCreate(O, 0);
	    A.length = flattenIntoArray_1(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	    return A;
	  }
	});

	var flatMap = entryVirtual('Array').flatMap;

	var ArrayPrototype$d = Array.prototype;

	var flatMap_1 = function (it) {
	  var own = it.flatMap;
	  return it === ArrayPrototype$d || (it instanceof Array && own === ArrayPrototype$d.flatMap) ? flatMap : own;
	};

	var flatMap$1 = flatMap_1;

	var flatMap$2 = flatMap$1;

	var nativeStartsWith = ''.startsWith;
	var min$2 = Math.min;

	var CORRECT_IS_REGEXP_LOGIC = correctIsRegexpLogic('startsWith');

	// `String.prototype.startsWith` method
	// https://tc39.es/ecma262/#sec-string.prototype.startswith
	_export({ target: 'String', proto: true, forced:  !CORRECT_IS_REGEXP_LOGIC }, {
	  startsWith: function startsWith(searchString /* , position = 0 */) {
	    var that = String(requireObjectCoercible(this));
	    notARegexp(searchString);
	    var index = toLength(min$2(arguments.length > 1 ? arguments[1] : undefined, that.length));
	    var search = String(searchString);
	    return nativeStartsWith
	      ? nativeStartsWith.call(that, search, index)
	      : that.slice(index, index + search.length) === search;
	  }
	});

	var startsWith = entryVirtual('String').startsWith;

	var StringPrototype$2 = String.prototype;

	var startsWith_1 = function (it) {
	  var own = it.startsWith;
	  return typeof it === 'string' || it === StringPrototype$2
	    || (it instanceof String && own === StringPrototype$2.startsWith) ? startsWith : own;
	};

	var startsWith$1 = startsWith_1;

	var startsWith$2 = startsWith$1;

	/** @module Facet */

	/**
	 * Model representing a facet filter with the format of
	 * {
	 *   "field_name": [ Filters... ],
	 *   ...
	 * }
	 *
	 * @see {@link Filter}
	 */
	var Facet = /*#__PURE__*/function () {
	  function Facet(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    _extends(this, data);

	    freeze$2(this);
	  }
	  /**
	   * Create a facet filter from a list of Filters
	   * @param {Array<string>} availableFieldIds array of expected field ids
	   * @param  {...Filter} filters The filters to use in this facet
	   * @returns {Facet}
	   */


	  Facet.fromFilters = function fromFilters(availableFieldIds) {
	    var groups = {};

	    forEach$2(availableFieldIds).call(availableFieldIds, function (fieldId) {
	      groups[fieldId] = [];
	    });

	    for (var _len = arguments.length, filters = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      filters[_key - 1] = arguments[_key];
	    }

	    var flatFilters = flatMap$2(filters).call(filters, function (f) {
	      return f.$or || f;
	    });

	    forEach$2(flatFilters).call(flatFilters, function (f) {
	      var key = f.getFilterKey();

	      if (!groups[key]) {
	        groups[key] = [];
	      }

	      groups[key].push(f);
	    });

	    return new Facet(groups);
	  }
	  /**
	   * Transforms an answers-core DisplayableFacet array into a Facet array
	   *
	   * @param {DisplayableFacet[]} coreFacets from answers-core
	   * @returns {Facet[]}
	   */
	  ;

	  Facet.fromCore = function fromCore(coreFacets) {
	    var _context;

	    if (coreFacets === void 0) {
	      coreFacets = [];
	    }

	    var facets = map$2(_context = map$2(coreFacets).call(coreFacets, function (f) {
	      var _context2;

	      return {
	        label: f.displayName,
	        fieldId: f.fieldId,
	        options: map$2(_context2 = f.options).call(_context2, function (o) {
	          var _f$fieldId, _filter;

	          return {
	            label: o.displayName,
	            countLabel: o.count,
	            selected: o.selected,
	            filter: (_filter = {}, _filter[f.fieldId] = (_f$fieldId = {}, _f$fieldId[o.matcher] = o.value, _f$fieldId), _filter)
	          };
	        })
	      };
	    })).call(_context, function (f) {
	      return new Facet(f);
	    });

	    return facets;
	  };

	  return Facet;
	}();

	var assertThisInitialized = createCommonjsModule(function (module) {
	function _assertThisInitialized(self) {
	  if (self === void 0) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return self;
	}

	module.exports = _assertThisInitialized;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _assertThisInitialized = unwrapExports(assertThisInitialized);

	/** @module FilterTypes */

	/**
	 * FilterType is an ENUM for the different types of filters in the SDK.
	 * @enum {string}
	 */
	var FilterType = {
	  STATIC: 'filter-type-static',
	  FACET: 'filter-type-facet',
	  RADIUS: 'filter-type-radius',
	  NLP: 'filter-type-nlp'
	};

	/**
	 * FilterMetadata is a container for additional display data for a {@link Filter}.
	 */

	var FilterMetadata = function FilterMetadata(metadata) {
	  if (metadata === void 0) {
	    metadata = {};
	  }

	  var _metadata = metadata,
	      fieldName = _metadata.fieldName,
	      displayValue = _metadata.displayValue,
	      filterType = _metadata.filterType;
	  /**
	   * The display name for the field being filtered on.
	   * @type {string}
	   */

	  this.fieldName = fieldName;
	  /**
	   * The display value for the values being filtered on.
	   * Even if there are multiple values within the data of a filter,
	   * there should only be one display value for the whole filter.
	   * @type {string}
	   */

	  this.displayValue = displayValue;
	  /**
	   * What type of filter this is.
	   * @type {FilterType}
	   */

	  this.filterType = filterType || FilterType.STATIC;

	  freeze$2(this);
	};

	/** @module FilterNode */

	/**
	 * A FilterNode represents a single node in a filter tree.
	 * Each filter node has an associated filter, containing the filter
	 * data to send in a request, any additional filter metadata for display,
	 * and any children nodes.
	 *
	 * Implemented by {@link SimpleFilterNode} and {@link CombinedFilterNode}.
	 */
	var FilterNode = /*#__PURE__*/function () {
	  function FilterNode() {}

	  var _proto = FilterNode.prototype;

	  /**
	   * Returns this node's filter.
	   * @returns {Filter}
	   */
	  _proto.getFilter = function getFilter() {}
	  /**
	   * Returns the metadata for this node's filter.
	   * @returns {FilterMetadata}
	   */
	  ;

	  _proto.getMetadata = function getMetadata() {}
	  /**
	   * Returns the children of this node.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getChildren = function getChildren() {}
	  /**
	   * Recursively get all of the leaf SimpleFilterNodes.
	   * @returns {Array<SimpleFilterNode>}
	   */
	  ;

	  _proto.getSimpleDescendants = function getSimpleDescendants() {}
	  /**
	   * Remove this FilterNode from the FilterRegistry.
	   */
	  ;

	  _proto.remove = function remove() {};

	  return FilterNode;
	}();

	/**
	 * A SimpleFilterNode represents a single, atomic filter.
	 * An atomic filter is a filter that filters on a single field id,
	 * and does not contain any children filters.
	 */

	var SimpleFilterNode = /*#__PURE__*/function (_FilterNode) {
	  _inheritsLoose(SimpleFilterNode, _FilterNode);

	  function SimpleFilterNode(filterNode) {
	    var _this;

	    if (filterNode === void 0) {
	      filterNode = {};
	    }

	    _this = _FilterNode.call(this) || this;

	    var _filterNode = filterNode,
	        filter = filter$2(_filterNode),
	        metadata = _filterNode.metadata,
	        remove = _filterNode.remove;
	    /**
	     * The filter data.
	     * @type {Filter}
	     */


	    _this.filter = Filter.from(filter);
	    /**
	     * Display metadata associated with the filter data.
	     * @type {FilterMetadata}
	     */

	    _this.metadata = new FilterMetadata(metadata);
	    /**
	     * Remove callback function.
	     * @type {Function}
	     */

	    _this._remove = remove || function () {};

	    freeze$2(_assertThisInitialized(_this));

	    return _this;
	  }
	  /**
	   * Returns the filter associated with this node.
	   * @type {Filter}
	   */


	  var _proto = SimpleFilterNode.prototype;

	  _proto.getFilter = function getFilter() {
	    return filter$2(this);
	  }
	  /**
	   * Returns the children associated with this node (no children).
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getChildren = function getChildren() {
	    return [];
	  }
	  /**
	   * Returns the filter metadata for this node's filter.
	   * @returns {FilterMetadata}
	   */
	  ;

	  _proto.getMetadata = function getMetadata() {
	    return this.metadata;
	  }
	  /**
	   * Recursively get all of the leaf SimpleFilterNodes.
	   * Since SimpleFilterNodes have no children this just returns itself.
	   * @returns {Array<SimpleFilterNode>}
	   */
	  ;

	  _proto.getSimpleDescendants = function getSimpleDescendants() {
	    return this;
	  }
	  /**
	   * Removes this filter node from the FilterRegistry.
	   */
	  ;

	  _proto.remove = function remove() {
	    this._remove();
	  }
	  /**
	   * Returns whether this SimpleFilterNode's filter is equal to another SimpleFilterNode's
	   * @param {SimpleFilterNode} node
	   * @returns {boolean}
	   */
	  ;

	  _proto.hasSameFilterAs = function hasSameFilterAs(otherNode) {
	    var thisFilter = this.getFilter();
	    var otherFilter = otherNode.getFilter();
	    var thisFieldId = thisFilter.getFilterKey();
	    var otherFieldId = otherFilter.getFilterKey();

	    if (thisFieldId !== otherFieldId) {
	      return false;
	    }

	    var thisMatchersToValues = thisFilter[thisFieldId];
	    var otherMatchersToValues = otherFilter[otherFieldId];

	    var thisMatchers = keys$3(thisMatchersToValues);

	    var otherMatchers = keys$3(otherMatchersToValues);

	    if (thisMatchers.length !== otherMatchers.length) {
	      return false;
	    }

	    return every$2(thisMatchers).call(thisMatchers, function (m) {
	      return m in otherMatchersToValues && otherMatchersToValues[m] === thisMatchersToValues[m];
	    });
	  };

	  return SimpleFilterNode;
	}(FilterNode);

	/**
	 * A CombinedFilterNode represents a combined filter.
	 * A combined filter is a set of filters combined with a {@link FilterCombinators}
	 * ($and or $or). Since a combined filter is just a set of other filters,
	 * it does not have its own {@link FilterMetadata}, and its filter is dervied from
	 * its children.
	 */

	var CombinedFilterNode = /*#__PURE__*/function (_FilterNode) {
	  _inheritsLoose(CombinedFilterNode, _FilterNode);

	  function CombinedFilterNode(filterNode) {
	    var _this;

	    if (filterNode === void 0) {
	      filterNode = {};
	    }

	    _this = _FilterNode.call(this) || this;
	    var _filterNode = filterNode,
	        combinator = _filterNode.combinator,
	        children = _filterNode.children;
	    /**
	     * @type {string}
	     */

	    _this.combinator = combinator;
	    /**
	     * @type {Array<FilterNode>}
	     */

	    _this.children = children || [];

	    freeze$2(_assertThisInitialized(_this));

	    return _this;
	  }
	  /**
	   * Returns the filter created by combining this node's children.
	   * @type {Filter}
	   */


	  var _proto = CombinedFilterNode.prototype;

	  _proto.getFilter = function getFilter() {
	    var _context;

	    var filters = map$2(_context = this.children).call(_context, function (childNode) {
	      return childNode.getFilter();
	    });

	    switch (this.combinator) {
	      case FilterCombinators.AND:
	        return Filter.and.apply(Filter, filters);

	      case FilterCombinators.OR:
	        return Filter.or.apply(Filter, filters);
	    }

	    return Filter.empty();
	  }
	  /**
	   * Returns the metadata associated with this node's filter.
	   * Because a combined filter's purpose is solely to join together other filters,
	   * and does not have its own filter, this value is always null.
	   * @returns {null}
	   */
	  ;

	  _proto.getMetadata = function getMetadata() {
	    return null;
	  }
	  /**
	   * Returns this node's children.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getChildren = function getChildren() {
	    return this.children;
	  }
	  /**
	   * Recursively get all of the leaf SimpleFilterNodes.
	   * @returns {Array<SimpleFilterNode>}
	   */
	  ;

	  _proto.getSimpleDescendants = function getSimpleDescendants() {
	    var _context2;

	    return flatMap$2(_context2 = this.getChildren()).call(_context2, function (fn) {
	      return fn.getSimpleDescendants();
	    });
	  }
	  /**
	   * Removes this filter node from the FilterRegistry by calling remove on each of its
	   * child FilterNodes.
	   */
	  ;

	  _proto.remove = function remove() {
	    var _context3;

	    forEach$2(_context3 = this.children).call(_context3, function (child) {
	      child.remove();
	    });
	  };

	  return CombinedFilterNode;
	}(FilterNode);

	/**
	 * FilterNodeFactory is a class containing static helper methods for
	 * generating FilterNodes.
	 */

	var FilterNodeFactory = /*#__PURE__*/function () {
	  function FilterNodeFactory() {}

	  /**
	   * Create an AND filter node, with specified children.
	   * @param  {...FilterNode} childrenNodes
	   * @returns {FilterNode}
	   */
	  FilterNodeFactory.and = function and() {
	    for (var _len = arguments.length, childrenNodes = new Array(_len), _key = 0; _key < _len; _key++) {
	      childrenNodes[_key] = arguments[_key];
	    }

	    return FilterNodeFactory._combine(FilterCombinators.AND, childrenNodes);
	  }
	  /**
	   * Create an OR filter node, with specified children.
	   * @param  {...FilterNode} childrenNodes
	   * @returns {FilterNode}
	   */
	  ;

	  FilterNodeFactory.or = function or() {
	    for (var _len2 = arguments.length, childrenNodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	      childrenNodes[_key2] = arguments[_key2];
	    }

	    return FilterNodeFactory._combine(FilterCombinators.OR, childrenNodes);
	  }
	  /**
	   * Creates a combined filter node with the given combinator and children.
	   * @param {string} combinator
	   * @param {Array<FilterNode>} filterNodes
	   * @returns {FilterNode}
	   * @private
	   */
	  ;

	  FilterNodeFactory._combine = function _combine(combinator, filterNodes) {
	    var children = filter$2(filterNodes).call(filterNodes, function (fn) {
	      return fn.getFilter().getFilterKey();
	    });

	    if (!children.length) {
	      return new SimpleFilterNode();
	    }

	    if (children.length === 1) {
	      return children[0];
	    }

	    return new CombinedFilterNode({
	      combinator: combinator,
	      children: children
	    });
	  }
	  /**
	   * Creates a filterNode from the given data.
	   * @param {Object|FilterNode} filterNode
	   * @returns {FilterNode}
	   */
	  ;

	  FilterNodeFactory.from = function from(filterNode) {
	    if (filterNode === void 0) {
	      filterNode = {};
	    }

	    if (filterNode.children && filterNode.children.length) {
	      return new CombinedFilterNode(filterNode);
	    }

	    return new SimpleFilterNode(filterNode);
	  };

	  return FilterNodeFactory;
	}();

	/** @typedef {import('../storage/storage').default} Storage */

	/**
	 * FilterRegistry is a structure that manages static {@link Filter}s and {@link Facet} filters.
	 *
	 * Static filters and facet filters are stored within storage using FilterNodes.
	 */

	var FilterRegistry = /*#__PURE__*/function () {
	  function FilterRegistry(storage, availableFieldIds) {
	    if (availableFieldIds === void 0) {
	      availableFieldIds = [];
	    }

	    /**
	     * FilterRegistry uses {@link Storage} for storing FilterNodes.
	     * Each node is given a unique key in storage.
	     * @type {Storage}
	     */
	    this.storage = storage;
	    /**
	     * All available field ids for the current facet filters, including
	     * field ids for unused but available filters.
	     * @type {Array<string>}
	     */

	    this.availableFieldIds = availableFieldIds;
	  }
	  /**
	   * Returns an array containing all of the filternodes stored in storage.
	   * @returns {Array<FilterNode>}
	   */


	  var _proto = FilterRegistry.prototype;

	  _proto.getAllFilterNodes = function getAllFilterNodes() {
	    var _context;

	    var storageFilterNodes = concat$2(_context = []).call(_context, this.getStaticFilterNodes(), this.getFacetFilterNodes());

	    var locationRadiusFilterNode = this.getFilterNodeByKey(StorageKeys.LOCATION_RADIUS_FILTER_NODE);

	    if (locationRadiusFilterNode) {
	      storageFilterNodes.push(locationRadiusFilterNode);
	    }

	    return storageFilterNodes;
	  }
	  /**
	   * Get all of the {@link FilterNode}s for static filters.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getStaticFilterNodes = function getStaticFilterNodes() {
	    var _context2;

	    var staticFilterNodes = [];

	    forEach$2(_context2 = this.storage.getAll()).call(_context2, function (value, key) {
	      if (startsWith$2(key).call(key, StorageKeys.STATIC_FILTER_NODES)) {
	        staticFilterNodes.push(value);
	      }
	    });

	    return staticFilterNodes;
	  }
	  /**
	   * Get all of the active {@link FilterNode}s for facets.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getFacetFilterNodes = function getFacetFilterNodes() {
	    return this.storage.get(StorageKeys.FACET_FILTER_NODES) || [];
	  }
	  /**
	   * Gets the static filters as a {@link Filter|CombinedFilter} to send to the answers-core
	   *
	   * @returns {CombinedFilter|Filter|null} Returns null if no filters with
	   *                                             filtering logic are present.
	   */
	  ;

	  _proto.getStaticFilterPayload = function getStaticFilterPayload() {
	    var _context3;

	    var filterNodes = filter$2(_context3 = this.getStaticFilterNodes()).call(_context3, function (filterNode) {
	      return filterNode.getChildren().length > 0 || filterNode.getFilter().getFilterKey();
	    });

	    return filterNodes.length > 0 ? this._transformFilterNodes(filterNodes, FilterCombinators.AND) : null;
	  }
	  /**
	   * Combines together all static filter nodes in the same shape that would
	   * be sent to the API.
	   *
	   * @returns {FilterNode}
	   */
	  ;

	  _proto.getAllStaticFilterNodesCombined = function getAllStaticFilterNodesCombined() {
	    var filterNodes = this.getStaticFilterNodes();
	    var totalNode = FilterNodeFactory.and.apply(FilterNodeFactory, filterNodes);
	    return totalNode;
	  }
	  /**
	   * Transforms a list of filter nodes {@link CombinedFilterNode} or {@link SimpleFilterNode} to
	   * answers-core's {@link Filter} or {@link CombinedFilter}
	   *
	   * @param {Array<CombinedFilterNode|SimpleFilterNode>} filterNodes
	   * @param {FilterCombinator} combinator from answers-core
	   * @returns {CombinedFilter|Filter} from answers-core
	   */
	  ;

	  _proto._transformFilterNodes = function _transformFilterNodes(filterNodes, combinator) {
	    var _this = this;

	    var filters = flatMap$2(filterNodes).call(filterNodes, function (filterNode) {
	      if (filterNode.children) {
	        return _this._transformFilterNodes(filterNode.children, filterNode.combinator);
	      }

	      return _this._transformSimpleFilterNode(filterNode);
	    });

	    return filters.length === 1 ? filters[0] : {
	      filters: filters,
	      combinator: combinator
	    };
	  }
	  /**
	   * Transforms a {@link SimpleFilterNode} to answers-core's {@link Filter} or {@link CombinedFilter}
	   * if there are multiple matchers.
	   * TODO(SLAP-1183): remove the parsing for multiple matchers.
	   *
	   * @param {SimpleFilterNode} filterNode
	   * @returns {Filter}
	   */
	  ;

	  _proto._transformSimpleFilterNode = function _transformSimpleFilterNode(filterNode) {
	    var fieldId = keys$3(filter$2(filterNode))[0];

	    var filterComparison = filter$2(filterNode)[fieldId];

	    var matchers = keys$3(filterComparison);

	    if (matchers.length === 1) {
	      var matcher = matchers[0];
	      var value = filterComparison[matcher];
	      return {
	        fieldId: fieldId,
	        matcher: matcher,
	        value: value
	      };
	    } else if (matchers.length > 1) {
	      var childFilters = map$2(matchers).call(matchers, function (matcher) {
	        return {
	          fieldId: fieldId,
	          matcher: matcher,
	          value: filterComparison[matcher]
	        };
	      });

	      return {
	        combinator: FilterCombinators.AND,
	        filters: childFilters
	      };
	    }
	  }
	  /**
	   * Transforms a {@link Filter} into answers-core's {@link FacetOption}
	   *
	   * @param {Filter} filter
	   * @returns {FacetOption} from answers-core
	   */
	  ;

	  _proto._transformSimpleFilterNodeIntoFacetOption = function _transformSimpleFilterNodeIntoFacetOption(filter) {
	    var fieldId = keys$3(filter)[0];

	    var filterComparison = filter[fieldId];

	    var matcher = keys$3(filterComparison)[0];

	    var value = filterComparison[matcher];
	    return {
	      matcher: matcher,
	      value: value
	    };
	  }
	  /**
	   * Combines the active facet FilterNodes into a single Facet
	   *
	   * @returns {Facet}
	   */
	  ;

	  _proto._createFacetsFromFilterNodes = function _createFacetsFromFilterNodes() {
	    var _context5, _context6;

	    var getFilters = function getFilters(fn) {
	      var _context4;

	      return fn.getChildren().length ? flatMap$2(_context4 = fn.getChildren()).call(_context4, getFilters) : fn.getFilter();
	    };

	    var filters = flatMap$2(_context5 = this.getFacetFilterNodes()).call(_context5, getFilters);

	    return Facet.fromFilters.apply(Facet, concat$2(_context6 = [this.availableFieldIds]).call(_context6, filters));
	  }
	  /**
	   * Returns the current Facets state.
	   *
	   * @returns {Facet}
	   */
	  ;

	  _proto.getFacets = function getFacets() {
	    var hasFacetFilterNodes = this.storage.has(StorageKeys.FACET_FILTER_NODES);
	    return hasFacetFilterNodes ? this._createFacetsFromFilterNodes() : this.storage.get(StorageKeys.PERSISTED_FACETS) || {};
	  }
	  /**
	   * Gets the facet filters as an array of Filters to send to the answers-core.
	   *
	   * @returns {Facet[]} from answers-core
	   */
	  ;

	  _proto.getFacetsPayload = function getFacetsPayload() {
	    var _context7,
	        _this2 = this;

	    var facets = this.getFacets();

	    var coreFacets = map$2(_context7 = entries$5(facets)).call(_context7, function (_ref) {
	      var fieldId = _ref[0],
	          filterArray = _ref[1];
	      return {
	        fieldId: fieldId,
	        options: map$2(filterArray).call(filterArray, _this2._transformSimpleFilterNodeIntoFacetOption)
	      };
	    });

	    return coreFacets;
	  }
	  /**
	   * Get the FilterNode with the corresponding key. Defaults to null.
	   * @param {string} key
	   */
	  ;

	  _proto.getFilterNodeByKey = function getFilterNodeByKey(key) {
	    return this.storage.get(key);
	  }
	  /**
	   * Sets the specified {@link FilterNode} under the given key.
	   * Will replace a preexisting node if there is one.
	   * @param {string} key
	   * @param {FilterNode} filterNode
	   */
	  ;

	  _proto.setStaticFilterNodes = function setStaticFilterNodes(key, filterNode) {
	    this.storage.set(StorageKeys.STATIC_FILTER_NODES + "." + key, filterNode);
	  }
	  /**
	   * Sets the filter nodes used for the current facet filters.
	   *
	   * Because the search response only sends back one
	   * set of facet filters, there can only be one active facet filter node
	   * at a time.
	   * @param {Array<string>} availableFieldIds
	   * @param {Array<FilterNode>} filterNodes
	   */
	  ;

	  _proto.setFacetFilterNodes = function setFacetFilterNodes(availableFieldIds, filterNodes) {
	    if (availableFieldIds === void 0) {
	      availableFieldIds = [];
	    }

	    if (filterNodes === void 0) {
	      filterNodes = [];
	    }

	    this.availableFieldIds = availableFieldIds;
	    this.storage.set(StorageKeys.FACET_FILTER_NODES, filterNodes);
	  }
	  /**
	   * Sets the locationRadius filterNode. There may only be one locationRadius active
	   * at a time.
	   * @param {FilterNode} filterNode
	   */
	  ;

	  _proto.setLocationRadiusFilterNode = function setLocationRadiusFilterNode(filterNode) {
	    this.storage.set(StorageKeys.LOCATION_RADIUS_FILTER_NODE, filterNode);
	  }
	  /**
	   * Deletes the static FilterNode with this namespace.
	   * @param {string} key
	   */
	  ;

	  _proto.clearStaticFilterNode = function clearStaticFilterNode(key) {
	    this.storage["delete"](StorageKeys.STATIC_FILTER_NODES + "." + key);
	  }
	  /**
	   * Deletes all facet FilterNodes.
	   */
	  ;

	  _proto.clearFacetFilterNodes = function clearFacetFilterNodes() {
	    this.storage["delete"](StorageKeys.FACET_FILTER_NODES);
	  }
	  /**
	   * Deletes all FilterNodes in storage.
	   */
	  ;

	  _proto.clearAllFilterNodes = function clearAllFilterNodes() {
	    var _context8,
	        _this3 = this;

	    this.storage["delete"](StorageKeys.LOCATION_RADIUS_FILTER_NODE);
	    this.clearFacetFilterNodes();

	    forEach$2(_context8 = this.storage.getAll()).call(_context8, function (value, key) {
	      if (startsWith$2(key).call(key, StorageKeys.STATIC_FILTER_NODES)) {
	        _this3.storage["delete"](key);
	      }
	    });
	  };

	  return FilterRegistry;
	}();

	/** @module AutoCompleteData */
	var AutoCompleteData = function AutoCompleteData(data) {
	  if (data === void 0) {
	    data = {};
	  }

	  this.sections = data.sections || [];
	  this.queryId = data.queryId || '';
	  this.inputIntents = data.inputIntents || [];

	  freeze$2(this);
	};
	var AutoCompleteResult = function AutoCompleteResult(data) {
	  if (data === void 0) {
	    data = {};
	  }

	  this.filter = filter$2(data) || {};
	  this.key = data.key || '';
	  this.matchedSubstrings = data.matchedSubstrings || [];
	  this.value = data.value || '';
	  this.shortValue = data.shortValue || this.value;
	  this.intents = data.queryIntents || [];

	  freeze$2(this);
	};

	/**
	 * A data transformer that takes the response object from an
	 * AutoComplete request and transforms it into a front-end oriented
	 * data structure that our component library and core storage understand.
	 */

	var AutoCompleteResponseTransformer = /*#__PURE__*/function () {
	  function AutoCompleteResponseTransformer() {}

	  /**
	   * Converts a universal or vertical autocomplete response from the
	   * core library into an object that the SDK understands.
	   *
	   * @param {import('@yext/answers-core').AutocompleteResponse} response
	   *  the response passed from the core library
	   * @returns {AutoCompleteData}
	   */
	  AutoCompleteResponseTransformer.transformAutoCompleteResponse = function transformAutoCompleteResponse(response) {
	    var _context,
	        _this = this;

	    var sections = [{
	      results: map$2(_context = response.results).call(_context, function (result) {
	        return _this._transformAutoCompleteResult(result);
	      }),
	      resultsCount: response.results.length
	    }];
	    return new AutoCompleteData({
	      sections: sections,
	      queryId: response.queryId,
	      inputIntents: response.inputIntents
	    });
	  }
	  /**
	   * Converts a filter search response from the
	   * core library into an object that the SDK understands.
	   *
	   * @param {import('@yext/answers-core').FilterSearchResponse} response
	   *  the response passed from the core library
	   * @returns {AutoCompleteData}
	   */
	  ;

	  AutoCompleteResponseTransformer.transformFilterSearchResponse = function transformFilterSearchResponse(response) {
	    var _this2 = this;

	    if (response.sectioned && response.sections) {
	      var _context2;

	      var transformedSections = map$2(_context2 = response.sections).call(_context2, function (section) {
	        var _context3;

	        return {
	          label: section.label,
	          results: map$2(_context3 = section.results).call(_context3, function (result) {
	            return _this2._transformAutoCompleteResult(result);
	          }),
	          resultsCount: section.results.length
	        };
	      });

	      return new AutoCompleteData({
	        sections: transformedSections,
	        queryId: response.queryId,
	        inputIntents: response.inputIntents
	      });
	    } else {
	      return this.transformAutoCompleteResponse(response);
	    }
	  };

	  AutoCompleteResponseTransformer._transformAutoCompleteResult = function _transformAutoCompleteResult(result) {
	    var transformedFilter = filter$2(result) ? this._transformFilter(filter$2(result)) : {};
	    return new AutoCompleteResult({
	      filter: transformedFilter,
	      key: result.key,
	      matchedSubstrings: result.matchedSubstrings,
	      value: result.value
	    });
	  };

	  AutoCompleteResponseTransformer._transformFilter = function _transformFilter(filter) {
	    var _fieldId, _ref;

	    var fieldId = filter.fieldId;
	    var matcher = filter.matcher;
	    var value = filter.value;
	    return _ref = {}, _ref[fieldId] = (_fieldId = {}, _fieldId[matcher] = value, _fieldId), _ref;
	  };

	  return AutoCompleteResponseTransformer;
	}();

	/** @module */

	/** The current lib version, reported with errors and analytics, injected by the build process */
	var LIB_VERSION = 'v1.9.2';
	/** The current locale, injected by the build process */

	var LOCALE = 'en';
	/** The identifier of the production environment */

	var PRODUCTION = 'production';
	/** The identifier of the sandbox environment */

	var SANDBOX = 'sandbox';
	/** The default url for compiled component templates */

	var COMPILED_TEMPLATES_URL = "https://assets.sitescdn.net/answers/" + LIB_VERSION + "/answerstemplates.compiled.min.js";
	/** The query source, reported with analytics */

	var QUERY_SOURCE = 'STANDARD';
	var ENDPOINTS = {
	  UNIVERSAL_SEARCH: '/v2/accounts/me/answers/query',
	  VERTICAL_SEARCH: '/v2/accounts/me/answers/vertical/query',
	  QUESTION_SUBMISSION: '/v2/accounts/me/createQuestion',
	  UNIVERSAL_AUTOCOMPLETE: '/v2/accounts/me/answers/autocomplete',
	  VERTICAL_AUTOCOMPLETE: '/v2/accounts/me/answers/vertical/autocomplete',
	  FILTER_SEARCH: '/v2/accounts/me/answers/filtersearch'
	};

	/** @module SearchParams */

	/* global window */

	/**
	 * SearchParams is a class to get the search params in a URL.
	 * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
	 */
	var SearchParams = /*#__PURE__*/function () {
	  function SearchParams(url) {
	    /**
	     * Mapping of all query parameters in the given url, query param -> value
	     * Only used if URLSearchParams does not exist in the window
	     * @type {Object}
	     * @private
	     */
	    this._params = {};

	    if (window && window.URLSearchParams) {
	      return new urlSearchParams$2(url);
	    } else {
	      this._params = this.parse(url);
	    }
	  }
	  /**
	   * parse creates a mapping of all query params in a given url
	   * The query param values are decoded before being put in the map
	   * Three types of input are supported
	   *   (1) full URL e.g. http://www.yext.com/?q=hello
	   *   (2) params with ? e.g. ?q=hello
	   *   (1) params without ? e.g. q=hello
	   * @param {string} url The url
	   * @returns {Object} mapping from query param -> value where value is '' if no value is provided
	   */


	  var _proto = SearchParams.prototype;

	  _proto.parse = function parse(url) {
	    var params = {};
	    var search = url;

	    if (!search) {
	      return params;
	    } // Normalize all url inputs to string of query params separated by &


	    if (indexOf$3(url).call(url, '?') > -1) {
	      search = slice$4(url).call(url, indexOf$3(url).call(url, '?') + 1);
	    }

	    var encodedParams = search.split('&');

	    for (var i = 0; i < encodedParams.length; i++) {
	      var keyVal = encodedParams[i].split('=');

	      if (keyVal.length > 1) {
	        params[keyVal[0]] = SearchParams.decode(keyVal[1]);
	      } else {
	        params[keyVal[0]] = '';
	      }
	    }

	    return params;
	  }
	  /**
	   * get returns the value of the given query param
	   * @param {string} query the query param key to get the value of
	   * @return {string} param value, null otherwise
	   */
	  ;

	  _proto.get = function get(query) {
	    if (typeof this._params[String(query)] === 'undefined') {
	      return null;
	    }

	    return this._params[query];
	  }
	  /**
	   * set changes the value of a given query param
	   * @param {string} name the query param key
	   * @param {string} value the value of the query param update with
	   */
	  ;

	  _proto.set = function set(name, value) {
	    this._params[String(name)] = String(value);
	  }
	  /**
	   * has checks to see if the given query param key exists in the params object
	   * @param {string} query the query param to check
	   * @return {boolean} true if the query param is in the params object, false o/w
	   */
	  ;

	  _proto.has = function has(query) {
	    return query in this._params;
	  }
	  /**
	   * delete removes the given query param and its associated value from the params object
	   * @param {string} name the query param key
	   */
	  ;

	  _proto["delete"] = function _delete(name) {
	    delete this._params[String(name)];
	  }
	  /**
	   * toString returns a url with all the query params in the params object (without a ?)
	   * @return {string}
	   */
	  ;

	  _proto.toString = function toString() {
	    var string = [];

	    for (var key in this._params) {
	      string.push(key + "=" + SearchParams.encode(this._params[key]));
	    }

	    return string.join('&');
	  };

	  _proto.entries = function entries() {
	    var entries = [];

	    for (var key in this._params) {
	      entries.push([key, this._params[key]]);
	    }

	    return entries;
	  }
	  /**
	   * decode returns the decoded representation of the given string
	   * @param {string} string the string to decode
	   * @return {string}
	   */
	  ;

	  SearchParams.decode = function decode(string) {
	    return decodeURIComponent(string.replace(/[ +]/g, '%20'));
	  }
	  /**
	   * decode returns the encoded representation of the given string (e.g. + -> %2B)
	   * @param {string} string the string to encode
	   * @return {string}
	   */
	  ;

	  SearchParams.encode = function encode(string) {
	    var replace = {
	      '!': '%21',
	      "'": '%27',
	      '(': '%28',
	      ')': '%29',
	      '%20': '+'
	    };
	    return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
	      return replace[match];
	    });
	  };

	  return SearchParams;
	}();

	/** @module */

	/**
	 * An enum listing the different Component types supported in the SDK
	 * TODO: add all component types
	 * @type {Object.<string, string>}
	 */
	var ComponentTypes = {
	  FILTER_BOX: 'FilterBox',
	  FILTER_OPTIONS: 'FilterOptions',
	  RANGE_FILTER: 'RangeFilter',
	  DATE_RANGE_FILTER: 'DateRangeFilter',
	  FACETS: 'Facets',
	  GEOLOCATION_FILTER: 'GeoLocationFilter',
	  SORT_OPTIONS: 'SortOptions',
	  FILTER_SEARCH: 'FilterSearch'
	};

	function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var _context3; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context3 = it.next).call(_context3, it); }

	function _unsupportedIterableToArray$1(o, minLen) { var _context2; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = slice$4(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

	function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	/**
	 * Returns the base url for the live api backend in the desired environment.
	 * @param {string} env The desired environment.
	 */

	function getLiveApiUrl(env) {
	  if (env === void 0) {
	    env = PRODUCTION;
	  }

	  return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi.yext.com';
	}
	/**
	 * Returns the base url for the live api backend in the desired environment.
	 * @param {string} env The desired environment.
	 */

	function getCachedLiveApiUrl(env) {
	  if (env === void 0) {
	    env = PRODUCTION;
	  }

	  return env === SANDBOX ? 'https://liveapi-sandbox.yext.com' : 'https://liveapi-cached.yext.com';
	}
	/**
	 * Returns the base url for the knowledge api backend in the desired environment.
	 * @param {string} env The desired environment.
	 */

	function getKnowledgeApiUrl(env) {
	  if (env === void 0) {
	    env = PRODUCTION;
	  }

	  return env === SANDBOX ? 'https://api-sandbox.yext.com' : 'https://api.yext.com';
	}
	/**
	 * Returns the base url for the analytics backend in the desired environment.
	 * @param {string} env The desired environment.
	 * @param {boolean} conversionTrackingEnabled If conversion tracking has been opted into.
	 */

	function getAnalyticsUrl(env, conversionTrackingEnabled) {
	  if (env === void 0) {
	    env = PRODUCTION;
	  }

	  if (conversionTrackingEnabled === void 0) {
	    conversionTrackingEnabled = false;
	  }

	  if (conversionTrackingEnabled) {
	    return env === SANDBOX ? 'https://sandbox-realtimeanalytics.yext.com' : 'https://realtimeanalytics.yext.com';
	  }

	  return env === SANDBOX ? 'https://sandbox-answers.yext-pixel.com' : 'https://answers.yext-pixel.com';
	}
	/**
	 * Returns the passed in url with the passed in params appended as query params
	 * Note: query parameters in the url are stripped, you should include those query parameters
	 * in `params` if you want to keep them
	 * @param {string} url
	 * @param {SearchParams} params to add to the url
	 * @returns {string}
	 */

	function replaceUrlParams(url, params) {
	  if (params === void 0) {
	    params = new SearchParams();
	  }

	  return url.split('?')[0] + '?' + params.toString();
	}
	/**
	 * Returns the given url without query params and hashes
	 * @param {string} url Full url e.g. https://yext.com/?query=hello#Footer
	 * @returns {string} Url without query params and hashes e.g. https://yext.com/
	 */

	function urlWithoutQueryParamsAndHash(url) {
	  return url.split('?')[0].split('#')[0];
	}
	/**
	 * Creates a copy of the provided {@link SearchParams}, with the specified
	 * attributes filtered out
	 * @param {SearchParams} params The parameters to remove from
	 * @param {string[]} prefixes The prefixes of parameters to remove
	 * @return {SearchParams} A new instance of SearchParams without entries with
	 *   keys that start with the given prefixes
	 */

	function removeParamsWithPrefixes(params, prefixes) {
	  var newParams = new SearchParams();

	  var _loop = function _loop() {
	    var _step2$value = _step2.value,
	        key = _step2$value[0],
	        val = _step2$value[1];

	    var includeEntry = every$2(prefixes).call(prefixes, function (prefix) {
	      return !startsWith$2(key).call(key, prefix);
	    });

	    if (includeEntry) {
	      newParams.set(key, val);
	    }
	  };

	  for (var _iterator2 = _createForOfIteratorHelperLoose$1(entries$2(params).call(params)), _step2; !(_step2 = _iterator2()).done;) {
	    _loop();
	  }

	  return newParams;
	}
	/**
	 * Removes parameters for filters, facets, sort options, and pagination
	 * from the provided {@link SearchParams}. This is useful for constructing
	 * inter-experience answers links.
	 * @param {SearchParams} params The parameters to remove from
	 * @param {function} getComponentNamesForComponentTypes Given string[]
	 *   component types, returns string[] component names for those types
	 * @return {SearchParams} Parameters that have filtered out params that
	 *   should not persist across the answers experience
	 */

	function filterParamsForExperienceLink(params, getComponentNamesForComponentTypes) {
	  var componentTypesToExclude = [ComponentTypes.GEOLOCATION_FILTER, ComponentTypes.FILTER_SEARCH];

	  var paramsToFilter = reduce$2(componentTypesToExclude).call(componentTypesToExclude, function (params, type) {
	    var _context;

	    forEach$2(_context = getComponentNamesForComponentTypes([type])).call(_context, function (componentName) {
	      params.push(StorageKeys.QUERY + "." + componentName);
	      params.push(StorageKeys.FILTER + "." + componentName);
	    });

	    return params;
	  }, []);

	  var newParams = removeParamsWithPrefixes(params, paramsToFilter);
	  var paramsToDelete = [StorageKeys.SEARCH_OFFSET, StorageKeys.PERSISTED_FILTER, StorageKeys.PERSISTED_LOCATION_RADIUS, StorageKeys.PERSISTED_FACETS, StorageKeys.SORT_BYS];

	  forEach$2(paramsToDelete).call(paramsToDelete, function (storageKey) {
	    return newParams["delete"](storageKey);
	  });

	  return newParams;
	}

	function ownKeys$3(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$3(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$3(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	/** @module DOM */

	/* global HTMLElement, HTMLDocument, Window, Element */
	var document$4 = window.document;
	/**
	 * Static interface for interacting with the DOM API.
	 * @namespace
	 */

	var DOM = /*#__PURE__*/function () {
	  function DOM() {}

	  DOM.setup = function setup(d, p) {
	    document$4 = d;
	  }
	  /**
	   * create a HTMLElement from and HTML string
	   * @param {string} html The HTML to parse to a DOM node.
	   * @return {HTMLElement}
	   */
	  ;

	  DOM.create = function create(html) {
	    if ('createRange' in document$4) {
	      // prefer this implementation as it has wider browser support
	      // and it's better performing.
	      // see https://davidwalsh.name/convert-html-stings-dom-nodes
	      var container = document$4.createElement('div');
	      var frag = document$4.createRange().createContextualFragment(html);
	      container.appendChild(frag);
	      return container;
	    } // fallback to this because of a bug in jsdom that causes tests to fail
	    // see: https://github.com/jsdom/jsdom/issues/399


	    return new DOMParser().parseFromString(html, 'text/html').body;
	  }
	  /**
	   * query the DOM for a given css selector
	   * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
	   * @param {string} selector the CSS selector to query for
	   *
	   * @returns {HTMLElement} the FIRST node it finds, if any
	   */
	  ;

	  DOM.query = function query(parent, selector) {
	    // Facade, shifting the selector to the parent argument if only one
	    // argument is provided
	    if (selector === undefined) {
	      selector = parent;
	      parent = document$4;
	    }

	    if (selector instanceof HTMLElement || selector instanceof Window || selector instanceof HTMLDocument) {
	      return selector;
	    }

	    return parent.querySelector(selector);
	  }
	  /**
	   * query the DOM for a given css selector
	   * @param {HTMLElement} parent Optional context to use for a search. Defaults to document if not provided.
	   * @param {string} selector the CSS selector to query for
	   *
	   * @returns {Array} the FIRST node it finds, if any
	   */
	  ;

	  DOM.queryAll = function queryAll(parent, selector) {
	    // Facade, shifting the selector to the parent argument if only one
	    // argument is provided
	    if (selector === undefined) {
	      selector = parent;
	      parent = document$4;
	    } // handle the case where client code is using a pointer to a dom node and it's null, e.g. this._container


	    if (parent == null) {
	      parent = document$4;
	    }

	    if (selector instanceof HTMLElement || selector instanceof HTMLDocument || selector instanceof Window) {
	      return [selector];
	    }

	    return from_1$2(parent.querySelectorAll(selector));
	  };

	  DOM.onReady = function onReady(cb) {
	    if (document$4.readyState === 'complete' || document$4.readyState === 'loaded' || document$4.readyState === 'interactive') {
	      cb();
	      return;
	    }

	    DOM.on(document$4, 'DOMContentLoaded', cb);
	  }
	  /**
	   * createEle will create a {HTMLElement} and apply the properties attributes through an object provided.
	   * @param {string} el The element `tag` name to construct
	   * @param {Object} opts_data Optional attributes to apply to the new HTMLElement
	   */
	  ;

	  DOM.createEl = function createEl(el, opts_data) {
	    if (opts_data === void 0) {
	      opts_data = {};
	    }

	    var node = document$4.createElement(el);

	    var props = keys$3(opts_data);

	    for (var i = 0; i < props.length; i++) {
	      if (props[i] === 'class') {
	        DOM.addClass(node, opts_data[props[i]]);
	        continue;
	      }

	      node[props[i]] = opts_data[props[i]];
	    }

	    return node;
	  };

	  DOM.append = function append(parent, node) {
	    if (node === undefined) {
	      node = parent;
	      parent = document$4;
	    }

	    if (typeof parent === 'string') {
	      parent = DOM.query(parent);
	    } // Support HTML injection as well as HTMLElement appends


	    if (typeof node === 'string') {
	      parent.insertAdjacentHTML('afterBegin', node);
	    } else {
	      parent.appendChild(node);
	    }
	  };

	  DOM.addClass = function addClass(node, className) {
	    if (!node) {
	      return;
	    }

	    var classes = className.split(',');
	    var len = classes.length;

	    for (var i = 0; i < len; i++) {
	      node.classList.add(classes[i]);
	    }
	  }
	  /**
	   * Removes classes from a specified element.
	   * @param {HTMLElement} node The html element to be acted upon
	   * @param {string} className A css class to be removed
	   */
	  ;

	  DOM.removeClass = function removeClass(node, className) {
	    if (!node) {
	      return;
	    }

	    node.classList.remove(className);
	  };

	  DOM.empty = function empty(parent) {
	    parent.innerHTML = '';
	  };

	  DOM.css = function css(selector, styles) {
	    var node = DOM.query(selector);

	    for (var prop in styles) {
	      node.style[prop] = styles[prop];
	    }
	  };

	  DOM.attr = function attr(selector, _attr, val) {
	    DOM.query(selector).setAttribute(_attr, val);
	  };

	  DOM.attributes = function attributes(selector, attrs) {
	    var _context,
	        _this = this;

	    forEach$2(_context = entries$5(attrs)).call(_context, function (_ref) {
	      var attr = _ref[0],
	          val = _ref[1];
	      return _this.attr(selector, attr, val);
	    });
	  };

	  DOM.trigger = function trigger(selector, event, settings) {
	    var e = DOM._customEvent(event, settings);

	    DOM.query(selector).dispatchEvent(e);
	  } // TODO (agrow) investigate removing this
	  // Event constructor polyfill
	  ;

	  DOM._customEvent = function _customEvent(event, settings) {
	    var _settings = _objectSpread$2({
	      bubbles: true,
	      cancelable: true,
	      detail: null
	    }, settings);

	    var evt = document$4.createEvent('CustomEvent');
	    evt.initCustomEvent(event, _settings.bubbles, _settings.cancelable, _settings.detail);
	    return evt;
	  };

	  DOM.on = function on(selector, evt, handler) {
	    DOM.query(selector).addEventListener(evt, handler);
	  };

	  DOM.once = function once(selector, evt, handler) {
	    DOM.query(selector).addEventListener(evt, handler, {
	      once: true
	    });
	  };

	  DOM.off = function off(selector, evt, handler) {
	    DOM.query(selector).removeEventListener(evt, handler);
	  };

	  DOM.delegate = function delegate(ctxt, selector, evt, handler) {
	    var el = DOM.query(ctxt);
	    el.addEventListener(evt, function (event) {
	      var target = event.target;

	      while (!target.isEqualNode(el)) {
	        if (DOM.matches(target, selector)) {
	          handler(event, target);
	          break;
	        }

	        target = target.parentNode;
	      }
	    });
	  } // TODO (agrow) investigate removing this
	  // Element.matches polyfill
	  ;

	  DOM.matches = function matches(element, potentialMatch) {
	    if (Element.prototype.matches) {
	      return element.matches(potentialMatch);
	    }

	    if (Element.prototype.msMatchesSelector) {
	      return element.msMatchesSelector(potentialMatch);
	    }

	    if (Element.prototype.webkitMatchesSelector) {
	      return element.webkitMatchesSelector(potentialMatch);
	    }
	  };

	  return DOM;
	}();

	/** @module Renderer */

	/**
	 * Renderer is an abstract class that all Renderers should extend and implement
	 */
	var Renderer = /*#__PURE__*/function () {
	  function Renderer() {}

	  var _proto = Renderer.prototype;

	  /**
	   * render is a core method for all renderers.
	   * All implementations should override this class
	   * @param {string} template
	   * @param {object} data
	   */
	  _proto.render = function render(template, data) {
	    return template;
	  };

	  _proto.registerHelper = function registerHelper(name, cb) {};

	  _proto.registerTemplate = function registerTemplate(templateName, template) {};

	  _proto.compile = function compile(template) {};

	  return Renderer;
	}();

	var trim$4 = stringTrim.trim;


	var $parseInt = global_1.parseInt;
	var hex = /^[+-]?0[Xx]/;
	var FORCED$7 = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	var numberParseInt = FORCED$7 ? function parseInt(string, radix) {
	  var S = trim$4(String(string));
	  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
	} : $parseInt;

	// `parseInt` method
	// https://tc39.es/ecma262/#sec-parseint-string-radix
	_export({ global: true, forced: parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var _parseInt = path.parseInt;

	var _parseInt$1 = _parseInt;

	var _parseInt$2 = _parseInt$1;

	var $some = arrayIteration.some;


	var STRICT_METHOD$5 = arrayMethodIsStrict('some');

	// `Array.prototype.some` method
	// https://tc39.es/ecma262/#sec-array.prototype.some
	_export({ target: 'Array', proto: true, forced: !STRICT_METHOD$5 }, {
	  some: function some(callbackfn /* , thisArg */) {
	    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var some = entryVirtual('Array').some;

	var ArrayPrototype$e = Array.prototype;

	var some_1 = function (it) {
	  var own = it.some;
	  return it === ArrayPrototype$e || (it instanceof Array && own === ArrayPrototype$e.some) ? some : own;
	};

	var some$1 = some_1;

	var some$2 = some$1;

	var SVGIcon = /*#__PURE__*/function () {
	  /**
	   * @param config
	   * @param config.name
	   * @param config.path
	   * @param config.complexContents
	   * @param config.viewBox
	   * @constructor
	   */
	  function SVGIcon(config) {
	    /**
	     * the name of the icon
	     */
	    this.name = config.name;
	    /**
	     * an svg path definition
	     */

	    this.path = config.path;
	    /**
	     * if not using a path, a the markup for a complex SVG
	     */

	    this.complexContents = config.complexContents;
	    /**
	     * the view box definition, defaults to 24x24
	     * @type {string}
	     */

	    this.viewBox = config.viewBox || '0 0 24 24';
	    /**
	     * actual contents used
	     */

	    this.contents = this.pathDefinition();
	  }

	  var _proto = SVGIcon.prototype;

	  _proto.pathDefinition = function pathDefinition() {
	    if (this.complexContents) {
	      return this.complexContents;
	    }

	    return "<path d=\"" + this.path + "\"></path>";
	  };

	  _proto.parseContents = function parseContents(complexContentsParams) {
	    var contents = this.contents;

	    if (typeof contents === 'function') {
	      contents = contents(complexContentsParams);
	    }

	    return "<svg viewBox=\"" + this.viewBox + "\" xmlns=\"http://www.w3.org/2000/svg\">" + contents + "</svg>";
	  }
	  /**
	   * returns the svg markup
	   */
	  ;

	  _proto.markup = function markup() {
	    var _this = this;

	    if (typeof this.contents === 'function') {
	      return function (complexContentsParams) {
	        return _this.parseContents(complexContentsParams);
	      };
	    }

	    return this.parseContents();
	  };

	  return SVGIcon;
	}();

	var thumbIcon = new SVGIcon({
	  name: 'thumb',
	  viewBox: '0 0 24 22',
	  path: 'M15.273 1H5.455c-.906 0-1.68.55-2.008 1.342L.153 10.097A2.19 2.19 0 000 10.9v2.2c0 1.21.982 2.2 2.182 2.2h6.883L8.03 20.327l-.033.352c0 .451.186.869.48 1.166L9.633 23l7.178-7.249a2.16 2.16 0 00.644-1.551v-11c0-1.21-.982-2.2-2.182-2.2zm0 13.2l-4.735 4.774L11.75 13.1H2.182v-2.2l3.273-7.7h9.818v11zM19.636 1H24v13.2h-4.364V1z'
	});

	var receiptIcon = new SVGIcon({
	  name: 'receipt',
	  path: 'M14.606 9.5c-.671-.515-1.591-.833-2.606-.833 1.015 0 1.935.318 2.606.833zm-7.985 0H1.655A1.66 1.66 0 010 7.833V3.667C0 2.747.741 2 1.655 2h20.69A1.66 1.66 0 0124 3.667v4.166A1.66 1.66 0 0122.345 9.5h-4.966V22H6.621V9.5h2.773H6.62zm10.758-1.667h4.966V3.667H1.655v4.166h4.966v-2.5h10.758v2.5z'
	});

	var pantheonIcon = new SVGIcon({
	  name: 'pantheon',
	  path: 'M9.947 16.598h.252V9.412h-.252a.432.432 0 01-.23-.065c-.07-.043-.106-.093-.106-.15L9.15 7.82v-.15c0-.044.028-.08.084-.109a.691.691 0 01.105-.086.254.254 0 01.146-.043H13.6c.056 0 .104.015.146.043.042.03.091.058.147.086a.271.271 0 01.063.108c.014.043.007.093-.02.15l-.42 1.378a.374.374 0 01-.147.15.37.37 0 01-.19.065h-.251v7.186h.252a.37.37 0 01.189.065c.07.043.119.093.147.15l.42 1.378c.027.028.034.071.02.129a.275.275 0 01-.063.129 1.364 1.364 0 00-.147.086.254.254 0 01-.146.043H9.485a.254.254 0 01-.146-.043.691.691 0 01-.105-.086c-.056-.029-.084-.072-.084-.13v-.128l.461-1.377c0-.058.035-.108.105-.151a.432.432 0 01.231-.065zm5.792 0h.252V9.412h-.252a.432.432 0 01-.23-.065.374.374 0 01-.148-.15l-.42-1.377c-.027-.029-.034-.072-.02-.13a.275.275 0 01.063-.129c.056-.028.105-.057.146-.086a.254.254 0 01.147-.043h4.114c.055 0 .104.015.146.043a.691.691 0 01.105.086c.056.03.084.072.084.13v.129l-.42 1.377a.374.374 0 01-.146.15.432.432 0 01-.231.065h-.21v7.186h.21a.43.43 0 01.23.065c.07.043.12.093.148.15l.42 1.378v.15c0 .043-.029.08-.085.108a.691.691 0 01-.105.086.254.254 0 01-.146.043h-4.114a.254.254 0 01-.147-.043 1.364 1.364 0 00-.146-.086.271.271 0 01-.063-.108c-.014-.043-.007-.093.02-.15l.42-1.377a.374.374 0 01.147-.151.432.432 0 01.231-.065zm-11.794-.086h.252V9.498h-.252a.334.334 0 01-.21-.065.386.386 0 01-.126-.193l-.42-1.377a.248.248 0 01-.02-.172.854.854 0 01.063-.173c.028-.057.07-.1.126-.129a.365.365 0 01.168-.043h4.07c.057 0 .113.015.169.043a.278.278 0 01.126.13.854.854 0 01.062.172.248.248 0 01-.02.172l-.42 1.377a.386.386 0 01-.126.193.334.334 0 01-.21.065h-.21v7.014h.21c.084 0 .154.029.21.086a.673.673 0 01.126.172l.42 1.378a.248.248 0 01.02.172.854.854 0 01-.062.172.278.278 0 01-.126.129.365.365 0 01-.168.043H3.526a.365.365 0 01-.168-.043.278.278 0 01-.126-.13.854.854 0 01-.063-.171.248.248 0 01.02-.172l.42-1.378a.673.673 0 01.126-.172.281.281 0 01.21-.086zM1.763 6.658a.717.717 0 01-.504-.194.644.644 0 01-.21-.495v-.43a.73.73 0 01.105-.387.68.68 0 01.273-.259C4.309 3.402 6.54 2.276 8.121 1.515 9.702.755 10.493.361 10.493.332c.531-.258.972-.366 1.322-.323.35.043.734.165 1.154.366l8.31 4.518c.14.058.245.144.315.259a.73.73 0 01.105.387v.43c0 .201-.07.366-.21.495a.717.717 0 01-.504.194H1.763zm-.714 13.34a.54.54 0 01.168-.387.516.516 0 01.378-.172h19.642c.168 0 .308.057.42.172a.541.541 0 01.168.387v.818a.522.522 0 01-.168.408.605.605 0 01-.42.151H1.595a.551.551 0 01-.378-.15.522.522 0 01-.168-.41v-.817zm21.405 2.022c.14 0 .266.058.378.173a.592.592 0 01.168.43v.818a.541.541 0 01-.168.387.516.516 0 01-.378.172L.546 23.957a.516.516 0 01-.378-.172.541.541 0 01-.168-.387v-.818a.59.59 0 01.168-.43.516.516 0 01.378-.173l21.908.043z'
	});

	var micIcon = new SVGIcon({
	  name: 'mic',
	  path: 'M12 15c1.66 0 2.99-1.34 2.99-3L15 6c0-1.66-1.34-3-3-3S9 4.34 9 6v6c0 1.66 1.34 3 3 3zm5.3-3c0 3-2.54 5.1-5.3 5.1S6.7 15 6.7 12H5c0 3.41 2.72 6.23 6 6.72V22h2v-3.28c3.28-.48 6-3.3 6-6.72h-1.7z'
	});

	var directionsIcon = new SVGIcon({
	  name: 'directions',
	  path: 'M23.649 11.154L12.846.35a1.195 1.195 0 00-1.692 0L.35 11.154a1.195 1.195 0 000 1.692L11.154 23.65a1.195 1.195 0 001.692 0L23.65 12.846c.468-.456.468-1.212 0-1.692zm-9.254 3.853v-3.001H9.593v3.6h-2.4v-4.8c0-.66.54-1.2 1.2-1.2h6.002V6.604l4.2 4.2-4.2 4.202z'
	});

	var calendarIcon = new SVGIcon({
	  name: 'calendar',
	  path: 'M18.111 13.2H12v6h6.111v-6zM16.89 0v2.4H7.11V0H4.667v2.4H3.444c-1.356 0-2.432 1.08-2.432 2.4L1 21.6C1 22.92 2.088 24 3.444 24h17.112C21.9 24 23 22.92 23 21.6V4.8c0-1.32-1.1-2.4-2.444-2.4h-1.223V0H16.89zm3.667 21.6H3.444V8.4h17.112v13.2z'
	});

	var calloutIcon = new SVGIcon({
	  name: 'callout',
	  path: 'M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18z'
	});

	var infoIcon = new SVGIcon({
	  name: 'info',
	  path: 'M12 8.4A1.2 1.2 0 1012 6a1.2 1.2 0 000 2.4zM12 0c6.624 0 12 5.376 12 12s-5.376 12-12 12S0 18.624 0 12 5.376 0 12 0zm0 18c.66 0 1.2-.54 1.2-1.2V12c0-.66-.54-1.2-1.2-1.2-.66 0-1.2.54-1.2 1.2v4.8c0 .66.54 1.2 1.2 1.2z'
	});

	var briefcaseIcon = new SVGIcon({
	  name: 'briefcase',
	  path: 'M20 7h-4V5c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 20c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V9c0-1.11-.89-2-2-2zm-6 0h-4V5h4v2z'
	});

	var kabobIcon = new SVGIcon({
	  name: 'kabob',
	  viewBox: '0 0 3 11',
	  complexContents: '<circle cx="1.5" cy="1.5" r="1.5"/><circle cx="1.5" cy="5.5" r="1.5"/><circle cx="1.5" cy="9.5" r="1.5"/>'
	});

	var personIcon = new SVGIcon({
	  name: 'person',
	  viewBox: '0 0 18 18',
	  path: 'M9 9c2.486 0 4.5-2.014 4.5-4.5S11.486 0 9 0a4.499 4.499 0 00-4.5 4.5C4.5 6.986 6.514 9 9 9zm0 2.25c-3.004 0-9 1.508-9 4.5v1.125C0 17.494.506 18 1.125 18h15.75c.619 0 1.125-.506 1.125-1.125V15.75c0-2.992-5.996-4.5-9-4.5z'
	});

	var magnifyingGlassIcon = new SVGIcon({
	  name: 'magnifying_glass',
	  path: 'M16.124 13.051a5.154 5.154 0 110-10.308 5.154 5.154 0 010 10.308M16.114 0a7.886 7.886 0 00-6.46 12.407L0 22.06 1.94 24l9.653-9.653A7.886 7.886 0 1016.113 0'
	});

	var officeIcon = new SVGIcon({
	  name: 'office',
	  path: 'M12 7V3H2v18h20V7H12zM6 19H4v-2h2v2zm0-4H4v-2h2v2zm0-4H4V9h2v2zm0-4H4V5h2v2zm4 12H8v-2h2v2zm0-4H8v-2h2v2zm0-4H8V9h2v2zm0-4H8V5h2v2zm10 12h-8v-2h2v-2h-2v-2h2v-2h-2V9h8v10zm-2-8h-2v2h2v-2zm0 4h-2v2h2v-2z'
	});

	var linkIcon = new SVGIcon({
	  name: 'link',
	  path: 'M2.28 12A3.723 3.723 0 016 8.28h4.8V6H6c-3.312 0-6 2.688-6 6s2.688 6 6 6h4.8v-2.28H6A3.723 3.723 0 012.28 12zm4.92 1.2h9.6v-2.4H7.2v2.4zM18 6h-4.8v2.28H18A3.723 3.723 0 0121.72 12 3.723 3.723 0 0118 15.72h-4.8V18H18c3.312 0 6-2.688 6-6s-2.688-6-6-6z'
	});

	var windowIcon = new SVGIcon({
	  name: 'window',
	  path: 'M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z'
	});

	var phoneIcon = new SVGIcon({
	  name: 'phone',
	  path: 'M4.827 10.387a20.198 20.198 0 008.786 8.786l2.934-2.933c.36-.36.893-.48 1.36-.32a15.21 15.21 0 004.76.76c.733 0 1.333.6 1.333 1.333v4.654C24 23.4 23.4 24 22.667 24 10.147 24 0 13.853 0 1.333 0 .6.6 0 1.333 0H6c.733 0 1.333.6 1.333 1.333 0 1.667.267 3.267.76 4.76.147.467.04.987-.333 1.36l-2.933 2.934z'
	});

	var tagIcon = new SVGIcon({
	  name: 'tag',
	  viewBox: '0 0 18 18',
	  path: 'M17.469 8.622l-8.1-8.1A1.789 1.789 0 008.1 0H1.8C.81 0 0 .81 0 1.8v6.3c0 .495.198.945.531 1.278l8.1 8.1c.324.324.774.522 1.269.522a1.76 1.76 0 001.269-.531l6.3-6.3A1.76 1.76 0 0018 9.9c0-.495-.207-.954-.531-1.278zM3.15 4.5c-.747 0-1.35-.603-1.35-1.35 0-.747.603-1.35 1.35-1.35.747 0 1.35.603 1.35 1.35 0 .747-.603 1.35-1.35 1.35z'
	});

	var documentIcon = new SVGIcon({
	  name: 'document',
	  path: 'M4 6H2v14c0 1.1.9 2 2 2h14v-2H4V6zm16-4H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-1 9H9V9h10v2zm-4 4H9v-2h6v2zm4-8H9V5h10v2z'
	});

	var chevronIcon = new SVGIcon({
	  name: 'chevron',
	  viewBox: '0 0 7 9',
	  complexContents: '<g fill-rule="evenodd" transform="translate(-1 -8)"><path d="m2.6417004 8-1.1417004 1.0575 3.70850202 3.4425-3.70850202 3.4425 1.1417004 1.0575 4.8582996-4.5z"/></g>'
	});

	var supportIcon = new SVGIcon({
	  name: 'support',
	  path: 'M12,0 C5.376,0 0,5.376 0,12 C0,18.624 5.376,24 12,24 C18.624,24 24,18.624 24,12 C24,5.376 18.624,0 12,0 Z M13,19 L11,19 L11,17 L13,17 L13,19 Z M15.07,11.25 L14.17,12.17 C13.45,12.9 13,13.5 13,15 L11,15 L11,14.5 C11,13.4 11.45,12.4 12.17,11.67 L13.41,10.41 C13.78,10.05 14,9.55 14,9 C14,7.9 13.1,7 12,7 C10.9,7 10,7.9 10,9 L8,9 C8,6.79 9.79,5 12,5 C14.21,5 16,6.79 16,9 C16,9.88 15.64,10.68 15.07,11.25 Z'
	});

	var yextIcon = new SVGIcon({
	  name: 'yext',
	  viewBox: '0 0 30 30',
	  path: 'M25.517 28.142v.095h-.204v.905h-.066v-.905h-.197v-.095h.467zm.667 0h.066v1h-.066v-.825l-.24.595h-.013l-.24-.595v.825h-.066v-1h.066l.247.61.246-.61zM15 28.8c7.622 0 13.8-6.178 13.8-13.8 0-7.622-6.178-13.8-13.8-13.8C7.378 1.2 1.2 7.378 1.2 15c0 7.622 6.178 13.8 13.8 13.8zM15 0c8.284 0 15 6.716 15 15 0 8.284-6.716 15-15 15-8.284 0-15-6.716-15-15C0 6.716 6.716 0 15 0zm.45 16.65v-1.2h6.6v1.2h-2.7v5.4h-1.2v-5.4h-2.7zm-1.599-1.35l.849.849-2.601 2.601 2.601 2.601-.849.849-2.601-2.601L8.649 22.2l-.849-.849 2.601-2.601L7.8 16.149l.849-.849 2.601 2.601 2.601-2.601zM18.675 9a2.175 2.175 0 00-1.847 3.323l2.995-2.995A2.163 2.163 0 0018.675 9zm0 5.55a3.375 3.375 0 112.833-5.209l-3.789 3.788a2.175 2.175 0 003.13-1.954h1.201a3.375 3.375 0 01-3.375 3.375zm-7.425-3.734L13.78 7.8l.92.771-2.85 3.397v2.582h-1.2v-2.582L7.8 8.57l.92-.771 2.53 3.016z'
	});

	var pinIcon = new SVGIcon({
	  name: 'pin',
	  viewBox: '5 0 9 18',
	  path: 'm9.375 0c-3.52446429 0-6.375 2.817-6.375 6.3 0 4.725 6.375 11.7 6.375 11.7s6.375-6.975 6.375-11.7c0-3.483-2.8505357-6.3-6.375-6.3zm.00000018 8.55000007c-1.25678576 0-2.27678579-1.008-2.27678579-2.25s1.02000003-2.25 2.27678579-2.25c1.25678572 0 2.27678582 1.008 2.27678582 2.25s-1.0200001 2.25-2.27678582 2.25z'
	});

	var gearIcon = new SVGIcon({
	  name: 'gear',
	  path: 'M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5a2 2 0 00-2 2v14a2 2 0 002 2h14a2 2 0 002-2V5a2 2 0 00-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42a.353.353 0 01.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16a.353.353 0 01-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z'
	});

	var lightBulbIcon = new SVGIcon({
	  name: 'light_bulb',
	  viewBox: '0 0 32 35',
	  path: 'M11.585 31.056l8.38-.493v-.986l-8.38.493zM11.585 33.028L15.775 35l4.19-1.972V31.55l-8.38.493v.986zm6.926-.407l-2.736 1.29-2.13-1.004 4.866-.286zM15.775 7.394c-4.63 0-8.38 3.205-8.38 8.38 0 5.177 4.19 6.902 4.19 12.818v.493l8.38-.493c0-5.916 4.19-8.188 4.19-12.817a8.38 8.38 0 00-8.38-8.38zm5.617 13.48c-1.025 1.837-2.174 3.892-2.381 6.786l-6.44.38c-.129-3.01-1.29-5.021-2.32-6.808-.493-.8-.928-1.636-1.299-2.5h13.556c-.325.708-.704 1.403-1.116 2.142zm1.479-3.128H8.627a7.793 7.793 0 01-.247-1.971c0-4.353 3.042-7.395 7.395-7.395a7.394 7.394 0 017.394 7.395 6.739 6.739 0 01-.3 1.971h.002zM26.62 15.282h4.93v1h-4.93zM23.094 7.756l2.091-2.091.698.697-2.092 2.092zM15.282 0h1v4.93h-1zM5.666 6.362l.697-.697 2.091 2.091-.697.697zM0 15.282h4.93v1H0z'
	});

	var starIcon = new SVGIcon({
	  name: 'star',
	  viewBox: '0 0 18 18',
	  path: 'M8.991 0C4.023 0 0 4.032 0 9s4.023 9 8.991 9C13.968 18 18 13.968 18 9s-4.032-9-9.009-9zm3.816 14.4L9 12.105 5.193 14.4l1.008-4.329-3.357-2.907 4.428-.378L9 2.7l1.728 4.077 4.428.378-3.357 2.907z'
	});

	var close = new SVGIcon({
	  name: 'close',
	  viewBox: '0 1 24 24',
	  complexContents: "\n    <path d=\"M7 8l9.716 9.716m0-9.716L7 17.716\"\n          stroke=\"currentColor\"\n          stroke-width=\"2\"/>\n  "
	});

	var elements = new SVGIcon({
	  name: 'elements',
	  path: 'M13,15 L13,17 L21,17 L21,19 L13,19 L13,21 L11,21 L11,15 L13,15 Z M9,17 L9,19 L3,19 L3,17 L9,17 Z M9,15 L7,15 L7,13 L3,13 L3,11 L7,11 L7,9 L9,9 L9,15 Z M21,11 L21,13 L11,13 L11,11 L21,11 Z M17,3 L17,5 L21,5 L21,7 L17,7 L17,9 L15,9 L15,3 L17,3 Z M13,5 L13,7 L3,7 L3,5 L13,5 Z'
	});

	var yextAnimatedForward = new SVGIcon({
	  name: 'yext_animated_reverse',
	  viewBox: '0 0 72 72',
	  complexContents: function complexContents(params) {
	    if (params === void 0) {
	      params = {};
	    }

	    var iconPrefix = params.iconPrefix || 'yxt';
	    return "<defs>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-1\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-2\">\n        <rect x=\"-144.3\" y=\"144.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-3\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M489.8 277.4c0 0 78 18.8 78 18.8c0 0-96.1 61.5-96.1 61.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-13.9 14-13.9 14m-67.8-108.1c0 0 73.9 1.3 73.9 1.3c0 0-33.8 54.5-33.8 54.5c0 0 18.6-3.2 18.6-3.2c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-32.1 9.8-32.1 9.8\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-4\">\n        <rect x=\"-91.1\" y=\"91.1\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-5\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M488.4 291.4c0 0 40.5 39.3 40.5 39.3c0 0-57.2 27-57.2 27c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-15.3 28-15.3 28m-90.5-97.4c0 0 52-11.3 52-11.3c0 0-6 45.2-6 45.2c0 0 36.8-6 36.8-6c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-56.2 34.5-56.2 34.5\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-6\">\n        <rect x=\"-61.3\" y=\"61.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-7\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M481.8 298.4c0 0 27.5 39.8 27.5 39.8c0 0-37.6 19.5-37.6 19.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-21.9 35-21.9 35m-108.1-79.7c0 0 30.2-23.8 30.2-23.8c0 0 21.7 35.9 21.7 35.9c0 0 55.1-8.9 55.1-8.9c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-80.4 59.2-80.4 59.2\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-8\">\n        <rect x=\"-42.6\" y=\"42.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-9\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M475.2 305.4c0 0 14.5 40.3 14.5 40.3c0 0-18 12-18 12c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-28.5 42-28.5 42m-113.6-74.3c0 0 17.9-18.5 17.9-18.5c0 0 36.4 25.3 36.4 25.3c0 0 64.8-16 64.8-16c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-10\">\n        <rect x=\"-29.6\" y=\"29.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-11\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M468.6 312.4c0 0 1.5 40.8 1.5 40.8c0 0 1.6 4.5 1.6 4.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-35.1 49-35.1 49m-107-81.3c0 0 15.1 4.9 15.1 4.9c0 0 38.2 13.3 38.2 13.3c0 0 65.8-27.4 65.8-27.4c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-12\">\n        <rect x=\"-20.3\" y=\"20.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-13\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M456.6 311.9c0 0-7 35.6-7 35.6c0 0 22.1 10.2 22.1 10.2c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-47.1 48.5-47.1 48.5m-95-80.8c0 0 12.3 28.3 12.3 28.3c0 0 39.9 1.3 39.9 1.3c0 0 66.9-38.8 66.9-38.8c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-14\">\n        <rect x=\"-13.4\" y=\"13.4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-15\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M444.6 311.4c0 0-15.6 30.5-15.6 30.5c0 0 42.7 15.8 42.7 15.8c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-59.1 48-59.1 48m-83-80.3c0 0 9.5 51.7 9.5 51.7c0 0 41.7-10.8 41.7-10.8c0 0 67.9-50.1 67.9-50.1c0 0 50.6-31.9 50.6-31.9c0 0-77.2-30.5-77.2-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-16\">\n        <rect x=\"-7.3\" y=\"7.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-17\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-18\">\n        <rect x=\"-4\" y=\"4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-19\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_reverse_Mask-20\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <clipPath id=\"" + iconPrefix + "_reverse_ClipPath-1\">\n        <rect width=\"720\" height=\"720\" />\n      </clipPath>\n    </defs>\n    <g transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_reverse_Mask-1)\">\n        <path d=\"M377.5 395.3c0 0 64.8 0 64.8 0c0 0 0 129.6 0 129.6c0 0 28.8 0 28.8 0c0 0 0-129.6 0-129.6c0 0 64.8 0 64.8 0c0 0 0-28.8 0-28.8c0 0-158.4 0-158.4 0c0 0 0 28.8 0 28.8Z\" />\n        <path d=\"M338.9 363.6c0 0-62.5 62.4-62.5 62.4c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 62.4-62.4 62.4-62.4c0 0-20.3-20.4-20.3-20.4Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-60.7-72.8-60.7-72.8c0 0-22.1 18.6-22.1 18.6c0 0 68.4 82 68.4 82c0 0 0 62.4 0 62.4c0 0 28.8 0 28.8 0c0 0 0-62.6 0-62.6c0 0 68.4-81.8 68.4-81.8c0 0-22-18.6-22-18.6c0 0-60.8 72.8-60.8 72.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-353.7c195.2 0 353.7 158.5 353.7 353.7c0 195.2-158.5 353.7-353.7 353.7c-195.2 0-353.7-158.5-353.7-353.7c0-195.2 158.5-353.7 353.7-353.7Z\" fill=\"none\" transform=\"translate(359.8,360.4) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-2)\" transform=\"translate(144.3,-144.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-3)\">\n        <path d=\"M390.6 395.2c0 0 51.7 .1 51.7 .1c0 0 .1 103.6 .1 103.6c0 0 28.7 0 28.7 0c0 0 0-103.6 0-103.6c0 0 52-0.1 52-0.1c0 0 0-28.4 0-28.4c0 0-132.5 0-132.5 0c0 0 0 28.4 0 28.4Z\" />\n        <path d=\"M329 373.4c0 .1-52.6 52.6-52.6 52.6c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 52.6-52.6 52.6-52.6c0 0-20.4-20.3-20.4-20.3Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-48.7-58.3-48.7-58.3c0 0-21.1 19-21.1 19c0 0 55.5 67.2 55.5 67.2c0 0 .3 50 .3 50c0 0 28.4 0 28.4 0c0 0 0-50.3 0-50.3c0 0 55.4-66.9 55.4-66.9c0 0-21-18.6-21-18.6c0 0-48.8 57.9-48.8 57.9Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-336.2c185.6 0 336.2 150.6 336.2 336.2c0 185.6-150.6 336.2-336.2 336.2c-185.6 0-336.2-150.6-336.2-336.2c0-185.6 150.6-336.2 336.2-336.2Z\" fill=\"none\" display=\"block\" transform=\"translate(370.8,347.5) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_reverse_Mask-4)\" transform=\"translate(91.1,-91.1)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#" + iconPrefix + "_reverse_Mask-5)\">\n        <path d=\"M409.7 395.1c0 0 32.6 .2 32.6 .2c0 0 .3 65.5 .3 65.5c0 0 28.5 0 28.5 0c0 0 0-65.5 0-65.5c0 0 33.1-0.2 33.1-0.2c0 0 0-27.8 0-27.8c0 0-94.5 0-94.5 0c0 0 0 27.8 0 27.8Z\" />\n        <path d=\"M319.7 382.8c0 0-43.3 43.2-43.3 43.2c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 43.4-43.3 43.4-43.3c0 0-20.5-20.3-20.5-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l69.8-69.9l.3-0.2l-20.3-20.4l-71.2 71.1c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-31.1-37-31.1-37c0 0-19.7 19.5-19.7 19.5c0 0 36.7 45.6 36.7 45.6c0 0 .7 31.8 .7 31.8c0 0 27.7 0 27.7 0c0 0 0-32.4 0-32.4c0 0 36.5-44.9 36.5-44.9c0 0-19.6-18.6-19.6-18.6c0 0-31.2 36-31.2 36Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-310c171.1 0 310 138.9 310 310c0 171.1-138.9 310-310 310c-171.1 0-310-138.9-310-310c0-171.1 138.9-310 310-310Z\" fill=\"none\" transform=\"translate(387.8,328.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-6)\" transform=\"translate(61.3,-61.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#" + iconPrefix + "_reverse_Mask-7)\">\n        <path d=\"M420.4 395c0 0 21.9 .3 21.9 .3c0 0 .4 44.1 .4 44.1c0 0 28.4 0 28.4 0c0 0 0-44.1 0-44.1c0 0 22.6-0.3 22.6-0.3c0 0 0-27.5 0-27.5c0 0-73.3 0-73.3 0c0 0 0 27.5 0 27.5Z\" />\n        <path d=\"M313.2 389.2c0 0-36.8 36.8-36.8 36.8c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 37-36.9 37-36.9c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M500 200c-13.4-9.9-27.2-16.2-45.3-16.2c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l57.7-57.7l-20.3-20.4l-58.8 58.7c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-21.2-25.1-21.2-25.1c0 0-19 19.8-19 19.8c0 0 26.2 33.5 26.2 33.5c0 0 1 21.6 1 21.6c0 0 27.2 0 27.2 0c0 0 0-22.3 0-22.3c0 0 25.9-32.7 25.9-32.7c0 0-18.8-18.6-18.8-18.6c0 0-21.3 23.8-21.3 23.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-294.3c162.4 0 294.3 131.9 294.3 294.3c0 162.4-131.9 294.3-294.3 294.3c-162.4 0-294.3-131.9-294.3-294.3c0-162.4 131.9-294.3 294.3-294.3Z\" fill=\"none\" display=\"block\" transform=\"translate(398.7,318.2) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_reverse_Mask-8)\" transform=\"translate(42.6,-42.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-9)\">\n        <path d=\"M427.2 394.9c0 0 15.1 .4 15.1 .4c0 0 .4 30.7 .4 30.7c0 0 28.4 0 28.4 0c0 0 0-30.7 0-30.7c0 0 15.9-0.4 15.9-0.4c0 0 0-27.2 0-27.2c0 0-59.8 0-59.8 0c0 0 0 27.2 0 27.2Z\" />\n        <path d=\"M307.4 395c0 0-31 31-31 31c0 0-53.9-54-53.9-54c0 0-20.4 20.4-20.4 20.4c0 0 54 54 54 54c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 54 54 54 54c0 0 20.4-20.3 20.4-20.3c0 0-54-54.1-54-54.1c0 0 31.2-31.1 31.2-31.1c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l45.5-45.5l-20.4-20.4l-46.5 46.5c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-15-17.6-15-17.6c0 0-18.4 20-18.4 20c0 0 19.4 25.8 19.4 25.8c0 0 1.2 15.2 1.2 15.2c0 0 27 0 27 0c0 0 0-15.9 0-15.9c0 0 19.1-24.9 19.1-24.9c0 0-18.2-18.7-18.2-18.7c0 0-15.1 16.1-15.1 16.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-284.4c157 0 284.4 127.4 284.4 284.4c0 157-127.4 284.4-284.4 284.4c-157 0-284.4-127.4-284.4-284.4c0-157 127.4-284.4 284.4-284.4Z\" fill=\"none\" transform=\"translate(406.1,311.6) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-10)\" transform=\"translate(29.6,-29.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-11)\">\n        <path d=\"M436 393.5c0 0 8.7 .4 8.7 .4c0 0 .4 17.8 .4 17.8c0 0 23.6 0 23.6 0c0 0 0-17.8 0-17.8c0 0 9.4-0.4 9.4-0.4c0 0 0-22.6 0-22.6c0 0-42.1 0-42.1 0c0 0 0 22.6 0 22.6Z\" />\n        <path d=\"M297.2 405.2c0 0-20.8 20.8-20.8 20.8c0 0-35.4-35.6-35.4-35.6c0 0-20.3 20.5-20.3 20.5c0 0 35.4 35.5 35.4 35.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 35.6 35.5 35.6 35.5c0 0 20.2-20.2 20.2-20.2c0 0-35.4-35.7-35.4-35.7c0 0 21.1-21 21.1-21c0 0-20.7-20.2-20.7-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l33.7-33.7l-20.4-20.3l-34.7 34.6c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-10.7-12.4-10.7-12.4c0 0-18.1 20.1-18.1 20.1c0 0 14.9 20.6 14.9 20.6c0 0 1.2 10.7 1.2 10.7c0 0 26.8 0 26.8 0c0 0 0-11.5 0-11.5c0 0 14.6-19.6 14.6-19.6c0 0-17.9-18.6-17.9-18.6c0 0-10.8 10.7-10.8 10.7Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-277.5c153.1 0 277.5 124.4 277.5 277.5c0 153.1-124.4 277.5-277.5 277.5c-153.1 0-277.5-124.4-277.5-277.5c0-153.1 124.4-277.5 277.5-277.5Z\" fill=\"none\" display=\"block\" transform=\"translate(411.2,307.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-12)\" transform=\"translate(20.3,-20.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-13)\">\n        <path d=\"M446 390.8c0 0 3.5 .2 3.5 .2c0 0 .2 7.3 .2 7.3c.1 0 14.2 0 14.2 0c0 0 0-7.3 0-7.3c0 0 4-0.2 4-0.2c0 0 0-13.5 0-13.5c0 0-21.9 0-21.9 0c0 0 0 13.5 0 13.5Z\" />\n        <path d=\"M287.9 414.4c0 0-11.5 11.6-11.5 11.6c0 0-18.5-18.8-18.5-18.8c0 0-20.3 20.5-20.3 20.5c0 0 18.5 18.7 18.5 18.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 18.7 18.7 18.7 18.7c0 0 20.2-20 20.2-20c0 0-18.5-19.1-18.5-19.1c0 0 11.9-11.8 11.9-11.8c0 0-20.8-20.2-20.8-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l22.4-22.4l-20.4-20.4l-23.4 23.4c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 259.4c0 0-4.5-5.2-4.5-5.2c0 0-10.7 12.1-10.7 12.1c0 0 6.9 10.1 6.9 10.1c0 0 .8 4.5 .8 4.5c0 0 16 0 16 0c0 0 0-5 0-5c0 0 6.7-9.4 6.7-9.4c0 0-10.6-11.2-10.6-11.2c0 0-4.6 4.1-4.6 4.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-272.5c150.4 0 272.5 122.1 272.5 272.5c0 150.4-122.1 272.5-272.5 272.5c-150.4 0-272.5-122.1-272.5-272.5c0-150.4 122.1-272.5 272.5-272.5Z\" fill=\"none\" display=\"block\" transform=\"translate(414.9,303.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-14)\" transform=\"translate(13.4,-13.4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-15)\">\n        <path d=\"M453.6 388.1c0 0 .7 0 .7 0c0 0 .1 1.7 .1 1.7c0 0 4.7 0 4.7 0c0 0 0-1.7 0-1.7c0 0 1 0 1 0c0 0 0-4.5 0-4.5c0 0-6.5 0-6.5 0c0 0 0 4.5 0 4.5Z\" />\n        <path d=\"M280.8 421.5c0 0-4.4 4.5-4.4 4.5c0 0-5.5-5.9-5.5-5.9c0 0-20.3 20.6-20.3 20.6c0 0 5.5 5.7 5.5 5.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 5.8 5.7 5.8 5.7c0 0 20.1-19.9 20.1-19.9c0 0-5.5-6.2-5.5-6.2c0 0 4.8-4.6 4.8-4.6c0 0-20.8-20.3-20.8-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l11.9-11.9l-20.4-20.3l-12.9 12.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 262.9c0 0-1-1.2-1-1.2c0 0-3.6 4-3.6 4c0 0 1.9 2.8 1.9 2.8c0 0 .2 1.1 .2 1.1c0 0 5.4 0 5.4 0c0 0 0-1.2 0-1.2c0 0 1.7-2.6 1.7-2.6c0 0-3.5-3.7-3.5-3.7c0 0-1.1 .8-1.1 .8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-268.8c148.4 0 268.8 120.4 268.8 268.8c0 148.4-120.4 268.8-268.8 268.8c-148.4 0-268.8-120.4-268.8-268.8c0-148.4 120.4-268.8 268.8-268.8Z\" fill=\"none\" display=\"block\" transform=\"translate(417.6,301.3) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-16)\" transform=\"translate(7.3,-7.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-17)\">\n        <path d=\"M275.4 426.9c0 0-19.3 19.5-19.3 19.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 19.9-19.7 19.9-19.7c0 0-20.9-20.2-20.9-20.2Z\" />\n        <path d=\"M411.4 291.3l20.7 20.7l.1-0.1c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 21.9 6.3 35.3 16.2l-7.9 20.3c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10.1 2.9 19.5 7.9 27.5Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-265.6c146.6 0 265.6 119 265.6 265.6c0 146.6-119 265.6-265.6 265.6c-146.6 0-265.6-119-265.6-265.6c0-146.6 119-265.6 265.6-265.6Z\" fill=\"none\" display=\"block\" transform=\"translate(420,299.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-18)\" transform=\"translate(4,-4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-19)\">\n        <path d=\"M265.4 437.1c0 0-9.3 9.3-9.3 9.3c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 9.8-9.6 9.8-9.6c0 0-20.8-20.1-20.8-20.1Z\" />\n        <path d=\"M403 299.3l20.9 20.9l8.3-8.3c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 34.6 5.8 48.1 15.8l-20.7 20.7c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10 2.9 19.3 7.8 27.3Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-263.8c145.6 0 263.8 118.2 263.8 263.8c0 145.6-118.2 263.8-263.8 263.8c-145.6 0-263.8-118.2-263.8-263.8c0-145.6 118.2-263.8 263.8-263.8Z\" fill=\"none\" display=\"block\" transform=\"translate(421.2,297.8) scale(.977,.977)\" />\n    </g>\n    <g clip-path=\"url(#" + iconPrefix + "_reverse_ClipPath-1)\" opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_reverse_Mask-20)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-261.7c144.4 0 261.7 117.3 261.7 261.7c0 144.4-117.3 261.7-261.7 261.7c-144.4 0-261.7-117.3-261.7-261.7c0-144.4 117.3-261.7 261.7-261.7Z\" fill=\"none\" display=\"block\" transform=\"translate(422.8,296.4) scale(.977,.977)\" />\n    </g>";
	  }
	});

	var yextAnimatedReverse = new SVGIcon({
	  name: 'yext_animated_forward',
	  viewBox: '0 0 72 72',
	  complexContents: function complexContents(params) {
	    if (params === void 0) {
	      params = {};
	    }

	    var iconPrefix = params.iconPrefix || 'yxt';
	    return "<defs>\n      <mask id=\"" + iconPrefix + "_forward_Mask-1\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-2\">\n        <rect x=\"-144.3\" y=\"144.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-3\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M489.8 277.4c0 0 78 18.8 78 18.8c0 0-96.1 61.5-96.1 61.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-13.9 14-13.9 14m-67.8-108.1c0 0 73.9 1.3 73.9 1.3c0 0-33.8 54.5-33.8 54.5c0 0 18.6-3.2 18.6-3.2c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-32.1 9.8-32.1 9.8\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-4\">\n        <rect x=\"-91.1\" y=\"91.1\" fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M-0.3 .1c0 0 1.3 1.2 1.3 1.2c0 0 .3-1.6 .3-1.6c0 0-1.6 .4-1.6 .4\" />\n        <path fill=\"#fff\" d=\"M.3 .7c0 0-0.3 .3-0.3 .3c0 0 0 0 0 0c0 0 .3-0.3 .3-0.3c0 0 0 0 0 0\" />\n        <path d=\"M.3 .7c0 0-0.1 0-0.1 0c0 0 .1 .1 .1 .1c0 0 .1-0.1 .1-0.1c0 0-0.1 0-0.1 0m222.8 469.1c0 0-70.5 69.4-70.5 69.4c0 0 34.1 33.5 34.1 33.5c0 0 67-72.9 67-72.9c0 0-30.6-30-30.6-30\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-5\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M488.4 291.4c0 0 40.5 39.3 40.5 39.3c0 0-57.2 27-57.2 27c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-15.3 28-15.3 28m-90.5-97.4c0 0 52-11.3 52-11.3c0 0-6 45.2-6 45.2c0 0 36.8-6 36.8-6c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-56.2 34.5-56.2 34.5\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-6\">\n        <rect x=\"-61.3\" y=\"61.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-7\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M481.8 298.4c0 0 27.5 39.8 27.5 39.8c0 0-37.6 19.5-37.6 19.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-21.9 35-21.9 35m-108.1-79.7c0 0 30.2-23.8 30.2-23.8c0 0 21.7 35.9 21.7 35.9c0 0 55.1-8.9 55.1-8.9c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-80.4 59.2-80.4 59.2\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-8\">\n        <rect x=\"-42.6\" y=\"42.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-9\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M475.2 305.4c0 0 14.5 40.3 14.5 40.3c0 0-18 12-18 12c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-28.5 42-28.5 42m-113.6-74.3c0 0 17.9-18.5 17.9-18.5c0 0 36.4 25.3 36.4 25.3c0 0 64.8-16 64.8-16c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-10\">\n        <rect x=\"-29.6\" y=\"29.6\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-11\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M468.6 312.4c0 0 1.5 40.8 1.5 40.8c0 0 1.6 4.5 1.6 4.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-35.1 49-35.1 49m-107-81.3c0 0 15.1 4.9 15.1 4.9c0 0 38.2 13.3 38.2 13.3c0 0 65.8-27.4 65.8-27.4c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-12\">\n        <rect x=\"-20.3\" y=\"20.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-13\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M456.6 311.9c0 0-7 35.6-7 35.6c0 0 22.1 10.2 22.1 10.2c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-47.1 48.5-47.1 48.5m-95-80.8c0 0 12.3 28.3 12.3 28.3c0 0 39.9 1.3 39.9 1.3c0 0 66.9-38.8 66.9-38.8c0 0 39.3-21.9 39.3-21.9c0 0-65.9-40.5-65.9-40.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-14\">\n        <rect x=\"-13.4\" y=\"13.4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-15\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M444.6 311.4c0 0-15.6 30.5-15.6 30.5c0 0 42.7 15.8 42.7 15.8c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-59.1 48-59.1 48m-83-80.3c0 0 9.5 51.7 9.5 51.7c0 0 41.7-10.8 41.7-10.8c0 0 67.9-50.1 67.9-50.1c0 0 50.6-31.9 50.6-31.9c0 0-77.2-30.5-77.2-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-16\">\n        <rect x=\"-7.3\" y=\"7.3\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-17\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 35.4-36.5 35.4-36.5c0 0-62-25.9-62-25.9c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-18\">\n        <rect x=\"-4\" y=\"4\" fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-19\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n        <path d=\"M432.6 310.9c0 0-24.2 25.3-24.2 25.3c0 0 63.3 21.5 63.3 21.5c0 0 59.6-41.1 59.6-41.1c0 0 10.6-53.8 10.6-53.8c0 0-38.2 .6-38.2 .6c0 0-71.1 47.5-71.1 47.5m-71-79.8c0 0 20.3 90.4 20.3 90.4c0 0 29-29.5 29-29.5c0 0 69.8-70.1 69.8-70.1c0 0 39.3-31.9 39.3-31.9c0 0-65.9-30.5-65.9-30.5c0 0-92.5 71.6-92.5 71.6\" />\n      </mask>\n      <mask id=\"" + iconPrefix + "_forward_Mask-20\">\n        <rect fill=\"#fff\" width=\"720\" height=\"720\" />\n      </mask>\n      <clipPath id=\"" + iconPrefix + "_forward_ClipPath-1\">\n        <rect width=\"720\" height=\"720\" />\n      </clipPath>\n    </defs>\n    <g transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_forward_Mask-1)\">\n        <path d=\"M377.5 395.3c0 0 64.8 0 64.8 0c0 0 0 129.6 0 129.6c0 0 28.8 0 28.8 0c0 0 0-129.6 0-129.6c0 0 64.8 0 64.8 0c0 0 0-28.8 0-28.8c0 0-158.4 0-158.4 0c0 0 0 28.8 0 28.8Z\" />\n        <path d=\"M338.9 363.6c0 0-62.5 62.4-62.5 62.4c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 62.4-62.4 62.4-62.4c0 0-20.3-20.4-20.3-20.4Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-60.7-72.8-60.7-72.8c0 0-22.1 18.6-22.1 18.6c0 0 68.4 82 68.4 82c0 0 0 62.4 0 62.4c0 0 28.8 0 28.8 0c0 0 0-62.6 0-62.6c0 0 68.4-81.8 68.4-81.8c0 0-22-18.6-22-18.6c0 0-60.8 72.8-60.8 72.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-353.7c195.2 0 353.7 158.5 353.7 353.7c0 195.2-158.5 353.7-353.7 353.7c-195.2 0-353.7-158.5-353.7-353.7c0-195.2 158.5-353.7 353.7-353.7Z\" fill=\"none\" transform=\"translate(359.8,360.4) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-2)\" transform=\"translate(144.3,-144.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-3)\">\n        <path d=\"M390.6 395.2c0 0 51.7 .1 51.7 .1c0 0 .1 103.6 .1 103.6c0 0 28.7 0 28.7 0c0 0 0-103.6 0-103.6c0 0 52-0.1 52-0.1c0 0 0-28.4 0-28.4c0 0-132.5 0-132.5 0c0 0 0 28.4 0 28.4Z\" />\n        <path d=\"M329 373.4c0 .1-52.6 52.6-52.6 52.6c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 52.6-52.6 52.6-52.6c0 0-20.4-20.3-20.4-20.3Z\" />\n        <path d=\"M454.7 345.8c44.8 0 81-36.3 81-81c0 0-28.8 0-28.8 0c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3c0 0 69.8-69.9 69.8-69.9c0 0 21.1-21 21.1-21c-14.4-22.3-39.5-37-68-37c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81Zm0-133.2c10.2 0 19.6 2.9 27.6 7.9c0 0-71.9 71.8-71.9 71.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2Z\" />\n        <path d=\"M276.4 255.9c0 0-48.7-58.3-48.7-58.3c0 0-21.1 19-21.1 19c0 0 55.5 67.2 55.5 67.2c0 0 .3 50 .3 50c0 0 28.4 0 28.4 0c0 0 0-50.3 0-50.3c0 0 55.4-66.9 55.4-66.9c0 0-21-18.6-21-18.6c0 0-48.8 57.9-48.8 57.9Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-336.2c185.6 0 336.2 150.6 336.2 336.2c0 185.6-150.6 336.2-336.2 336.2c-185.6 0-336.2-150.6-336.2-336.2c0-185.6 150.6-336.2 336.2-336.2Z\" fill=\"none\" display=\"block\" transform=\"translate(370.8,347.5) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_forward_Mask-4)\" transform=\"translate(91.1,-91.1)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#" + iconPrefix + "_forward_Mask-5)\">\n        <path d=\"M409.7 395.1c0 0 32.6 .2 32.6 .2c0 0 .3 65.5 .3 65.5c0 0 28.5 0 28.5 0c0 0 0-65.5 0-65.5c0 0 33.1-0.2 33.1-0.2c0 0 0-27.8 0-27.8c0 0-94.5 0-94.5 0c0 0 0 27.8 0 27.8Z\" />\n        <path d=\"M319.7 382.8c0 0-43.3 43.2-43.3 43.2c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 43.4-43.3 43.4-43.3c0 0-20.5-20.3-20.5-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l69.8-69.9l.3-0.2l-20.3-20.4l-71.2 71.1c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-31.1-37-31.1-37c0 0-19.7 19.5-19.7 19.5c0 0 36.7 45.6 36.7 45.6c0 0 .7 31.8 .7 31.8c0 0 27.7 0 27.7 0c0 0 0-32.4 0-32.4c0 0 36.5-44.9 36.5-44.9c0 0-19.6-18.6-19.6-18.6c0 0-31.2 36-31.2 36Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-310c171.1 0 310 138.9 310 310c0 171.1-138.9 310-310 310c-171.1 0-310-138.9-310-310c0-171.1 138.9-310 310-310Z\" fill=\"none\" transform=\"translate(387.8,328.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-6)\" transform=\"translate(61.3,-61.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g mask=\"url(#" + iconPrefix + "_forward_Mask-7)\">\n        <path d=\"M420.4 395c0 0 21.9 .3 21.9 .3c0 0 .4 44.1 .4 44.1c0 0 28.4 0 28.4 0c0 0 0-44.1 0-44.1c0 0 22.6-0.3 22.6-0.3c0 0 0-27.5 0-27.5c0 0-73.3 0-73.3 0c0 0 0 27.5 0 27.5Z\" />\n        <path d=\"M313.2 389.2c0 0-36.8 36.8-36.8 36.8c0 0-62.4-62.4-62.4-62.4c0 0-20.4 20.4-20.4 20.4c0 0 62.5 62.4 62.5 62.4c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 62.5 62.4 62.5 62.4c0 0 20.3-20.4 20.3-20.4c0 0-62.4-62.4-62.4-62.4c0 0 37-36.9 37-36.9c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M500 200c-13.4-9.9-27.2-16.2-45.3-16.2c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l57.7-57.7l-20.3-20.4l-58.8 58.7c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-21.2-25.1-21.2-25.1c0 0-19 19.8-19 19.8c0 0 26.2 33.5 26.2 33.5c0 0 1 21.6 1 21.6c0 0 27.2 0 27.2 0c0 0 0-22.3 0-22.3c0 0 25.9-32.7 25.9-32.7c0 0-18.8-18.6-18.8-18.6c0 0-21.3 23.8-21.3 23.8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-294.3c162.4 0 294.3 131.9 294.3 294.3c0 162.4-131.9 294.3-294.3 294.3c-162.4 0-294.3-131.9-294.3-294.3c0-162.4 131.9-294.3 294.3-294.3Z\" fill=\"none\" display=\"block\" transform=\"translate(398.7,318.2) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g mask=\"url(#" + iconPrefix + "_forward_Mask-8)\" transform=\"translate(42.6,-42.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-9)\">\n        <path d=\"M427.2 394.9c0 0 15.1 .4 15.1 .4c0 0 .4 30.7 .4 30.7c0 0 28.4 0 28.4 0c0 0 0-30.7 0-30.7c0 0 15.9-0.4 15.9-0.4c0 0 0-27.2 0-27.2c0 0-59.8 0-59.8 0c0 0 0 27.2 0 27.2Z\" />\n        <path d=\"M307.4 395c0 0-31 31-31 31c0 0-53.9-54-53.9-54c0 0-20.4 20.4-20.4 20.4c0 0 54 54 54 54c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 54 54 54 54c0 0 20.4-20.3 20.4-20.3c0 0-54-54.1-54-54.1c0 0 31.2-31.1 31.2-31.1c0 0-20.6-20.3-20.6-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l45.5-45.5l-20.4-20.4l-46.5 46.5c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-15-17.6-15-17.6c0 0-18.4 20-18.4 20c0 0 19.4 25.8 19.4 25.8c0 0 1.2 15.2 1.2 15.2c0 0 27 0 27 0c0 0 0-15.9 0-15.9c0 0 19.1-24.9 19.1-24.9c0 0-18.2-18.7-18.2-18.7c0 0-15.1 16.1-15.1 16.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-284.4c157 0 284.4 127.4 284.4 284.4c0 157-127.4 284.4-284.4 284.4c-157 0-284.4-127.4-284.4-284.4c0-157 127.4-284.4 284.4-284.4Z\" fill=\"none\" transform=\"translate(406.1,311.6) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-10)\" transform=\"translate(29.6,-29.6)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-11)\">\n        <path d=\"M436 393.5c0 0 8.7 .4 8.7 .4c0 0 .4 17.8 .4 17.8c0 0 23.6 0 23.6 0c0 0 0-17.8 0-17.8c0 0 9.4-0.4 9.4-0.4c0 0 0-22.6 0-22.6c0 0-42.1 0-42.1 0c0 0 0 22.6 0 22.6Z\" />\n        <path d=\"M297.2 405.2c0 0-20.8 20.8-20.8 20.8c0 0-35.4-35.6-35.4-35.6c0 0-20.3 20.5-20.3 20.5c0 0 35.4 35.5 35.4 35.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 35.6 35.5 35.6 35.5c0 0 20.2-20.2 20.2-20.2c0 0-35.4-35.7-35.4-35.7c0 0 21.1-21 21.1-21c0 0-20.7-20.2-20.7-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-9.9-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l33.7-33.7l-20.4-20.3l-34.7 34.6c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 255.9c0 0-10.7-12.4-10.7-12.4c0 0-18.1 20.1-18.1 20.1c0 0 14.9 20.6 14.9 20.6c0 0 1.2 10.7 1.2 10.7c0 0 26.8 0 26.8 0c0 0 0-11.5 0-11.5c0 0 14.6-19.6 14.6-19.6c0 0-17.9-18.6-17.9-18.6c0 0-10.8 10.7-10.8 10.7Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-277.5c153.1 0 277.5 124.4 277.5 277.5c0 153.1-124.4 277.5-277.5 277.5c-153.1 0-277.5-124.4-277.5-277.5c0-153.1 124.4-277.5 277.5-277.5Z\" fill=\"none\" display=\"block\" transform=\"translate(411.2,307.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-12)\" transform=\"translate(20.3,-20.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-13)\">\n        <path d=\"M446 390.8c0 0 3.5 .2 3.5 .2c0 0 .2 7.3 .2 7.3c.1 0 14.2 0 14.2 0c0 0 0-7.3 0-7.3c0 0 4-0.2 4-0.2c0 0 0-13.5 0-13.5c0 0-21.9 0-21.9 0c0 0 0 13.5 0 13.5Z\" />\n        <path d=\"M287.9 414.4c0 0-11.5 11.6-11.5 11.6c0 0-18.5-18.8-18.5-18.8c0 0-20.3 20.5-20.3 20.5c0 0 18.5 18.7 18.5 18.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 18.7 18.7 18.7 18.7c0 0 20.2-20 20.2-20c0 0-18.5-19.1-18.5-19.1c0 0 11.9-11.8 11.9-11.8c0 0-20.8-20.2-20.8-20.2Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l22.4-22.4l-20.4-20.4l-23.4 23.4c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 259.4c0 0-4.5-5.2-4.5-5.2c0 0-10.7 12.1-10.7 12.1c0 0 6.9 10.1 6.9 10.1c0 0 .8 4.5 .8 4.5c0 0 16 0 16 0c0 0 0-5 0-5c0 0 6.7-9.4 6.7-9.4c0 0-10.6-11.2-10.6-11.2c0 0-4.6 4.1-4.6 4.1Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-272.5c150.4 0 272.5 122.1 272.5 272.5c0 150.4-122.1 272.5-272.5 272.5c-150.4 0-272.5-122.1-272.5-272.5c0-150.4 122.1-272.5 272.5-272.5Z\" fill=\"none\" display=\"block\" transform=\"translate(414.9,303.7) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-14)\" transform=\"translate(13.4,-13.4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-15)\">\n        <path d=\"M453.6 388.1c0 0 .7 0 .7 0c0 0 .1 1.7 .1 1.7c0 0 4.7 0 4.7 0c0 0 0-1.7 0-1.7c0 0 1 0 1 0c0 0 0-4.5 0-4.5c0 0-6.5 0-6.5 0c0 0 0 4.5 0 4.5Z\" />\n        <path d=\"M280.8 421.5c0 0-4.4 4.5-4.4 4.5c0 0-5.5-5.9-5.5-5.9c0 0-20.3 20.6-20.3 20.6c0 0 5.5 5.7 5.5 5.7c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 5.8 5.7 5.8 5.7c0 0 20.1-19.9 20.1-19.9c0 0-5.5-6.2-5.5-6.2c0 0 4.8-4.6 4.8-4.6c0 0-20.8-20.3-20.8-20.3Z\" />\n        <path d=\"M502.8 199.6c-13.4-10-30.1-15.8-48.1-15.8c-44.7 0-81 36.2-81 81c0 44.7 36.3 81 81 81c44.8 0 81-36.3 81-81h-28.8c0 28.8-23.3 52.2-52.2 52.2c-8.2 0-16-1.9-22.9-5.3l11.9-11.9l-20.4-20.3l-12.9 12.8c-5-8-7.9-17.4-7.9-27.5c0-28.9 23.4-52.2 52.2-52.2c10.1 0 19.4 2.8 27.4 7.7Z\" fill-rule=\"evenodd\" />\n        <path d=\"M276.4 262.9c0 0-1-1.2-1-1.2c0 0-3.6 4-3.6 4c0 0 1.9 2.8 1.9 2.8c0 0 .2 1.1 .2 1.1c0 0 5.4 0 5.4 0c0 0 0-1.2 0-1.2c0 0 1.7-2.6 1.7-2.6c0 0-3.5-3.7-3.5-3.7c0 0-1.1 .8-1.1 .8Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-268.8c148.4 0 268.8 120.4 268.8 268.8c0 148.4-120.4 268.8-268.8 268.8c-148.4 0-268.8-120.4-268.8-268.8c0-148.4 120.4-268.8 268.8-268.8Z\" fill=\"none\" display=\"block\" transform=\"translate(417.6,301.3) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-16)\" transform=\"translate(7.3,-7.3)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-17)\">\n        <path d=\"M275.4 426.9c0 0-19.3 19.5-19.3 19.5c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 19.9-19.7 19.9-19.7c0 0-20.9-20.2-20.9-20.2Z\" />\n        <path d=\"M411.4 291.3l20.7 20.7l.1-0.1c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 21.9 6.3 35.3 16.2l-7.9 20.3c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10.1 2.9 19.5 7.9 27.5Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-265.6c146.6 0 265.6 119 265.6 265.6c0 146.6-119 265.6-265.6 265.6c-146.6 0-265.6-119-265.6-265.6c0-146.6 119-265.6 265.6-265.6Z\" fill=\"none\" display=\"block\" transform=\"translate(420,299.1) scale(.977,.977)\" />\n    </g>\n    <g opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-18)\" transform=\"translate(4,-4)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-19)\">\n        <path d=\"M265.4 437.1c0 0-9.3 9.3-9.3 9.3c0 0-62.5 62.4-62.5 62.4c0 0 20.4 20.4 20.4 20.4c0 0 62.4-62.4 62.4-62.4c0 0 9.8-9.6 9.8-9.6c0 0-20.8-20.1-20.8-20.1Z\" />\n        <path d=\"M403 299.3l20.9 20.9l8.3-8.3c6.8 3.2 14.5 5.1 22.5 5.1c28.9 0 52.2-23.4 52.2-52.2h28.8c0 44.7-36.2 81-81 81c-44.7 0-81-36.3-81-81c0-44.8 36.3-81 81-81c18 0 34.6 5.8 48.1 15.8l-20.7 20.7c-8-4.9-17.3-7.7-27.4-7.7c-28.8 0-52.2 23.3-52.2 52.2c0 10 2.9 19.3 7.8 27.3Z\" fill-rule=\"evenodd\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-263.8c145.6 0 263.8 118.2 263.8 263.8c0 145.6-118.2 263.8-263.8 263.8c-145.6 0-263.8-118.2-263.8-263.8c0-145.6 118.2-263.8 263.8-263.8Z\" fill=\"none\" display=\"block\" transform=\"translate(421.2,297.8) scale(.977,.977)\" />\n    </g>\n    <g clip-path=\"url(#" + iconPrefix + "_forward_ClipPath-1)\" opacity=\"0\" transform=\"translate(0,0) scale(.1,.1)\">\n      <g display=\"block\" mask=\"url(#" + iconPrefix + "_forward_Mask-20)\">\n        <path d=\"M224.2 478.3c0 0-210.6 210.5-210.6 210.5c0 0 20.4 20.4 20.4 20.4c0 0 210.7-210.7 210.7-210.7c-11.7-11-5.9-6-20.5-20.2Z\" />\n      </g>\n      <path stroke=\"#000\" stroke-width=\"30\" d=\"M0-261.7c144.4 0 261.7 117.3 261.7 261.7c0 144.4-117.3 261.7-261.7 261.7c-144.4 0-261.7-117.3-261.7-261.7c0-144.4 117.3-261.7 261.7-261.7Z\" fill=\"none\" display=\"block\" transform=\"translate(422.8,296.4) scale(.977,.977)\" />\n    </g>";
	  }
	});

	var email = new SVGIcon({
	  name: 'email',
	  path: 'M12,-3.55271368e-15 C8.81712,-3.55271368e-15 5.7648,1.26468 3.5148,3.5148 C1.2648,5.76492 3.55271368e-15,8.81736 3.55271368e-15,12 C3.55271368e-15,15.18264 1.26468,18.2352 3.5148,20.4852 C5.76492,22.7352 8.81736,24 12,24 C15.18264,24 18.2352,22.73532 20.4852,20.4852 C22.7352,18.23508 24,15.18264 24,12 C24,8.81736 22.73532,5.7648 20.4852,3.5148 C18.23508,1.2648 15.18264,-3.55271368e-15 12,-3.55271368e-15 Z M17.28,7.92 L12,11.87064 L6.72,7.92 L17.28,7.92 Z M18,15.64776 C18,15.7743216 17.9446872,15.894312 17.85,15.976824 C17.7543744,16.059324 17.6278128,16.096824 17.503128,16.0799496 L6.479928,16.0799496 C6.352428,16.0940122 6.224928,16.0499496 6.13212,15.961824 C6.0402456,15.8727624 5.9914944,15.7471368 5.9999328,15.618696 L5.9999328,9.047736 L5.9999328,8.441184 L7.9536768,9.90744 L11.6398368,12.67224 C11.839524,12.8681784 12.1601568,12.8681784 12.3598368,12.67224 L17.8939968,8.51736 L17.9849352,8.44986 L17.9858726,8.45079768 C17.9914978,8.48548488 17.9952478,8.52111048 17.9971226,8.55579768 L17.9971226,15.6386777 L18,15.64776 Z'
	});

	var iconsArray = [thumbIcon, receiptIcon, pantheonIcon, micIcon, directionsIcon, calendarIcon, calloutIcon, infoIcon, briefcaseIcon, kabobIcon, personIcon, magnifyingGlassIcon, officeIcon, linkIcon, windowIcon, phoneIcon, tagIcon, documentIcon, chevronIcon, supportIcon, yextIcon, pinIcon, gearIcon, lightBulbIcon, elements, close, yextAnimatedForward, yextAnimatedReverse, email, starIcon];
	var Icons = {};

	forEach$2(iconsArray).call(iconsArray, function (icon) {
	  Icons[icon.name] = icon.markup();
	});

	Icons["default"] = starIcon.markup();

	var keys$6 = entryVirtual('Array').keys;

	var keys$7 = keys$6;

	var ArrayPrototype$f = Array.prototype;

	var DOMIterables$2 = {
	  DOMTokenList: true,
	  NodeList: true
	};

	var keys_1 = function (it) {
	  var own = it.keys;
	  return it === ArrayPrototype$f || (it instanceof Array && own === ArrayPrototype$f.keys)
	    // eslint-disable-next-line no-prototype-builtins -- safe
	    || DOMIterables$2.hasOwnProperty(classof(it)) ? keys$7 : own;
	};

	var keys$8 = keys_1;

	var minimalSafe = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports,"__esModule",{value:!0});var n=/(\w+)[-_].*/;function f(f,r){if(r[f])return r[f];var t=f.match(n);if(!t)throw new Error("Can't find lang or lcale with code "+f);return r[t[1]]}function r(n){return n>1}function t(n){return 1!==n}function u(n){return 0}var e={ach:{n:2,f:r},af:{n:2,f:t},ak:{n:2,f:r},am:{n:2,f:r},an:{n:2,f:t},ar:{n:6,f:function(n){return 0===n?0:1===n?1:2===n?2:n%100>=3&&n%100<=10?3:n%100>=11?4:5}},arn:{n:2,f:r},ast:{n:2,f:t},ay:{n:1,f:u},az:{n:2,f:t},be:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},bg:{n:2,f:t},bn:{n:2,f:t},bo:{n:1,f:u},br:{n:2,f:r},brx:{n:2,f:t},bs:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},ca:{n:2,f:t},cgg:{n:1,f:u},cs:{n:3,f:function(n){return 1===n?0:n>=2&&n<=4?1:2}},csb:{n:3,f:function(n){return 1===n?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},cy:{n:4,f:function(n){return 1===n?0:2===n?1:8!==n&&11!==n?2:3}},da:{n:2,f:t},de:{n:2,f:t},doi:{n:2,f:t},dz:{n:1,f:u},el:{n:2,f:t},en:{n:2,f:t},eo:{n:2,f:t},es:{n:2,f:t},et:{n:2,f:t},eu:{n:2,f:t},fa:{n:1,f:u},ff:{n:2,f:t},fi:{n:2,f:t},fil:{n:2,f:r},fo:{n:2,f:t},fr:{n:2,f:r},fur:{n:2,f:t},fy:{n:2,f:t},ga:{n:5,f:function(n){return 1===n?0:2===n?1:n<7?2:n<11?3:4}},gd:{n:4,f:function(n){return 1===n||11===n?0:2===n||12===n?1:n>2&&n<20?2:3}},gl:{n:2,f:t},gu:{n:2,f:t},gun:{n:2,f:r},ha:{n:2,f:t},he:{n:2,f:t},hi:{n:2,f:t},hne:{n:2,f:t},hr:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},hu:{n:2,f:t},hy:{n:2,f:t},id:{n:1,f:u},is:{n:2,f:function(n){return n%10!=1||n%100==11}},it:{n:2,f:t},ja:{n:1,f:u},jbo:{n:1,f:u},jv:{n:2,f:function(n){return 0!==n}},ka:{n:1,f:u},kab:{n:2,f:t},kk:{n:1,f:u},km:{n:1,f:u},kn:{n:2,f:t},ko:{n:1,f:u},ku:{n:2,f:t},kw:{n:4,f:function(n){return 1===n?0:2===n?1:3===n?2:3}},ky:{n:1,f:u},lb:{n:2,f:t},ln:{n:2,f:r},lo:{n:1,f:u},lt:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&(n%100<10||n%100>=20)?1:2}},lv:{n:3,f:function(n){return n%10==1&&n%100!=11?0:0!==n?1:2}},mai:{n:2,f:t},mfe:{n:2,f:r},mg:{n:2,f:r},mi:{n:2,f:r},mk:{n:2,f:function(n){return 1===n||n%10==1?0:1}},ml:{n:2,f:t},mn:{n:2,f:t},mni:{n:2,f:t},mnk:{n:3,f:function(n){return 0===n?0:1===n?1:2}},mr:{n:2,f:t},ms:{n:1,f:u},mt:{n:4,f:function(n){return 1===n?0:0===n||n%100>1&&n%100<11?1:n%100>10&&n%100<20?2:3}},my:{n:1,f:u},nah:{n:2,f:t},nap:{n:2,f:t},nb:{n:2,f:t},ne:{n:2,f:t},nl:{n:2,f:t},nn:{n:2,f:t},no:{n:2,f:t},nso:{n:2,f:t},oc:{n:2,f:r},or:{n:2,f:t},pa:{n:2,f:t},pap:{n:2,f:t},pl:{n:3,f:function(n){return 1===n?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},pms:{n:2,f:t},ps:{n:2,f:t},pt:{n:2,f:t},rm:{n:2,f:t},ro:{n:3,f:function(n){return 1===n?0:0===n||n%100>0&&n%100<20?1:2}},ru:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},rw:{n:2,f:t},sah:{n:1,f:u},sat:{n:2,f:t},sco:{n:2,f:t},sd:{n:2,f:t},se:{n:2,f:t},si:{n:2,f:t},sk:{n:3,f:function(n){return 1===n?0:n>=2&&n<=4?1:2}},sl:{n:4,f:function(n){return n%100==1?1:n%100==2?2:n%100==3||n%100==4?3:0}},so:{n:2,f:t},son:{n:2,f:t},sq:{n:2,f:t},sr:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},su:{n:1,f:u},sv:{n:2,f:t},sw:{n:2,f:t},ta:{n:2,f:t},te:{n:2,f:t},tg:{n:2,f:r},th:{n:1,f:u},ti:{n:2,f:r},tk:{n:2,f:t},tr:{n:2,f:r},tt:{n:1,f:u},ug:{n:1,f:u},uk:{n:3,f:function(n){return n%10==1&&n%100!=11?0:n%10>=2&&n%10<=4&&(n%100<10||n%100>=20)?1:2}},ur:{n:2,f:t},uz:{n:2,f:r},vi:{n:1,f:u},wa:{n:2,f:r},wo:{n:1,f:u},yo:{n:2,f:t},zh:{n:1,f:u}};function o(n){return f(n,e).n}var i={};function c(n){if(i[n])return i[n];var r=f(n,e),t=function(n,f){return f[+r.f(n)]};return i[n]=t,t}function a(n){try{return f(n,e),!0}catch(n){return !1}}function s(){return Object.keys(e)}exports.getNPlurals=o,exports.getPluralFunc=c,exports.hasLang=a,exports.getAvailLangs=s;
	});

	unwrapExports(minimalSafe);
	var minimalSafe_1 = minimalSafe.getNPlurals;
	var minimalSafe_2 = minimalSafe.getPluralFunc;
	var minimalSafe_3 = minimalSafe.hasLang;
	var minimalSafe_4 = minimalSafe.getAvailLangs;

	var TranslationProcessor = /*#__PURE__*/function () {
	  function TranslationProcessor() {}

	  /**
	   * Processes a translation which includes performing interpolation, pluralization, or
	   * both
	   * @param {string | Object} translations The translation, or an object containing
	   * translated plural forms
	   * @param {Object} interpolationParams Params to use during interpolation
	   * @param {number} count The count associated with the pluralization
	   * @param {string} language The langauge associated with the pluralization
	   * @param {string} escapeExpression A function which escapes HTML in the passed string
	   * @returns {string} The translation with any interpolation or pluralization applied
	   */
	  TranslationProcessor.process = function process(translations, interpolationParams, count, language, escapeExpression) {
	    var stringToInterpolate = typeof translations === 'string' ? translations : this._selectPluralForm(translations, count, language);
	    return this._interpolate(stringToInterpolate, interpolationParams, escapeExpression);
	  }
	  /**
	   * Returns the correct plural form given a translations object and count.
	   * @param {Object} translations
	   * @param {number} count
	   * @param {string} language
	   * @returns {string}
	   */
	  ;

	  TranslationProcessor._selectPluralForm = function _selectPluralForm(translations, count, language) {
	    if (!minimalSafe_3(language)) {
	      language = 'en';
	    }

	    var oneToNArray = this._generateArrayOneToN(language);

	    var pluralFormIndex = minimalSafe_2(language)(count, oneToNArray);
	    return translations[pluralFormIndex];
	  }
	  /**
	   * @param {string} language
	   * @returns {Array} an array of the form [0, 1, 2, ..., nPluralForms]
	   */
	  ;

	  TranslationProcessor._generateArrayOneToN = function _generateArrayOneToN(language) {
	    var _context;

	    var numberOfPluralForms = minimalSafe_1(language);
	    return from_1$2(keys$8(_context = new Array(numberOfPluralForms)).call(_context));
	  };

	  TranslationProcessor._interpolate = function _interpolate(stringToInterpolate, interpolationParams, escapeExpression) {
	    if (interpolationParams && !escapeExpression) {
	      throw new Error('An escapeExpression function must be provided when processing translations with interpolation');
	    }

	    var interpolationRegex = /\[\[([a-zA-Z0-9]+)\]\]/g;
	    return stringToInterpolate.replace(interpolationRegex, function (match, interpolationKey) {
	      var interpolation = interpolationParams[interpolationKey];
	      return escapeExpression(interpolation);
	    });
	  };

	  return TranslationProcessor;
	}();

	/**
	 * HandlebarsRenderer is a wrapper around the nativate handlebars renderer.
	 * @extends Renderer
	 */

	var HandlebarsRenderer = /*#__PURE__*/function (_Renderer) {
	  _inheritsLoose(HandlebarsRenderer, _Renderer);

	  function HandlebarsRenderer(templates, opts) {
	    var _this;

	    if (templates === void 0) {
	      templates = {};
	    }

	    _this = _Renderer.call(this) || this;
	    /**
	     * A local reference to the handlebars compiler
	     * @type {Handlebars}
	     * @private
	     */

	    _this._handlebars = templates._hb || null;
	    /**
	     * A local reference to the pre-compiled handlebars templates
	     * @type {Handlebars}
	     * @private
	     */

	    _this._templates = templates || {};
	    return _this;
	  }

	  var _proto = HandlebarsRenderer.prototype;

	  _proto.init = function init(templates, locale) {
	    // Assign the handlebars compiler and templates based on
	    // information provided from external dep (in default case, it comes from external server request)
	    this._handlebars = templates._hb;
	    this._templates = templates; // Store the locale that ANSWERS was initialized with

	    this._initLocale = locale; // TODO(billy) Once we re-write templates using the new helpers library
	    // we probably don't need these custom helpers anymore

	    this._registerCustomHelpers();
	  }
	  /**
	   * registerHelper is a public interface for external dependencies to
	   * register their own custom helpers to our internal Handlebars Compiler
	   */
	  ;

	  _proto.registerHelper = function registerHelper(name, cb) {
	    this._handlebars.registerHelper(name, cb);
	  }
	  /**
	   * SafeString is a public interface for external dependencies to
	   * mark a string as 'safe'. Handlebars will not escape a SafeString
	   */
	  ;

	  _proto.SafeString = function SafeString(string) {
	    return new this._handlebars.SafeString(string);
	  }
	  /**
	   * EscapeExpression is a public interface for external dependencies to
	   * escape a string
	   */
	  ;

	  _proto.escapeExpression = function escapeExpression(string) {
	    return this._handlebars.escapeExpression(string);
	  }
	  /**
	   * compile a handlebars template so that it can be rendered,
	   * using the {Handlebars} compiler
	   * @param {string} template The template string to compile
	   * @returns {Function}
	   */
	  ;

	  _proto.compile = function compile(template) {
	    if (typeof template !== 'string') {
	      return '';
	    }

	    return this._handlebars.compile(template);
	  }
	  /**
	   * compile a template and then add it to the current template bundle
	   * @param {string} templateName The unique name for the template
	   * @param {string} template The handlebars template string
	   */
	  ;

	  _proto.registerTemplate = function registerTemplate(templateName, template) {
	    this._templates[templateName] = this.compile(template);
	  }
	  /**
	   * render will render a template with data
	   * @param {Object} config Provide either a templateName or a pre-compiled template
	   * @param {Object} data The data to provide to the template
	   */
	  ;

	  _proto.render = function render(config, data) {
	    // If a custom template is provided, use it,
	    // otherwise fall back to the template name
	    // TODO(billy) This interface should probably be less ugly
	    if (config.template !== null) {
	      return config.template(data);
	    }

	    if (!(config.templateName in this._templates)) {
	      throw new Error('Can\'t find template: ' + config.templateName);
	    }

	    try {
	      return this._templates[config.templateName](data);
	    } catch (e) {
	      console.error('Error when trying to render the template: ' + config.templateName);
	      throw e;
	    }
	  };

	  _proto._registerCustomHelpers = function _registerCustomHelpers() {
	    this.registerHelper('ifeq', function (arg1, arg2, options) {
	      return arg1 === arg2 ? options.fn(this) : options.inverse(this);
	    });
	    this.registerHelper('ifnoteq', function (arg1, arg2, options) {
	      return arg1 !== arg2 ? options.fn(this) : options.inverse(this);
	    });
	    this.registerHelper({
	      eq: function eq(v1, v2) {
	        return v1 === v2;
	      },
	      ne: function ne(v1, v2) {
	        return v1 !== v2;
	      },
	      lt: function lt(v1, v2) {
	        return v1 < v2;
	      },
	      gt: function gt(v1, v2) {
	        return v1 > v2;
	      },
	      lte: function lte(v1, v2) {
	        return v1 <= v2;
	      },
	      gte: function gte(v1, v2) {
	        return v1 >= v2;
	      },
	      and: function and() {
	        var _context;

	        return every$2(_context = slice$4(Array.prototype).call(arguments)).call(_context, Boolean);
	      },
	      or: function or() {
	        var _context2;

	        return some$2(_context2 = slice$4(Array.prototype).call(arguments, 0, -1)).call(_context2, Boolean);
	      }
	    });
	    this.registerHelper({
	      add: function add(a1, a2) {
	        return a1 + a2;
	      },
	      sub: function sub(a1, a2) {
	        return a1 - a2;
	      },
	      mul: function mul(a1, a2) {
	        return a1 * a2;
	      },
	      div: function div(a1, a2) {
	        return a1 / a2;
	      },
	      mod: function mod(a1, a2) {
	        return a1 % a2;
	      }
	    });
	    this.registerHelper('every', function () {
	      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }

	      var values = slice$4(args).call(args, 0, args.length - 1);

	      var options = args[args.length - 1];
	      return every$2(values).call(values, function (v) {
	        return v;
	      }) ? options.fn(this) : options.inverse(this);
	    });
	    this.registerHelper('formatPhoneNumber', function (phoneNumberString) {
	      var cleaned = ('' + phoneNumberString).replace(/\D/g, '');
	      var match = cleaned.match(/^(1|)?(\d{3})(\d{3})(\d{4})$/);

	      if (match) {
	        var intlCode = match[1] ? '+1 ' : '';
	        return [intlCode, '(', match[2], ') ', match[3], '-', match[4]].join('');
	      }

	      return null;
	    });
	    this.registerHelper('assign', function (name, value, options) {
	      var args = arguments;
	      options = args[args.length - 1];

	      if (!options.data.root) {
	        options.data.root = {};
	      }

	      var v = '';

	      for (var i = 1; i < args.length - 1; i++) {
	        v = v + args[i];
	      }

	      options.data.root[name] = v;
	    });
	    this.registerHelper('json', function (name, value, options) {
	      return name === undefined ? '' : stringify$2(name);
	    });
	    this.registerHelper('plural', function (number, singularText, pluralText) {
	      return number === 1 ? singularText : pluralText;
	    });
	    var self = this;
	    this.registerHelper('processTranslation', function (options) {
	      var _context3, _context4, _context5;

	      var pluralizationInfo = {};
	      var interpolationParams = {};
	      var _options$hash = options.hash,
	          phrase = _options$hash.phrase,
	          count = _options$hash.count,
	          locale = _options$hash.locale;

	      forEach$2(_context3 = entries$5(options.hash)).call(_context3, function (_ref) {
	        var key = _ref[0],
	            value = _ref[1];

	        if (startsWith$2(key).call(key, 'pluralForm')) {
	          var pluralFormIndex = _parseInt$2(key.substring(10));

	          pluralizationInfo[pluralFormIndex] = value;
	        } else {
	          interpolationParams[key] = value;
	        }
	      });

	      var isUsingPluralization = typeof phrase !== 'string';
	      locale = locale || self._initLocale;
	      var language = locale.substring(0, 2);
	      return isUsingPluralization ? TranslationProcessor.process(pluralizationInfo, interpolationParams, count, language, bind$2(_context4 = self.escapeExpression).call(_context4, self)) : TranslationProcessor.process(phrase, interpolationParams, null, null, bind$2(_context5 = self.escapeExpression).call(_context5, self));
	    });
	    self.registerHelper('icon', function (name, complexContentsParams, options) {
	      var icon = Icons["default"];

	      if (!Icons[name]) {
	        return self.SafeString(icon);
	      }

	      if (typeof Icons[name] === 'function') {
	        icon = Icons[name](complexContentsParams);
	      } else {
	        icon = Icons[name];
	      }

	      return self.SafeString(icon);
	    });
	    self.registerHelper('highlightValue', function (value, getInverted) {
	      var input = value.value || value.shortValue;
	      var highlightedVal = new HighlightedValue({
	        value: input,
	        matchedSubstrings: value.matchedSubstrings
	      });

	      var escapeFunction = function escapeFunction(val) {
	        return self.escapeExpression(val);
	      };

	      return getInverted ? self.SafeString(highlightedVal.getInvertedWithTransformFunction(escapeFunction)) : self.SafeString(highlightedVal.getWithTransformFunction(escapeFunction));
	    });
	  };

	  return HandlebarsRenderer;
	}(Renderer);

	/** @module */
	// E.g. Mustache, SOY, HandleBars, React, etc.

	var Renderers = {
	  SOY: Renderer,
	  Handlebars: HandlebarsRenderer
	};

	/**
	 * DefaultTemplatesLoader exposes an interface for loading the default set of compiled templates
	 * asynchronously from the server. Note that this class cannot be repurposed to fetch custom
	 * templates hosted by a client.
	 */

	var DefaultTemplatesLoader = /*#__PURE__*/function () {
	  function DefaultTemplatesLoader(onLoaded) {
	    if (!DefaultTemplatesLoader.setInstance(this)) {
	      return DefaultTemplatesLoader.getInstance();
	    }

	    this._templates = {};

	    this._onLoaded = onLoaded || function () {};
	  }

	  DefaultTemplatesLoader.setInstance = function setInstance(instance) {
	    if (!this.instance) {
	      this.instance = instance;
	      return true;
	    }

	    return false;
	  };

	  DefaultTemplatesLoader.getInstance = function getInstance() {
	    return this.instance;
	  };

	  var _proto = DefaultTemplatesLoader.prototype;

	  _proto.fetchTemplates = function fetchTemplates() {
	    // If template have already been loaded, do nothing
	    var node = DOM.query('#yext-answers-templates');

	    if (node) {
	      return promise$3.resolve();
	    } // Inject a script to fetch the compiled templates,
	    // wrapping it a Promise for cleanliness


	    return new promise$3(function (resolve, reject) {
	      var script = DOM.createEl('script', {
	        id: 'yext-answers-templates',
	        onload: resolve,
	        onerror: reject,
	        async: true,
	        src: COMPILED_TEMPLATES_URL
	      });
	      DOM.append('body', script);
	    });
	  }
	  /**
	   * register the templates internally so that they can be later consumed
	   * (e.g. by components and renderers) with convienience.
	   *
	   * This is called from inside handlebarswrapper.txt.
	   */
	  ;

	  _proto.register = function register(templates) {
	    this._templates = templates; // Notify our consumers that the templates are here :)

	    this._onLoaded(this._templates);

	    return this;
	  };

	  _proto.get = function get(templateName) {
	    return this._templates[templateName];
	  }
	  /**
	   * @return The internal template collection
	   */
	  ;

	  _proto.getTemplates = function getTemplates() {
	    return this._templates;
	  };

	  return DefaultTemplatesLoader;
	}();

	function ownKeys$4(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context3; forEach$2(_context3 = ownKeys$4(Object(source), true)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context4; forEach$2(_context4 = ownKeys$4(Object(source))).call(_context4, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/** @typedef {import('./storage/storage').default} Storage */

	/**
	 * Core is the main application container for all of the network and storage
	 * related behaviors of the application. It uses an instance of the external Core
	 * library to perform the actual network calls.
	 */

	var Core = /*#__PURE__*/function () {
	  function Core(config) {
	    if (config === void 0) {
	      config = {};
	    }

	    /**
	     * A reference to the client API Key used for all requests
	     * @type {string}
	     * @private
	     */
	    this._apiKey = config.apiKey;
	    /**
	     * A reference to the client Answers Key used for all requests
	     * @type {string}
	     * @private
	     */

	    this._experienceKey = config.experienceKey;
	    /**
	     * The answers config version to use for all requests
	     * @type {string}
	     * @private
	     */

	    this._experienceVersion = config.experienceVersion;
	    /**
	     * A reference to the client locale used for all requests. If not specified, defaults to "en" (for
	     * backwards compatibility).
	     * @type {string}
	     * @private
	     */

	    this._locale = config.locale;
	    /**
	     * A map of field formatters used to format results, if present
	     * @type {Object<string, function>}
	     * @private
	     */

	    this._fieldFormatters = config.fieldFormatters || {};
	    /**
	     * A reference to the core data storage that powers the UI
	     * @type {Storage}
	     */

	    this.storage = config.storage;
	    /**
	     * The filterRegistry is in charge of setting, removing, and retrieving filters
	     * and facet filters from storage.
	     * @type {FilterRegistry}
	     */

	    this.filterRegistry = new FilterRegistry(this.storage);
	    /**
	     * A local reference to the analytics reporter, used to report events for this component
	     * @type {AnalyticsReporter}
	     */

	    this._analyticsReporter = config.analyticsReporter;
	    /**
	     * A user-given function that returns an analytics event to fire after a universal search.
	     * @type {Function}
	     */

	    this.onUniversalSearch = config.onUniversalSearch || function () {};
	    /**
	     * A user-given function that returns an analytics event to fire after a vertical search.
	     * @type {Function}
	     */


	    this.onVerticalSearch = config.onVerticalSearch || function () {};
	    /**
	     * The environment which determines which URLs the requests use.
	     * @type {string}
	     */


	    this._environment = config.environment || PRODUCTION;
	    /**
	     * @type {string}
	     */

	    this._verticalKey = config.verticalKey;
	    /**
	     * @type {ComponentManager}
	     */

	    this._componentManager = config.componentManager;
	  }
	  /**
	   * Sets a reference in core to the global QueryUpdateListener.
	   *
	   * @param {QueryUpdateListener} queryUpdateListener
	   */


	  var _proto = Core.prototype;

	  _proto.setQueryUpdateListener = function setQueryUpdateListener(queryUpdateListener) {
	    this.queryUpdateListener = queryUpdateListener;
	  }
	  /**
	   * Initializes the {@link Core} by providing it with an instance of the Core library.
	   */
	  ;

	  _proto.init = function init() {
	    var params = {
	      apiKey: this._apiKey,
	      experienceKey: this._experienceKey,
	      locale: this._locale,
	      experienceVersion: this._experienceVersion,
	      endpoints: this._getServiceUrls(),
	      additionalQueryParams: {
	        jsLibVersion: LIB_VERSION
	      }
	    };
	    this._coreLibrary = commonjs_2(params);
	  }
	  /**
	   * Get the urls for each service based on the environment.
	   */
	  ;

	  _proto._getServiceUrls = function _getServiceUrls() {
	    return {
	      universalSearch: getLiveApiUrl(this._environment) + ENDPOINTS.UNIVERSAL_SEARCH,
	      verticalSearch: getLiveApiUrl(this._environment) + ENDPOINTS.VERTICAL_SEARCH,
	      questionSubmission: getKnowledgeApiUrl(this._environment) + ENDPOINTS.QUESTION_SUBMISSION,
	      universalAutocomplete: getCachedLiveApiUrl(this._environment) + ENDPOINTS.UNIVERSAL_AUTOCOMPLETE,
	      verticalAutocomplete: getCachedLiveApiUrl(this._environment) + ENDPOINTS.VERTICAL_AUTOCOMPLETE,
	      filterSearch: getCachedLiveApiUrl(this._environment) + ENDPOINTS.FILTER_SEARCH
	    };
	  }
	  /**
	   * @returns {boolean} A boolean indicating if the {@link Core} has been
	   *                    initailized.
	   */
	  ;

	  _proto.isInitialized = function isInitialized() {
	    return !!this._coreLibrary;
	  }
	  /**
	   * Search in the context of a vertical
	   * @param {string} verticalKey vertical ID for the search
	   * @param {Object} options additional settings for the search.
	   * @param {boolean} options.useFacets Whether to apply facets to this search, or to reset them instead
	   * @param {boolean} options.resetPagination Whether to reset the search offset, going back to page 1.
	   * @param {boolean} options.setQueryParams Whether to persist certain params in the url
	   * @param {string} options.sendQueryId Whether to send the queryId currently in storage.
	   *                                     If paging within a query, the same ID should be used.
	   * @param {Object} query The query details
	   * @param {string} query.input The input to search for
	   * @param {boolean} query.append If true, adds the results of this query to the end of the current results, defaults false
	   */
	  ;

	  _proto.verticalSearch = function verticalSearch(verticalKey, options, query) {
	    var _this = this;

	    if (options === void 0) {
	      options = {};
	    }

	    if (query === void 0) {
	      query = {};
	    }

	    window.performance.mark('yext.answers.verticalQueryStart');

	    if (!query.append) {
	      var verticalResults = this.storage.get(StorageKeys.VERTICAL_RESULTS);

	      if (!verticalResults || verticalResults.searchState !== SearchStates.SEARCH_LOADING) {
	        this.storage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading());
	      }

	      this.storage.set(StorageKeys.SPELL_CHECK, {});
	      this.storage.set(StorageKeys.LOCATION_BIAS, LocationBias$1.searchLoading());
	    }

	    var _options = options,
	        resetPagination = _options.resetPagination,
	        useFacets = _options.useFacets,
	        sendQueryId = _options.sendQueryId,
	        setQueryParams = _options.setQueryParams;

	    if (resetPagination) {
	      this.storage["delete"](StorageKeys.SEARCH_OFFSET);
	    }

	    if (!useFacets) {
	      this.filterRegistry.setFacetFilterNodes([], []);
	    }

	    var context = this.storage.get(StorageKeys.API_CONTEXT);
	    var referrerPageUrl = this.storage.get(StorageKeys.REFERRER_PAGE_URL);
	    var defaultQueryInput = this.storage.get(StorageKeys.QUERY) || '';

	    var parsedQuery = _extends({}, {
	      input: defaultQueryInput
	    }, query);

	    if (setQueryParams) {
	      if (context) {
	        this.storage.setWithPersist(StorageKeys.API_CONTEXT, context);
	      }

	      if (referrerPageUrl !== undefined) {
	        this.storage.setWithPersist(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	      }
	    }

	    var searchConfig = this.storage.get(StorageKeys.SEARCH_CONFIG) || {};

	    if (!searchConfig.verticalKey) {
	      this.storage.set(StorageKeys.SEARCH_CONFIG, _objectSpread$3(_objectSpread$3({}, searchConfig), {}, {
	        verticalKey: verticalKey
	      }));
	    }

	    var locationRadius = this._getLocationRadius();

	    var queryTrigger = this.storage.get(StorageKeys.QUERY_TRIGGER);
	    var queryTriggerForApi = this.getQueryTriggerForSearchApi(queryTrigger);
	    return this._coreLibrary.verticalSearch({
	      verticalKey: verticalKey || searchConfig.verticalKey,
	      limit: this.storage.get(StorageKeys.SEARCH_CONFIG).limit,
	      location: this._getLocationPayload(),
	      query: parsedQuery.input,
	      queryId: sendQueryId && this.storage.get(StorageKeys.QUERY_ID),
	      retrieveFacets: this._isDynamicFiltersEnabled,
	      facets: this.filterRegistry.getFacetsPayload(),
	      staticFilters: this.filterRegistry.getStaticFilterPayload(),
	      offset: this.storage.get(StorageKeys.SEARCH_OFFSET) || 0,
	      skipSpellCheck: this.storage.get(StorageKeys.SKIP_SPELL_CHECK),
	      queryTrigger: queryTriggerForApi,
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value,
	      sortBys: this.storage.get(StorageKeys.SORT_BYS),

	      /** In the SDK a locationRadius of 0 means "unset my locationRadius" */
	      locationRadius: locationRadius === 0 ? undefined : locationRadius,
	      context: context && JSON.parse(context),
	      referrerPageUrl: referrerPageUrl,
	      querySource: this.storage.get(StorageKeys.QUERY_SOURCE)
	    }).then(function (response) {
	      return SearchDataTransformer.transformVertical(response, _this._fieldFormatters, verticalKey);
	    }).then(function (data) {
	      _this._persistFacets();

	      _this._persistFilters();

	      _this._persistLocationRadius();

	      _this.storage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

	      _this.storage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

	      _this.storage.set(StorageKeys.ALTERNATIVE_VERTICALS, data[StorageKeys.ALTERNATIVE_VERTICALS]);

	      if (query.append) {
	        var mergedResults = _this.storage.get(StorageKeys.VERTICAL_RESULTS).append(data[StorageKeys.VERTICAL_RESULTS]);

	        _this.storage.set(StorageKeys.VERTICAL_RESULTS, mergedResults);
	      } else {
	        _this.storage.set(StorageKeys.VERTICAL_RESULTS, data[StorageKeys.VERTICAL_RESULTS]);
	      }

	      if (data[StorageKeys.DYNAMIC_FILTERS]) {
	        _this.storage.set(StorageKeys.DYNAMIC_FILTERS, data[StorageKeys.DYNAMIC_FILTERS]);

	        _this.storage.set(StorageKeys.RESULTS_HEADER, data[StorageKeys.DYNAMIC_FILTERS]);
	      }

	      if (data[StorageKeys.SPELL_CHECK]) {
	        _this.storage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);
	      }

	      if (data[StorageKeys.LOCATION_BIAS]) {
	        _this.storage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);
	      }

	      _this.storage["delete"](StorageKeys.SKIP_SPELL_CHECK);

	      _this.storage["delete"](StorageKeys.QUERY_TRIGGER);

	      var exposedParams = {
	        verticalKey: verticalKey,
	        queryString: parsedQuery.input,
	        resultsCount: _this.storage.get(StorageKeys.VERTICAL_RESULTS).resultsCount,
	        resultsContext: data[StorageKeys.VERTICAL_RESULTS].resultsContext
	      };

	      var analyticsEvent = _this.onVerticalSearch(exposedParams);

	      if (typeof analyticsEvent === 'object') {
	        _this._analyticsReporter.report(AnalyticsEvent.fromData(analyticsEvent));
	      }

	      _this.updateHistoryAfterSearch(queryTrigger);

	      window.performance.mark('yext.answers.verticalQueryResponseRendered');
	    });
	  };

	  _proto.clearResults = function clearResults() {
	    this.storage.set(StorageKeys.QUERY, null);
	    this.storage.set(StorageKeys.QUERY_ID, '');
	    this.storage.set(StorageKeys.RESULTS_HEADER, {});
	    this.storage.set(StorageKeys.SPELL_CHECK, {}); // TODO has a model but not cleared w new

	    this.storage.set(StorageKeys.DYNAMIC_FILTERS, {}); // TODO has a model but not cleared w new

	    this.storage.set(StorageKeys.QUESTION_SUBMISSION, new QuestionSubmission({}));
	    this.storage.set(StorageKeys.NAVIGATION, new Navigation());
	    this.storage.set(StorageKeys.ALTERNATIVE_VERTICALS, new AlternativeVerticals({}));
	    this.storage.set(StorageKeys.DIRECT_ANSWER, new DirectAnswer({}));
	    this.storage.set(StorageKeys.LOCATION_BIAS, new LocationBias$1({}));
	    this.storage.set(StorageKeys.VERTICAL_RESULTS, new VerticalResults({}));
	    this.storage.set(StorageKeys.UNIVERSAL_RESULTS, new UniversalResults({}));
	  }
	  /**
	   * Page within the results of the last query
	   */
	  ;

	  _proto.verticalPage = function verticalPage() {
	    this.triggerSearch(QueryTriggers.PAGINATION);
	  };

	  _proto.search = function search(queryString, options) {
	    var _this2 = this;

	    if (options === void 0) {
	      options = {};
	    }

	    var urls = this._getUrls(queryString);

	    window.performance.mark('yext.answers.universalQueryStart');
	    var _options2 = options,
	        setQueryParams = _options2.setQueryParams;
	    var context = this.storage.get(StorageKeys.API_CONTEXT);
	    var referrerPageUrl = this.storage.get(StorageKeys.REFERRER_PAGE_URL);

	    if (setQueryParams) {
	      if (context) {
	        this.storage.setWithPersist(StorageKeys.API_CONTEXT, context);
	      }

	      if (referrerPageUrl !== undefined) {
	        this.storage.setWithPersist(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	      }
	    }

	    this.storage.set(StorageKeys.DIRECT_ANSWER, {});
	    var universalResults = this.storage.get(StorageKeys.UNIVERSAL_RESULTS);

	    if (!universalResults || universalResults.searchState !== SearchStates.SEARCH_LOADING) {
	      this.storage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
	    }

	    this.storage.set(StorageKeys.QUESTION_SUBMISSION, {});
	    this.storage.set(StorageKeys.SPELL_CHECK, {});
	    this.storage.set(StorageKeys.LOCATION_BIAS, LocationBias$1.searchLoading());
	    var queryTrigger = this.storage.get(StorageKeys.QUERY_TRIGGER);
	    var queryTriggerForApi = this.getQueryTriggerForSearchApi(queryTrigger);
	    return this._coreLibrary.universalSearch({
	      query: queryString,
	      location: this._getLocationPayload(),
	      skipSpellCheck: this.storage.get(StorageKeys.SKIP_SPELL_CHECK),
	      queryTrigger: queryTriggerForApi,
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value,
	      context: context && JSON.parse(context),
	      referrerPageUrl: referrerPageUrl,
	      querySource: this.storage.get(StorageKeys.QUERY_SOURCE)
	    }).then(function (response) {
	      return SearchDataTransformer.transformUniversal(response, urls, _this2._fieldFormatters);
	    }).then(function (data) {
	      _this2.storage.set(StorageKeys.QUERY_ID, data[StorageKeys.QUERY_ID]);

	      _this2.storage.set(StorageKeys.NAVIGATION, data[StorageKeys.NAVIGATION]);

	      _this2.storage.set(StorageKeys.DIRECT_ANSWER, data[StorageKeys.DIRECT_ANSWER]);

	      _this2.storage.set(StorageKeys.UNIVERSAL_RESULTS, data[StorageKeys.UNIVERSAL_RESULTS]);

	      _this2.storage.set(StorageKeys.SPELL_CHECK, data[StorageKeys.SPELL_CHECK]);

	      _this2.storage.set(StorageKeys.LOCATION_BIAS, data[StorageKeys.LOCATION_BIAS]);

	      _this2.storage["delete"](StorageKeys.SKIP_SPELL_CHECK);

	      _this2.storage["delete"](StorageKeys.QUERY_TRIGGER);

	      var exposedParams = _this2._getOnUniversalSearchParams(data[StorageKeys.UNIVERSAL_RESULTS].sections, queryString);

	      var analyticsEvent = _this2.onUniversalSearch(exposedParams);

	      if (typeof analyticsEvent === 'object') {
	        _this2._analyticsReporter.report(AnalyticsEvent.fromData(analyticsEvent));
	      }

	      _this2.updateHistoryAfterSearch(queryTrigger);

	      window.performance.mark('yext.answers.universalQueryResponseRendered');
	    });
	  }
	  /**
	   * Builds the object passed as a parameter to onUniversalSearch. This object
	   * contains information about the universal search's query and result counts.
	   *
	   * @param {Array<Section>} sections The sections of results.
	   * @param {string} queryString The search query.
	   * @return {Object<string, ?>}
	   */
	  ;

	  _proto._getOnUniversalSearchParams = function _getOnUniversalSearchParams(sections, queryString) {
	    var resultsCountByVertical = reduce$2(sections).call(sections, function (resultsCountMap, section) {
	      var verticalConfigId = section.verticalConfigId,
	          resultsCount = section.resultsCount,
	          results = section.results;
	      resultsCountMap[verticalConfigId] = {
	        totalResultsCount: resultsCount,
	        displayedResultsCount: results.length
	      };
	      return resultsCountMap;
	    }, {});

	    var exposedParams = {
	      queryString: queryString,
	      sectionsCount: sections.length,
	      resultsCountByVertical: resultsCountByVertical
	    };
	    return exposedParams;
	  }
	  /**
	   * Given an input, query for a list of similar results and set into storage
	   *
	   * @param {string} input     the string to autocomplete
	   * @param {string} namespace the namespace to use for the storage key
	   */
	  ;

	  _proto.autoCompleteUniversal = function autoCompleteUniversal(input, namespace) {
	    var _this3 = this;

	    return this._coreLibrary.universalAutocomplete({
	      input: input,
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value
	    }).then(function (response) {
	      return AutoCompleteResponseTransformer.transformAutoCompleteResponse(response);
	    }).then(function (data) {
	      _this3.storage.set(StorageKeys.AUTOCOMPLETE + "." + namespace, data);

	      return data;
	    });
	  }
	  /**
	   * Given an input, query for a list of similar results in the provided vertical
	   * and set into storage
	   *
	   * @param {string} input       the string to autocomplete
	   * @param {string} namespace the namespace to use for the storage key
	   * @param {string} verticalKey the vertical key for the experience
	   */
	  ;

	  _proto.autoCompleteVertical = function autoCompleteVertical(input, namespace, verticalKey) {
	    var _this4 = this;

	    return this._coreLibrary.verticalAutocomplete({
	      input: input,
	      verticalKey: verticalKey,
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value
	    }).then(function (response) {
	      return AutoCompleteResponseTransformer.transformAutoCompleteResponse(response);
	    }).then(function (data) {
	      _this4.storage.set(StorageKeys.AUTOCOMPLETE + "." + namespace, data);

	      return data;
	    });
	  }
	  /**
	   * Given an input, provide a list of suitable filters for autocompletion
	   *
	   * @param {string} input  the string to search for filters with
	   * @param {object} config  the config to serach for filters with
	   * @param {string} config.namespace  the namespace to use for the storage key
	   * @param {string} config.verticalKey the vertical key for the config
	   * @param {object} config.searchParameters  the search parameters for the config v2
	   */
	  ;

	  _proto.autoCompleteFilter = function autoCompleteFilter(input, config) {
	    var _context,
	        _this5 = this;

	    var searchParamFields = map$2(_context = config.searchParameters.fields).call(_context, function (field) {
	      return {
	        fieldApiName: field.fieldId,
	        entityType: field.entityTypeId,
	        fetchEntities: field.shouldFetchEntities
	      };
	    });

	    return this._coreLibrary.filterSearch({
	      input: input,
	      verticalKey: config.verticalKey,
	      fields: searchParamFields,
	      sectioned: config.searchParameters.sectioned,
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value
	    }).then(function (response) {
	      return AutoCompleteResponseTransformer.transformFilterSearchResponse(response);
	    }).then(function (data) {
	      _this5.storage.set(StorageKeys.AUTOCOMPLETE + "." + config.namespace, data);
	    });
	  }
	  /**
	   * Submits a question to the server and updates the underlying question model
	   * @param {object} question The question object to submit to the server
	   * @param {number} question.entityId The entity to associate with the question (required)
	   * @param {string} question.site The "publisher" of the (e.g. 'FIRST_PARTY')
	   * @param {string} question.name The name of the author
	   * @param {string} question.email The email address of the author
	   * @param {string} question.questionText The question
	   * @param {string} question.questionDescription Additional information about the question
	   */
	  ;

	  _proto.submitQuestion = function submitQuestion(question) {
	    var _this6 = this;

	    return this._coreLibrary.submitQuestion(_objectSpread$3(_objectSpread$3({}, question), {}, {
	      sessionTrackingEnabled: this.storage.get(StorageKeys.SESSIONS_OPT_IN).value
	    })).then(function () {
	      _this6.storage.set(StorageKeys.QUESTION_SUBMISSION, QuestionSubmission.submitted());
	    });
	  }
	  /**
	   * Stores the given sortBy into storage, to be used for the next search
	   * @param {Object} sortByOptions
	   */
	  ;

	  _proto.setSortBys = function setSortBys() {
	    for (var _len = arguments.length, sortByOptions = new Array(_len), _key = 0; _key < _len; _key++) {
	      sortByOptions[_key] = arguments[_key];
	    }

	    var sortBys = map$2(sortByOptions).call(sortByOptions, function (option) {
	      return {
	        type: option.type,
	        field: option.field,
	        direction: option.direction
	      };
	    });

	    this.storage.setWithPersist(StorageKeys.SORT_BYS, sortBys);
	  }
	  /**
	   * Clears the sortBys key in storage.
	   */
	  ;

	  _proto.clearSortBys = function clearSortBys() {
	    this.storage["delete"](StorageKeys.SORT_BYS);
	  }
	  /**
	   * Stores the given query into storage, to be used for the next search
	   * @param {string} query the query to store
	   */
	  ;

	  _proto.setQuery = function setQuery(query) {
	    this.storage.setWithPersist(StorageKeys.QUERY, query);
	  }
	  /**
	   * Stores the provided query ID, to be used in analytics
	   * @param {string} queryId The query id to store
	   */
	  ;

	  _proto.setQueryId = function setQueryId(queryId) {
	    this.storage.set(StorageKeys.QUERY_ID, queryId);
	  };

	  _proto.triggerSearch = function triggerSearch(queryTrigger, newQuery) {
	    var query = newQuery !== undefined ? newQuery : this.storage.get(StorageKeys.QUERY) || '';
	    queryTrigger ? this.storage.set(StorageKeys.QUERY_TRIGGER, queryTrigger) : this.storage["delete"](StorageKeys.QUERY_TRIGGER);
	    this.setQuery(query);
	  }
	  /**
	   * Get all of the {@link FilterNode}s for static filters.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getStaticFilterNodes = function getStaticFilterNodes() {
	    return this.filterRegistry.getStaticFilterNodes();
	  }
	  /**
	   * Get all of the active {@link FilterNode}s for facets.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto.getFacetFilterNodes = function getFacetFilterNodes() {
	    return this.filterRegistry.getFacetFilterNodes();
	  }
	  /**
	   * Get the {@link FilterNode} affecting the locationRadius url parameter.
	   * @returns {FilterNode}
	   */
	  ;

	  _proto.getLocationRadiusFilterNode = function getLocationRadiusFilterNode() {
	    return this.filterRegistry.getFilterNodeByKey(StorageKeys.LOCATION_RADIUS_FILTER_NODE);
	  }
	  /**
	   * Sets the filter nodes used for the current facet filters.
	   *
	   * Because the search response only sends back one
	   * set of facet filters, there can only be one active facet filter node
	   * at a time.
	   * @param {Array<string>} availableFieldIds
	   * @param {Array<FilterNode>} filterNodes
	   */
	  ;

	  _proto.setFacetFilterNodes = function setFacetFilterNodes(availableFieldids, filterNodes) {
	    if (availableFieldids === void 0) {
	      availableFieldids = [];
	    }

	    if (filterNodes === void 0) {
	      filterNodes = [];
	    }

	    this.filterRegistry.setFacetFilterNodes(availableFieldids, filterNodes);
	  }
	  /**
	   * Sets the specified {@link FilterNode} under the given key.
	   * Will replace a preexisting node if there is one.
	   * @param {string} namespace
	   * @param {FilterNode} filterNode
	   */
	  ;

	  _proto.setStaticFilterNodes = function setStaticFilterNodes(namespace, filterNode) {
	    this.filterRegistry.setStaticFilterNodes(namespace, filterNode);
	  }
	  /**
	   * Sets the locationRadius filterNode.
	   * @param {FilterNode} filterNode
	   */
	  ;

	  _proto.setLocationRadiusFilterNode = function setLocationRadiusFilterNode(filterNode) {
	    this.filterRegistry.setLocationRadiusFilterNode(filterNode);
	  }
	  /**
	   * Remove the static FilterNode with this namespace.
	   * @param {string} namespace
	   */
	  ;

	  _proto.clearStaticFilterNode = function clearStaticFilterNode(namespace) {
	    this.filterRegistry.clearStaticFilterNode(namespace);
	  }
	  /**
	   * Remove all facet FilterNodes.
	   */
	  ;

	  _proto.clearFacetFilterNodes = function clearFacetFilterNodes() {
	    this.filterRegistry.clearFacetFilterNodes();
	  }
	  /**
	   * Clears the locationRadius filterNode.
	   */
	  ;

	  _proto.clearLocationRadiusFilterNode = function clearLocationRadiusFilterNode() {
	    this.filterRegistry.clearLocationRadiusFilterNode();
	  }
	  /**
	   * Gets the location object needed for answers-core
	   *
	   * @returns {LatLong|undefined} from answers-core
	   */
	  ;

	  _proto._getLocationPayload = function _getLocationPayload() {
	    var geolocation = this.storage.get(StorageKeys.GEOLOCATION);
	    return geolocation && {
	      latitude: geolocation.lat,
	      longitude: geolocation.lng
	    };
	  }
	  /**
	   * Returns the query trigger for the search API given the SDK query trigger
	   * @param {QueryTriggers} queryTrigger SDK query trigger
	   * @returns {QueryTriggers} query trigger if accepted by the search API, null o/w
	   */
	  ;

	  _proto.getQueryTriggerForSearchApi = function getQueryTriggerForSearchApi(queryTrigger) {
	    var _context2;

	    if (!includes$4(_context2 = [QueryTriggers.INITIALIZE, QueryTriggers.SUGGEST]).call(_context2, queryTrigger)) {
	      return null;
	    }

	    return queryTrigger;
	  }
	  /**
	   * Depending on the QUERY_TRIGGER, either replaces the history state
	   * for searches on load/back navigation (INITIALIZE, SUGGEST, QUERY_PARAMETER),
	   * or pushes a new state.
	   *
	   * @param {QueryTriggers} queryTrigger SDK query trigger
	   * @returns {boolean}
	   */
	  ;

	  _proto.updateHistoryAfterSearch = function updateHistoryAfterSearch(queryTrigger) {
	    var replaceStateTriggers = [QueryTriggers.INITIALIZE, QueryTriggers.SUGGEST, QueryTriggers.QUERY_PARAMETER];

	    if (includes$4(replaceStateTriggers).call(replaceStateTriggers, queryTrigger)) {
	      this.storage.replaceHistoryWithState();
	    } else {
	      this.storage.pushStateToHistory();
	    }
	  }
	  /**
	   * Returns the current `locationRadius` state
	   * @returns {number|null}
	   */
	  ;

	  _proto._getLocationRadius = function _getLocationRadius() {
	    var locationRadiusFilterNode = this.getLocationRadiusFilterNode();
	    return locationRadiusFilterNode ? locationRadiusFilterNode.getFilter().value : null;
	  }
	  /**
	   * Persists the current `facetFilters` state into the URL.
	   */
	  ;

	  _proto._persistFacets = function _persistFacets() {
	    var persistedFacets = this.filterRegistry.getFacets();
	    this.storage.setWithPersist(StorageKeys.PERSISTED_FACETS, persistedFacets);
	  }
	  /**
	   * Persists the current `filters` state into the URL.
	   */
	  ;

	  _proto._persistFilters = function _persistFilters() {
	    var totalFilterNode = this.filterRegistry.getAllStaticFilterNodesCombined();
	    var persistedFilter = totalFilterNode.getFilter();
	    this.storage.setWithPersist(StorageKeys.PERSISTED_FILTER, persistedFilter);
	  }
	  /**
	   * Persists the current `locationRadius` state into the URL.
	   */
	  ;

	  _proto._persistLocationRadius = function _persistLocationRadius() {
	    var locationRadius = this._getLocationRadius();

	    if (locationRadius || locationRadius === 0) {
	      this.storage.setWithPersist(StorageKeys.PERSISTED_LOCATION_RADIUS, locationRadius);
	    } else {
	      this.storage["delete"](StorageKeys.PERSISTED_LOCATION_RADIUS);
	    }
	  };

	  _proto.enableDynamicFilters = function enableDynamicFilters() {
	    this._isDynamicFiltersEnabled = true;
	  };

	  _proto.on = function on(evt, storageKey, cb) {
	    this.storage.registerListener({
	      eventType: evt,
	      storageKey: storageKey,
	      callback: cb
	    });
	    return this.storage;
	  }
	  /**
	   * This is needed to support very old usages of the SDK that have not been updated
	   * to use StorageKeys.VERTICAL_PAGES_CONFIG
	   */
	  ;

	  _proto._getUrls = function _getUrls(query) {
	    var nav = this._componentManager.getActiveComponent('Navigation');

	    if (!nav) {
	      return undefined;
	    }

	    var tabs = nav.getState('tabs');
	    var urls = {};

	    if (tabs && isArray$3(tabs)) {
	      for (var i = 0; i < tabs.length; i++) {
	        var params = new SearchParams(tabs[i].url.split('?')[1]);
	        params.set('query', query);
	        var url = tabs[i].baseUrl;

	        if (params.toString().length > 0) {
	          url += '?' + params.toString();
	        }

	        urls[tabs[i].configId] = url;
	      }
	    }

	    return urls;
	  };

	  return Core;
	}();

	/*!
	 * css-vars-ponyfill
	 * v2.4.3
	 * https://jhildenbiddle.github.io/css-vars-ponyfill/
	 * (c) 2018-2021 John Hildenbiddle <http://hildenbiddle.com>
	 * MIT license
	 */
	function _extends$1() {
	    _extends$1 = Object.assign || function(target) {
	        for (var i = 1; i < arguments.length; i++) {
	            var source = arguments[i];
	            for (var key in source) {
	                if (Object.prototype.hasOwnProperty.call(source, key)) {
	                    target[key] = source[key];
	                }
	            }
	        }
	        return target;
	    };
	    return _extends$1.apply(this, arguments);
	}

	/*!
	 * get-css-data
	 * v2.0.0
	 * https://github.com/jhildenbiddle/get-css-data
	 * (c) 2018-2021 John Hildenbiddle <http://hildenbiddle.com>
	 * MIT license
	 */ function getUrls(urls) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var settings = {
	        mimeType: options.mimeType || null,
	        onBeforeSend: options.onBeforeSend || Function.prototype,
	        onSuccess: options.onSuccess || Function.prototype,
	        onError: options.onError || Function.prototype,
	        onComplete: options.onComplete || Function.prototype
	    };
	    var urlArray = Array.isArray(urls) ? urls : [ urls ];
	    var urlQueue = Array.apply(null, Array(urlArray.length)).map((function(x) {
	        return null;
	    }));
	    function isValidCss(cssText) {
	        var isHTML = cssText && cssText.trim().charAt(0) === "<";
	        return cssText && !isHTML;
	    }
	    function onError(xhr, urlIndex) {
	        settings.onError(xhr, urlArray[urlIndex], urlIndex);
	    }
	    function onSuccess(responseText, urlIndex) {
	        var returnVal = settings.onSuccess(responseText, urlArray[urlIndex], urlIndex);
	        responseText = returnVal === false ? "" : returnVal || responseText;
	        urlQueue[urlIndex] = responseText;
	        if (urlQueue.indexOf(null) === -1) {
	            settings.onComplete(urlQueue);
	        }
	    }
	    var parser = document.createElement("a");
	    urlArray.forEach((function(url, i) {
	        parser.setAttribute("href", url);
	        parser.href = String(parser.href);
	        var isIElte9 = Boolean(document.all && !window.atob);
	        var isIElte9CORS = isIElte9 && parser.host.split(":")[0] !== location.host.split(":")[0];
	        if (isIElte9CORS) {
	            var isSameProtocol = parser.protocol === location.protocol;
	            if (isSameProtocol) {
	                var xdr = new XDomainRequest;
	                xdr.open("GET", url);
	                xdr.timeout = 0;
	                xdr.onprogress = Function.prototype;
	                xdr.ontimeout = Function.prototype;
	                xdr.onload = function() {
	                    if (isValidCss(xdr.responseText)) {
	                        onSuccess(xdr.responseText, i);
	                    } else {
	                        onError(xdr, i);
	                    }
	                };
	                xdr.onerror = function(err) {
	                    onError(xdr, i);
	                };
	                setTimeout((function() {
	                    xdr.send();
	                }), 0);
	            } else {
	                console.warn("Internet Explorer 9 Cross-Origin (CORS) requests must use the same protocol (".concat(url, ")"));
	                onError(null, i);
	            }
	        } else {
	            var xhr = new XMLHttpRequest;
	            xhr.open("GET", url);
	            if (settings.mimeType && xhr.overrideMimeType) {
	                xhr.overrideMimeType(settings.mimeType);
	            }
	            settings.onBeforeSend(xhr, url, i);
	            xhr.onreadystatechange = function() {
	                if (xhr.readyState === 4) {
	                    if (xhr.status < 400 && isValidCss(xhr.responseText)) {
	                        onSuccess(xhr.responseText, i);
	                    } else if (xhr.status === 0 && isValidCss(xhr.responseText)) {
	                        onSuccess(xhr.responseText, i);
	                    } else {
	                        onError(xhr, i);
	                    }
	                }
	            };
	            xhr.send();
	        }
	    }));
	}

	/**
	 * Gets CSS data from <style> and <link> nodes (including @imports), then
	 * returns data in order processed by DOM. Allows specifying nodes to
	 * include/exclude and filtering CSS data using RegEx.
	 *
	 * @preserve
	 * @param {object}   [options] The options object
	 * @param {object}   [options.rootElement=document] Root element to traverse for
	 *                   <link> and <style> nodes.
	 * @param {string}   [options.include] CSS selector matching <link> and <style>
	 *                   nodes to include
	 * @param {string}   [options.exclude] CSS selector matching <link> and <style>
	 *                   nodes to exclude
	 * @param {object}   [options.filter] Regular expression used to filter node CSS
	 *                   data. Each block of CSS data is tested against the filter,
	 *                   and only matching data is included.
	 * @param {boolean}  [options.skipDisabled=true] Determines if disabled
	 *                   stylesheets will be skipped while collecting CSS data.
	 * @param {boolean}  [options.useCSSOM=false] Determines if CSS data will be
	 *                   collected from a stylesheet's runtime values instead of its
	 *                   text content. This is required to get accurate CSS data
	 *                   when a stylesheet has been modified using the deleteRule()
	 *                   or insertRule() methods because these modifications will
	 *                   not be reflected in the stylesheet's text content.
	 * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
	 *                   1) the XHR object, 2) source node reference, and 3) the
	 *                   source URL as arguments.
	 * @param {function} [options.onSuccess] Callback on each CSS node read. Passes
	 *                   1) CSS text, 2) source node reference, and 3) the source
	 *                   URL as arguments.
	 * @param {function} [options.onError] Callback on each error. Passes 1) the XHR
	 *                   object for inspection, 2) soure node reference, and 3) the
	 *                   source URL that failed (either a <link> href or an @import)
	 *                   as arguments
	 * @param {function} [options.onComplete] Callback after all nodes have been
	 *                   processed. Passes 1) concatenated CSS text, 2) an array of
	 *                   CSS text in DOM order, and 3) an array of nodes in DOM
	 *                   order as arguments.
	 *
	 * @example
	 *
	 *   getCssData({
	 *     rootElement : document,
	 *     include     : 'style,link[rel="stylesheet"]',
	 *     exclude     : '[href="skip.css"]',
	 *     filter      : /red/,
	 *     skipDisabled: true,
	 *     useCSSOM    : false,
	 *     onBeforeSend(xhr, node, url) {
	 *       // ...
	 *     }
	 *     onSuccess(cssText, node, url) {
	 *       // ...
	 *     }
	 *     onError(xhr, node, url) {
	 *       // ...
	 *     },
	 *     onComplete(cssText, cssArray, nodeArray) {
	 *       // ...
	 *     }
	 *   });
	 */ function getCssData(options) {
	    var regex = {
	        cssComments: /\/\*[\s\S]+?\*\//g,
	        cssImports: /(?:@import\s*)(?:url\(\s*)?(?:['"])([^'"]*)(?:['"])(?:\s*\))?(?:[^;]*;)/g
	    };
	    var settings = {
	        rootElement: options.rootElement || document,
	        include: options.include || 'style,link[rel="stylesheet"]',
	        exclude: options.exclude || null,
	        filter: options.filter || null,
	        skipDisabled: options.skipDisabled !== false,
	        useCSSOM: options.useCSSOM || false,
	        onBeforeSend: options.onBeforeSend || Function.prototype,
	        onSuccess: options.onSuccess || Function.prototype,
	        onError: options.onError || Function.prototype,
	        onComplete: options.onComplete || Function.prototype
	    };
	    var sourceNodes = Array.apply(null, settings.rootElement.querySelectorAll(settings.include)).filter((function(node) {
	        return !matchesSelector(node, settings.exclude);
	    }));
	    var cssArray = Array.apply(null, Array(sourceNodes.length)).map((function(x) {
	        return null;
	    }));
	    function handleComplete() {
	        var isComplete = cssArray.indexOf(null) === -1;
	        if (isComplete) {
	            cssArray.reduce((function(skipIndices, value, i) {
	                if (value === "") {
	                    skipIndices.push(i);
	                }
	                return skipIndices;
	            }), []).reverse().forEach((function(skipIndex) {
	                return [ sourceNodes, cssArray ].forEach((function(arr) {
	                    return arr.splice(skipIndex, 1);
	                }));
	            }));
	            var cssText = cssArray.join("");
	            settings.onComplete(cssText, cssArray, sourceNodes);
	        }
	    }
	    function handleSuccess(cssText, cssIndex, node, sourceUrl) {
	        var returnVal = settings.onSuccess(cssText, node, sourceUrl);
	        cssText = returnVal !== undefined && Boolean(returnVal) === false ? "" : returnVal || cssText;
	        resolveImports(cssText, node, sourceUrl, (function(resolvedCssText, errorData) {
	            if (cssArray[cssIndex] === null) {
	                errorData.forEach((function(data) {
	                    return settings.onError(data.xhr, node, data.url);
	                }));
	                if (!settings.filter || settings.filter.test(resolvedCssText)) {
	                    cssArray[cssIndex] = resolvedCssText;
	                } else {
	                    cssArray[cssIndex] = "";
	                }
	                handleComplete();
	            }
	        }));
	    }
	    function parseImportData(cssText, baseUrl) {
	        var ignoreRules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	        var importData = {};
	        importData.rules = (cssText.replace(regex.cssComments, "").match(regex.cssImports) || []).filter((function(rule) {
	            return ignoreRules.indexOf(rule) === -1;
	        }));
	        importData.urls = importData.rules.map((function(rule) {
	            return rule.replace(regex.cssImports, "$1");
	        }));
	        importData.absoluteUrls = importData.urls.map((function(url) {
	            return getFullUrl(url, baseUrl);
	        }));
	        importData.absoluteRules = importData.rules.map((function(rule, i) {
	            var oldUrl = importData.urls[i];
	            var newUrl = getFullUrl(importData.absoluteUrls[i], baseUrl);
	            return rule.replace(oldUrl, newUrl);
	        }));
	        return importData;
	    }
	    function resolveImports(cssText, node, baseUrl, callbackFn) {
	        var __errorData = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
	        var __errorRules = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
	        var importData = parseImportData(cssText, baseUrl, __errorRules);
	        if (importData.rules.length) {
	            getUrls(importData.absoluteUrls, {
	                onBeforeSend: function onBeforeSend(xhr, url, urlIndex) {
	                    settings.onBeforeSend(xhr, node, url);
	                },
	                onSuccess: function onSuccess(cssText, url, urlIndex) {
	                    var returnVal = settings.onSuccess(cssText, node, url);
	                    cssText = returnVal === false ? "" : returnVal || cssText;
	                    var responseImportData = parseImportData(cssText, url, __errorRules);
	                    responseImportData.rules.forEach((function(rule, i) {
	                        cssText = cssText.replace(rule, responseImportData.absoluteRules[i]);
	                    }));
	                    return cssText;
	                },
	                onError: function onError(xhr, url, urlIndex) {
	                    __errorData.push({
	                        xhr: xhr,
	                        url: url
	                    });
	                    __errorRules.push(importData.rules[urlIndex]);
	                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
	                },
	                onComplete: function onComplete(responseArray) {
	                    responseArray.forEach((function(importText, i) {
	                        cssText = cssText.replace(importData.rules[i], importText);
	                    }));
	                    resolveImports(cssText, node, baseUrl, callbackFn, __errorData, __errorRules);
	                }
	            });
	        } else {
	            callbackFn(cssText, __errorData);
	        }
	    }
	    if (sourceNodes.length) {
	        sourceNodes.forEach((function(node, i) {
	            var linkHref = node.getAttribute("href");
	            var linkRel = node.getAttribute("rel");
	            var isLink = node.nodeName.toLowerCase() === "link" && linkHref && linkRel && linkRel.toLowerCase().indexOf("stylesheet") !== -1;
	            var isSkip = settings.skipDisabled === false ? false : node.disabled;
	            var isStyle = node.nodeName.toLowerCase() === "style";
	            if (isLink && !isSkip) {
	                getUrls(linkHref, {
	                    mimeType: "text/css",
	                    onBeforeSend: function onBeforeSend(xhr, url, urlIndex) {
	                        settings.onBeforeSend(xhr, node, url);
	                    },
	                    onSuccess: function onSuccess(cssText, url, urlIndex) {
	                        var sourceUrl = getFullUrl(linkHref);
	                        handleSuccess(cssText, i, node, sourceUrl);
	                    },
	                    onError: function onError(xhr, url, urlIndex) {
	                        cssArray[i] = "";
	                        settings.onError(xhr, node, url);
	                        handleComplete();
	                    }
	                });
	            } else if (isStyle && !isSkip) {
	                var cssText = node.textContent;
	                if (settings.useCSSOM) {
	                    cssText = Array.apply(null, node.sheet.cssRules).map((function(rule) {
	                        return rule.cssText;
	                    })).join("");
	                }
	                handleSuccess(cssText, i, node, location.href);
	            } else {
	                cssArray[i] = "";
	                handleComplete();
	            }
	        }));
	    } else {
	        settings.onComplete("", []);
	    }
	}

	function getFullUrl(url, base) {
	    var d = document.implementation.createHTMLDocument("");
	    var b = d.createElement("base");
	    var a = d.createElement("a");
	    d.head.appendChild(b);
	    d.body.appendChild(a);
	    b.href = base || document.baseURI || (document.querySelector("base") || {}).href || location.href;
	    a.href = url;
	    return a.href;
	}

	function matchesSelector(elm, selector) {
	    var matches = elm.matches || elm.matchesSelector || elm.webkitMatchesSelector || elm.mozMatchesSelector || elm.msMatchesSelector || elm.oMatchesSelector;
	    return matches.call(elm, selector);
	}

	var balancedMatch = balanced;

	function balanced(a, b, str) {
	    if (a instanceof RegExp) a = maybeMatch(a, str);
	    if (b instanceof RegExp) b = maybeMatch(b, str);
	    var r = range(a, b, str);
	    return r && {
	        start: r[0],
	        end: r[1],
	        pre: str.slice(0, r[0]),
	        body: str.slice(r[0] + a.length, r[1]),
	        post: str.slice(r[1] + b.length)
	    };
	}

	function maybeMatch(reg, str) {
	    var m = str.match(reg);
	    return m ? m[0] : null;
	}

	balanced.range = range;

	function range(a, b, str) {
	    var begs, beg, left, right, result;
	    var ai = str.indexOf(a);
	    var bi = str.indexOf(b, ai + 1);
	    var i = ai;
	    if (ai >= 0 && bi > 0) {
	        begs = [];
	        left = str.length;
	        while (i >= 0 && !result) {
	            if (i == ai) {
	                begs.push(i);
	                ai = str.indexOf(a, i + 1);
	            } else if (begs.length == 1) {
	                result = [ begs.pop(), bi ];
	            } else {
	                beg = begs.pop();
	                if (beg < left) {
	                    left = beg;
	                    right = bi;
	                }
	                bi = str.indexOf(b, i + 1);
	            }
	            i = ai < bi && ai >= 0 ? ai : bi;
	        }
	        if (begs.length) {
	            result = [ left, right ];
	        }
	    }
	    return result;
	}

	function parseCss(css) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var defaults = {
	        preserveStatic: true,
	        removeComments: false
	    };
	    var settings = _extends$1({}, defaults, options);
	    var errors = [];
	    function error(msg) {
	        throw new Error("CSS parse error: ".concat(msg));
	    }
	    function match(re) {
	        var m = re.exec(css);
	        if (m) {
	            css = css.slice(m[0].length);
	            return m;
	        }
	    }
	    function open() {
	        return match(/^{\s*/);
	    }
	    function close() {
	        return match(/^}/);
	    }
	    function whitespace() {
	        match(/^\s*/);
	    }
	    function comment() {
	        whitespace();
	        if (css[0] !== "/" || css[1] !== "*") {
	            return;
	        }
	        var i = 2;
	        while (css[i] && (css[i] !== "*" || css[i + 1] !== "/")) {
	            i++;
	        }
	        if (!css[i]) {
	            return error("end of comment is missing");
	        }
	        var str = css.slice(2, i);
	        css = css.slice(i + 2);
	        return {
	            type: "comment",
	            comment: str
	        };
	    }
	    function comments() {
	        var cmnts = [];
	        var c;
	        while (c = comment()) {
	            cmnts.push(c);
	        }
	        return settings.removeComments ? [] : cmnts;
	    }
	    function selector() {
	        whitespace();
	        while (css[0] === "}") {
	            error("extra closing bracket");
	        }
	        var m = match(/^(("(?:\\"|[^"])*"|'(?:\\'|[^'])*'|[^{])+)/);
	        if (m) {
	            return m[0].trim().replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, (function(m) {
	                return m.replace(/,/g, "‌");
	            })).split(/\s*(?![^(]*\)),\s*/).map((function(s) {
	                return s.replace(/\u200C/g, ",");
	            }));
	        }
	    }
	    function declaration() {
	        if (css[0] === "@") {
	            return at_rule();
	        }
	        match(/^([;\s]*)+/);
	        var comment_regexp = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
	        var prop = match(/^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
	        if (!prop) {
	            return;
	        }
	        prop = prop[0].trim();
	        if (!match(/^:\s*/)) {
	            return error("property missing ':'");
	        }
	        var val = match(/^((?:\/\*.*?\*\/|'(?:\\'|.)*?'|"(?:\\"|.)*?"|\((\s*'(?:\\'|.)*?'|"(?:\\"|.)*?"|[^)]*?)\s*\)|[^};])+)/);
	        var ret = {
	            type: "declaration",
	            property: prop.replace(comment_regexp, ""),
	            value: val ? val[0].replace(comment_regexp, "").trim() : ""
	        };
	        match(/^[;\s]*/);
	        return ret;
	    }
	    function declarations() {
	        if (!open()) {
	            return error("missing '{'");
	        }
	        var d;
	        var decls = comments();
	        while (d = declaration()) {
	            decls.push(d);
	            decls = decls.concat(comments());
	        }
	        if (!close()) {
	            return error("missing '}'");
	        }
	        return decls;
	    }
	    function keyframe() {
	        whitespace();
	        var vals = [];
	        var m;
	        while (m = match(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/)) {
	            vals.push(m[1]);
	            match(/^,\s*/);
	        }
	        if (vals.length) {
	            return {
	                type: "keyframe",
	                values: vals,
	                declarations: declarations()
	            };
	        }
	    }
	    function at_keyframes() {
	        var m = match(/^@([-\w]+)?keyframes\s*/);
	        if (!m) {
	            return;
	        }
	        var vendor = m[1];
	        m = match(/^([-\w]+)\s*/);
	        if (!m) {
	            return error("@keyframes missing name");
	        }
	        var name = m[1];
	        if (!open()) {
	            return error("@keyframes missing '{'");
	        }
	        var frame;
	        var frames = comments();
	        while (frame = keyframe()) {
	            frames.push(frame);
	            frames = frames.concat(comments());
	        }
	        if (!close()) {
	            return error("@keyframes missing '}'");
	        }
	        return {
	            type: "keyframes",
	            name: name,
	            vendor: vendor,
	            keyframes: frames
	        };
	    }
	    function at_page() {
	        var m = match(/^@page */);
	        if (m) {
	            var sel = selector() || [];
	            return {
	                type: "page",
	                selectors: sel,
	                declarations: declarations()
	            };
	        }
	    }
	    function at_page_margin_box() {
	        var m = match(/@(top|bottom|left|right)-(left|center|right|top|middle|bottom)-?(corner)?\s*/);
	        if (m) {
	            var name = "".concat(m[1], "-").concat(m[2]) + (m[3] ? "-".concat(m[3]) : "");
	            return {
	                type: "page-margin-box",
	                name: name,
	                declarations: declarations()
	            };
	        }
	    }
	    function at_fontface() {
	        var m = match(/^@font-face\s*/);
	        if (m) {
	            return {
	                type: "font-face",
	                declarations: declarations()
	            };
	        }
	    }
	    function at_supports() {
	        var m = match(/^@supports *([^{]+)/);
	        if (m) {
	            return {
	                type: "supports",
	                supports: m[1].trim(),
	                rules: rules()
	            };
	        }
	    }
	    function at_host() {
	        var m = match(/^@host\s*/);
	        if (m) {
	            return {
	                type: "host",
	                rules: rules()
	            };
	        }
	    }
	    function at_media() {
	        var m = match(/^@media([^{]+)*/);
	        if (m) {
	            return {
	                type: "media",
	                media: (m[1] || "").trim(),
	                rules: rules()
	            };
	        }
	    }
	    function at_custom_m() {
	        var m = match(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
	        if (m) {
	            return {
	                type: "custom-media",
	                name: m[1].trim(),
	                media: m[2].trim()
	            };
	        }
	    }
	    function at_document() {
	        var m = match(/^@([-\w]+)?document *([^{]+)/);
	        if (m) {
	            return {
	                type: "document",
	                document: m[2].trim(),
	                vendor: m[1] ? m[1].trim() : null,
	                rules: rules()
	            };
	        }
	    }
	    function at_x() {
	        var m = match(/^@(import|charset|namespace)\s*([^;]+);/);
	        if (m) {
	            return {
	                type: m[1],
	                name: m[2].trim()
	            };
	        }
	    }
	    function at_rule() {
	        whitespace();
	        if (css[0] === "@") {
	            var ret = at_x() || at_fontface() || at_media() || at_keyframes() || at_supports() || at_document() || at_custom_m() || at_host() || at_page() || at_page_margin_box();
	            if (ret && !settings.preserveStatic) {
	                var hasVarFunc = false;
	                if (ret.declarations) {
	                    hasVarFunc = ret.declarations.some((function(decl) {
	                        return /var\(/.test(decl.value);
	                    }));
	                } else {
	                    var arr = ret.keyframes || ret.rules || [];
	                    hasVarFunc = arr.some((function(obj) {
	                        return (obj.declarations || []).some((function(decl) {
	                            return /var\(/.test(decl.value);
	                        }));
	                    }));
	                }
	                return hasVarFunc ? ret : {};
	            }
	            return ret;
	        }
	    }
	    function rule() {
	        if (!settings.preserveStatic) {
	            var balancedMatch$1 = balancedMatch("{", "}", css);
	            if (balancedMatch$1) {
	                var hasVarDecl = /:(?:root|host)(?![.:#(])/.test(balancedMatch$1.pre) && /--\S*\s*:/.test(balancedMatch$1.body);
	                var hasVarFunc = /var\(/.test(balancedMatch$1.body);
	                if (!hasVarDecl && !hasVarFunc) {
	                    css = css.slice(balancedMatch$1.end + 1);
	                    return {};
	                }
	            }
	        }
	        var sel = selector() || [];
	        var decls = settings.preserveStatic ? declarations() : declarations().filter((function(decl) {
	            var hasVarDecl = sel.some((function(s) {
	                return /:(?:root|host)(?![.:#(])/.test(s);
	            })) && /^--\S/.test(decl.property);
	            var hasVarFunc = /var\(/.test(decl.value);
	            return hasVarDecl || hasVarFunc;
	        }));
	        if (!sel.length) {
	            error("selector missing");
	        }
	        return {
	            type: "rule",
	            selectors: sel,
	            declarations: decls
	        };
	    }
	    function rules(core) {
	        if (!core && !open()) {
	            return error("missing '{'");
	        }
	        var node;
	        var rules = comments();
	        while (css.length && (core || css[0] !== "}") && (node = at_rule() || rule())) {
	            if (node.type) {
	                rules.push(node);
	            }
	            rules = rules.concat(comments());
	        }
	        if (!core && !close()) {
	            return error("missing '}'");
	        }
	        return rules;
	    }
	    return {
	        type: "stylesheet",
	        stylesheet: {
	            rules: rules(true),
	            errors: errors
	        }
	    };
	}

	function parseVars(cssData) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var defaults = {
	        parseHost: false,
	        store: {},
	        onWarning: function onWarning() {}
	    };
	    var settings = _extends$1({}, defaults, options);
	    var reVarDeclSelectors = new RegExp(":".concat(settings.parseHost ? "host" : "root", "$"));
	    if (typeof cssData === "string") {
	        cssData = parseCss(cssData, settings);
	    }
	    cssData.stylesheet.rules.forEach((function(rule) {
	        if (rule.type !== "rule" || !rule.selectors.some((function(s) {
	            return reVarDeclSelectors.test(s);
	        }))) {
	            return;
	        }
	        rule.declarations.forEach((function(decl, i) {
	            var prop = decl.property;
	            var value = decl.value;
	            if (prop && prop.indexOf("--") === 0) {
	                settings.store[prop] = value;
	            }
	        }));
	    }));
	    return settings.store;
	}

	function stringifyCss(tree) {
	    var delim = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
	    var cb = arguments.length > 2 ? arguments[2] : undefined;
	    var renderMethods = {
	        charset: function charset(node) {
	            return "@charset " + node.name + ";";
	        },
	        comment: function comment(node) {
	            return node.comment.indexOf("__CSSVARSPONYFILL") === 0 ? "/*" + node.comment + "*/" : "";
	        },
	        "custom-media": function customMedia(node) {
	            return "@custom-media " + node.name + " " + node.media + ";";
	        },
	        declaration: function declaration(node) {
	            return node.property + ":" + node.value + ";";
	        },
	        document: function document(node) {
	            return "@" + (node.vendor || "") + "document " + node.document + "{" + visit(node.rules) + "}";
	        },
	        "font-face": function fontFace(node) {
	            return "@font-face" + "{" + visit(node.declarations) + "}";
	        },
	        host: function host(node) {
	            return "@host" + "{" + visit(node.rules) + "}";
	        },
	        import: function _import(node) {
	            return "@import " + node.name + ";";
	        },
	        keyframe: function keyframe(node) {
	            return node.values.join(",") + "{" + visit(node.declarations) + "}";
	        },
	        keyframes: function keyframes(node) {
	            return "@" + (node.vendor || "") + "keyframes " + node.name + "{" + visit(node.keyframes) + "}";
	        },
	        media: function media(node) {
	            return "@media " + node.media + "{" + visit(node.rules) + "}";
	        },
	        namespace: function namespace(node) {
	            return "@namespace " + node.name + ";";
	        },
	        page: function page(node) {
	            return "@page " + (node.selectors.length ? node.selectors.join(", ") : "") + "{" + visit(node.declarations) + "}";
	        },
	        "page-margin-box": function pageMarginBox(node) {
	            return "@" + node.name + "{" + visit(node.declarations) + "}";
	        },
	        rule: function rule(node) {
	            var decls = node.declarations;
	            if (decls.length) {
	                return node.selectors.join(",") + "{" + visit(decls) + "}";
	            }
	        },
	        supports: function supports(node) {
	            return "@supports " + node.supports + "{" + visit(node.rules) + "}";
	        }
	    };
	    function visit(nodes) {
	        var buf = "";
	        for (var i = 0; i < nodes.length; i++) {
	            var n = nodes[i];
	            if (cb) {
	                cb(n);
	            }
	            var txt = renderMethods[n.type](n);
	            if (txt) {
	                buf += txt;
	                if (txt.length && n.selectors) {
	                    buf += delim;
	                }
	            }
	        }
	        return buf;
	    }
	    return visit(tree.stylesheet.rules);
	}

	function walkCss(node, fn) {
	    node.rules.forEach((function(rule) {
	        if (rule.rules) {
	            walkCss(rule, fn);
	            return;
	        }
	        if (rule.keyframes) {
	            rule.keyframes.forEach((function(keyframe) {
	                if (keyframe.type === "keyframe") {
	                    fn(keyframe.declarations, rule);
	                }
	            }));
	            return;
	        }
	        if (!rule.declarations) {
	            return;
	        }
	        fn(rule.declarations, node);
	    }));
	}

	var VAR_PROP_IDENTIFIER = "--";

	var VAR_FUNC_IDENTIFIER = "var";

	function transformCss(cssData) {
	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var defaults = {
	        preserveStatic: true,
	        preserveVars: false,
	        variables: {},
	        onWarning: function onWarning() {}
	    };
	    var settings = _extends$1({}, defaults, options);
	    if (typeof cssData === "string") {
	        cssData = parseCss(cssData, settings);
	    }
	    walkCss(cssData.stylesheet, (function(declarations, node) {
	        for (var i = 0; i < declarations.length; i++) {
	            var decl = declarations[i];
	            var type = decl.type;
	            var prop = decl.property;
	            var value = decl.value;
	            if (type !== "declaration") {
	                continue;
	            }
	            if (!settings.preserveVars && prop && prop.indexOf(VAR_PROP_IDENTIFIER) === 0) {
	                declarations.splice(i, 1);
	                i--;
	                continue;
	            }
	            if (value.indexOf(VAR_FUNC_IDENTIFIER + "(") !== -1) {
	                var resolvedValue = resolveValue(value, settings);
	                if (resolvedValue !== decl.value) {
	                    resolvedValue = fixNestedCalc(resolvedValue);
	                    if (!settings.preserveVars) {
	                        decl.value = resolvedValue;
	                    } else {
	                        declarations.splice(i, 0, {
	                            type: type,
	                            property: prop,
	                            value: resolvedValue
	                        });
	                        i++;
	                    }
	                }
	            }
	        }
	    }));
	    return stringifyCss(cssData);
	}

	function fixNestedCalc(value) {
	    var reCalcVal = /calc\(([^)]+)\)/g;
	    (value.match(reCalcVal) || []).forEach((function(match) {
	        var newVal = "calc".concat(match.split("calc").join(""));
	        value = value.replace(match, newVal);
	    }));
	    return value;
	}

	function resolveValue(value) {
	    var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	    var __recursiveFallback = arguments.length > 2 ? arguments[2] : undefined;
	    if (value.indexOf("var(") === -1) {
	        return value;
	    }
	    var valueData = balancedMatch("(", ")", value);
	    function resolveFunc(value) {
	        var name = value.split(",")[0].replace(/[\s\n\t]/g, "");
	        var fallback = (value.match(/(?:\s*,\s*){1}(.*)?/) || [])[1];
	        var match = Object.prototype.hasOwnProperty.call(settings.variables, name) ? String(settings.variables[name]) : undefined;
	        var replacement = match || (fallback ? String(fallback) : undefined);
	        var unresolvedFallback = __recursiveFallback || value;
	        if (!match) {
	            settings.onWarning('variable "'.concat(name, '" is undefined'));
	        }
	        if (replacement && replacement !== "undefined" && replacement.length > 0) {
	            return resolveValue(replacement, settings, unresolvedFallback);
	        } else {
	            return "var(".concat(unresolvedFallback, ")");
	        }
	    }
	    if (!valueData) {
	        if (value.indexOf("var(") !== -1) {
	            settings.onWarning('missing closing ")" in the value "'.concat(value, '"'));
	        }
	        return value;
	    } else if (valueData.pre.slice(-3) === "var") {
	        var isEmptyVarFunc = valueData.body.trim().length === 0;
	        if (isEmptyVarFunc) {
	            settings.onWarning("var() must contain a non-whitespace string");
	            return value;
	        } else {
	            return valueData.pre.slice(0, -3) + resolveFunc(valueData.body) + resolveValue(valueData.post, settings);
	        }
	    } else {
	        return valueData.pre + "(".concat(resolveValue(valueData.body, settings), ")") + resolveValue(valueData.post, settings);
	    }
	}

	var isBrowser = typeof window !== "undefined";

	var isNativeSupport = isBrowser && window.CSS && window.CSS.supports && window.CSS.supports("(--a: 0)");

	var counters = {
	    group: 0,
	    job: 0
	};

	var defaults = {
	    rootElement: isBrowser ? document : null,
	    shadowDOM: false,
	    include: "style,link[rel=stylesheet]",
	    exclude: "",
	    variables: {},
	    onlyLegacy: true,
	    preserveStatic: true,
	    preserveVars: false,
	    silent: false,
	    updateDOM: true,
	    updateURLs: true,
	    watch: null,
	    onBeforeSend: function onBeforeSend() {},
	    onError: function onError() {},
	    onWarning: function onWarning() {},
	    onSuccess: function onSuccess() {},
	    onComplete: function onComplete() {},
	    onFinally: function onFinally() {}
	};

	var regex = {
	    cssComments: /\/\*[\s\S]+?\*\//g,
	    cssKeyframes: /@(?:-\w*-)?keyframes/,
	    cssMediaQueries: /@media[^{]+\{([\s\S]+?})\s*}/g,
	    cssUrls: /url\((?!['"]?(?:data|http|\/\/):)['"]?([^'")]*)['"]?\)/g,
	    cssVarDeclRules: /(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^}]*})/g,
	    cssVarDecls: /(?:[\s;]*)(-{2}\w[\w-]*)(?:\s*:\s*)([^;]*);/g,
	    cssVarFunc: /var\(\s*--[\w-]/,
	    cssVars: /(?:(?::(?:root|host)(?![.:#(])[\s,]*[^{]*{\s*[^;]*;*\s*)|(?:var\(\s*))(--[^:)]+)(?:\s*[:)])/
	};

	var variableStore = {
	    dom: {},
	    job: {},
	    user: {}
	};

	var cssVarsIsRunning = false;

	var cssVarsObserver = null;

	var cssVarsSrcNodeCount = 0;

	var debounceTimer = null;

	var isShadowDOMReady = false;

	/**
	 * Fetches, parses, and transforms CSS custom properties from specified
	 * <style> and <link> elements into static values, then appends a new <style>
	 * element with static values to the DOM to provide CSS custom property
	 * compatibility for legacy browsers. Also provides a single interface for
	 * live updates of runtime values in both modern and legacy browsers.
	 *
	 * @preserve
	 * @param {object}   [options] Options object
	 * @param {object}   [options.rootElement=document] Root element to traverse for
	 *                   <link> and <style> nodes
	 * @param {boolean}  [options.shadowDOM=false] Determines if shadow DOM <link>
	 *                   and <style> nodes will be processed.
	 * @param {string}   [options.include="style,link[rel=stylesheet]"] CSS selector
	 *                   matching <link re="stylesheet"> and <style> nodes to
	 *                   process
	 * @param {string}   [options.exclude] CSS selector matching <link
	 *                   rel="stylehseet"> and <style> nodes to exclude from those
	 *                   matches by options.include
	 * @param {object}   [options.variables] A map of custom property name/value
	 *                   pairs. Property names can omit or include the leading
	 *                   double-hyphen (—), and values specified will override
	 *                   previous values
	 * @param {boolean}  [options.onlyLegacy=true] Determines if the ponyfill will
	 *                   only generate legacy-compatible CSS in browsers that lack
	 *                   native support (i.e., legacy browsers)
	 * @param {boolean}  [options.preserveStatic=true] Determines if CSS
	 *                   declarations that do not reference a custom property will
	 *                   be preserved in the transformed CSS
	 * @param {boolean}  [options.preserveVars=false] Determines if CSS custom
	 *                   property declarations will be preserved in the transformed
	 *                   CSS
	 * @param {boolean}  [options.silent=false] Determines if warning and error
	 *                   messages will be displayed on the console
	 * @param {boolean}  [options.updateDOM=true] Determines if the ponyfill will
	 *                   update the DOM after processing CSS custom properties
	 * @param {boolean}  [options.updateURLs=true] Determines if relative url()
	 *                   paths will be converted to absolute urls in external CSS
	 * @param {boolean}  [options.watch=false] Determines if a MutationObserver will
	 *                   be created that will execute the ponyfill when a <link> or
	 *                   <style> DOM mutation is observed
	 * @param {function} [options.onBeforeSend] Callback before XHR is sent. Passes
	 *                   1) the XHR object, 2) source node reference, and 3) the
	 *                   source URL as arguments
	 * @param {function} [options.onError] Callback after a CSS parsing error has
	 *                   occurred or an XHR request has failed. Passes 1) an error
	 *                   message, and 2) source node reference, 3) xhr, and 4 url as
	 *                   arguments.
	 * @param {function} [options.onWarning] Callback after each CSS parsing warning
	 *                   has occurred. Passes 1) a warning message as an argument.
	 * @param {function} [options.onSuccess] Callback after CSS data has been
	 *                   collected from each node and before CSS custom properties
	 *                   have been transformed. Allows modifying the CSS data before
	 *                   it is transformed by returning any string value (or false
	 *                   to skip). Passes 1) CSS text, 2) source node reference, and
	 *                   3) the source URL as arguments.
	 * @param {function} [options.onComplete] Callback after all CSS has been
	 *                   processed, legacy-compatible CSS has been generated, and
	 *                   (optionally) the DOM has been updated. Passes 1) a CSS
	 *                   string with CSS variable values resolved, 2) an array of
	 *                   output <style> node references that have been appended to
	 *                   the DOM, 3) an object containing all custom properies names
	 *                   and values, and 4) the ponyfill execution time in
	 *                   milliseconds.
	 * @param {function} [options.onFinally] Callback in modern and legacy browsers
	 *                   after the ponyfill has finished all tasks. Passes 1) a
	 *                   boolean indicating if the last ponyfill call resulted in a
	 *                   style change, 2) a boolean indicating if the current
	 *                   browser provides native support for CSS custom properties,
	 *                   and 3) the ponyfill execution time in milliseconds.
	 * @example
	 *
	 *   cssVars({
	 *     rootElement   : document,
	 *     shadowDOM     : false,
	 *     include       : 'style,link[rel="stylesheet"]',
	 *     exclude       : '',
	 *     variables     : {},
	 *     onlyLegacy    : true,
	 *     preserveStatic: true,
	 *     preserveVars  : false,
	 *     silent        : false,
	 *     updateDOM     : true,
	 *     updateURLs    : true,
	 *     watch         : false,
	 *     onBeforeSend(xhr, node, url) {},
	 *     onError(message, node, xhr, url) {},
	 *     onWarning(message) {},
	 *     onSuccess(cssText, node, url) {},
	 *     onComplete(cssText, styleNode, cssVariables, benchmark) {},
	 *     onFinally(hasChanged, hasNativeSupport, benchmark)
	 *   });
	 */ function cssVars() {
	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var msgPrefix = "cssVars(): ";
	    var settings = _extends$1({}, defaults, options);
	    function handleError(message, sourceNode, xhr, url) {
	        if (!settings.silent && window.console) {
	            console.error("".concat(msgPrefix).concat(message, "\n"), sourceNode);
	        }
	        settings.onError(message, sourceNode, xhr, url);
	    }
	    function handleWarning(message) {
	        if (!settings.silent && window.console) {
	            console.warn("".concat(msgPrefix).concat(message));
	        }
	        settings.onWarning(message);
	    }
	    function handleFinally(hasChanged) {
	        settings.onFinally(Boolean(hasChanged), isNativeSupport, getTimeStamp() - settings.__benchmark);
	    }
	    if (!isBrowser) {
	        return;
	    }
	    if (settings.watch) {
	        settings.watch = defaults.watch;
	        addMutationObserver(settings);
	        cssVars(settings);
	        return;
	    } else if (settings.watch === false && cssVarsObserver) {
	        cssVarsObserver.disconnect();
	        cssVarsObserver = null;
	    }
	    if (!settings.__benchmark) {
	        if (cssVarsIsRunning === settings.rootElement) {
	            cssVarsDebounced(options);
	            return;
	        }
	        var srcNodes = Array.apply(null, settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])'));
	        settings.__benchmark = getTimeStamp();
	        settings.exclude = [ cssVarsObserver ? '[data-cssvars]:not([data-cssvars=""])' : '[data-cssvars="out"]', "link[disabled]:not([data-cssvars])", settings.exclude ].filter((function(selector) {
	            return selector;
	        })).join(",");
	        settings.variables = fixVarNames(settings.variables);
	        srcNodes.forEach((function(srcNode) {
	            var hasStyleCache = srcNode.nodeName.toLowerCase() === "style" && srcNode.__cssVars.text;
	            var hasStyleChanged = hasStyleCache && srcNode.textContent !== srcNode.__cssVars.text;
	            if (hasStyleCache && hasStyleChanged) {
	                srcNode.sheet && (srcNode.sheet.disabled = false);
	                srcNode.setAttribute("data-cssvars", "");
	            }
	        }));
	        if (!cssVarsObserver) {
	            var outNodes = Array.apply(null, settings.rootElement.querySelectorAll('[data-cssvars="out"]'));
	            outNodes.forEach((function(outNode) {
	                var dataGroup = outNode.getAttribute("data-cssvars-group");
	                var srcNode = dataGroup ? settings.rootElement.querySelector('[data-cssvars="src"][data-cssvars-group="'.concat(dataGroup, '"]')) : null;
	                if (!srcNode) {
	                    outNode.parentNode.removeChild(outNode);
	                }
	            }));
	            if (cssVarsSrcNodeCount && srcNodes.length < cssVarsSrcNodeCount) {
	                cssVarsSrcNodeCount = srcNodes.length;
	                variableStore.dom = {};
	            }
	        }
	    }
	    if (document.readyState !== "loading") {
	        if (isNativeSupport && settings.onlyLegacy) {
	            var hasVarChange = false;
	            if (settings.updateDOM) {
	                var targetElm = settings.rootElement.host || (settings.rootElement === document ? document.documentElement : settings.rootElement);
	                Object.keys(settings.variables).forEach((function(key) {
	                    var varValue = settings.variables[key];
	                    hasVarChange = hasVarChange || varValue !== getComputedStyle(targetElm).getPropertyValue(key);
	                    targetElm.style.setProperty(key, varValue);
	                }));
	            }
	            handleFinally(hasVarChange);
	        } else if (!isShadowDOMReady && (settings.shadowDOM || settings.rootElement.shadowRoot || settings.rootElement.host)) {
	            getCssData({
	                rootElement: defaults.rootElement,
	                include: defaults.include,
	                exclude: settings.exclude,
	                skipDisabled: false,
	                onSuccess: function onSuccess(cssText, node, url) {
	                    var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
	                    if (isUserDisabled) {
	                        return false;
	                    }
	                    cssText = cssText.replace(regex.cssComments, "").replace(regex.cssMediaQueries, "");
	                    cssText = (cssText.match(regex.cssVarDeclRules) || []).join("");
	                    return cssText || false;
	                },
	                onComplete: function onComplete(cssText, cssArray, nodeArray) {
	                    parseVars(cssText, {
	                        store: variableStore.dom,
	                        onWarning: handleWarning
	                    });
	                    isShadowDOMReady = true;
	                    cssVars(settings);
	                }
	            });
	        } else {
	            cssVarsIsRunning = settings.rootElement;
	            getCssData({
	                rootElement: settings.rootElement,
	                include: settings.include,
	                exclude: settings.exclude,
	                skipDisabled: false,
	                onBeforeSend: settings.onBeforeSend,
	                onError: function onError(xhr, node, url) {
	                    var responseUrl = xhr.responseURL || getFullUrl$1(url, location.href);
	                    var statusText = xhr.statusText ? "(".concat(xhr.statusText, ")") : "Unspecified Error" + (xhr.status === 0 ? " (possibly CORS related)" : "");
	                    var errorMsg = "CSS XHR Error: ".concat(responseUrl, " ").concat(xhr.status, " ").concat(statusText);
	                    handleError(errorMsg, node, xhr, responseUrl);
	                },
	                onSuccess: function onSuccess(cssText, node, url) {
	                    var isUserDisabled = (node.sheet || {}).disabled && !node.__cssVars;
	                    if (isUserDisabled) {
	                        return false;
	                    }
	                    var isLink = node.nodeName.toLowerCase() === "link";
	                    var isStyleImport = node.nodeName.toLowerCase() === "style" && cssText !== node.textContent;
	                    var returnVal = settings.onSuccess(cssText, node, url);
	                    cssText = returnVal !== undefined && Boolean(returnVal) === false ? "" : returnVal || cssText;
	                    if (settings.updateURLs && (isLink || isStyleImport)) {
	                        cssText = fixRelativeCssUrls(cssText, url);
	                    }
	                    return cssText;
	                },
	                onComplete: function onComplete(cssText, cssArray) {
	                    var nodeArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	                    var currentVars = _extends$1({}, variableStore.dom, variableStore.user);
	                    var hasVarChange = false;
	                    variableStore.job = {};
	                    nodeArray.forEach((function(node, i) {
	                        var nodeCSS = cssArray[i];
	                        node.__cssVars = node.__cssVars || {};
	                        node.__cssVars.text = nodeCSS;
	                        if (regex.cssVars.test(nodeCSS)) {
	                            try {
	                                var cssTree = parseCss(nodeCSS, {
	                                    preserveStatic: settings.preserveStatic,
	                                    removeComments: true
	                                });
	                                parseVars(cssTree, {
	                                    parseHost: Boolean(settings.rootElement.host),
	                                    store: variableStore.dom,
	                                    onWarning: handleWarning
	                                });
	                                node.__cssVars.tree = cssTree;
	                            } catch (err) {
	                                handleError(err.message, node);
	                            }
	                        }
	                    }));
	                    _extends$1(variableStore.job, variableStore.dom);
	                    if (settings.updateDOM) {
	                        _extends$1(variableStore.user, settings.variables);
	                        _extends$1(variableStore.job, variableStore.user);
	                    } else {
	                        _extends$1(variableStore.job, variableStore.user, settings.variables);
	                        _extends$1(currentVars, settings.variables);
	                    }
	                    hasVarChange = counters.job > 0 && Boolean(Object.keys(variableStore.job).length > Object.keys(currentVars).length || Boolean(Object.keys(currentVars).length && Object.keys(variableStore.job).some((function(key) {
	                        return variableStore.job[key] !== currentVars[key];
	                    }))));
	                    if (hasVarChange) {
	                        resetCssNodes(settings.rootElement);
	                        cssVars(settings);
	                    } else {
	                        var outCssArray = [];
	                        var outNodeArray = [];
	                        var hasKeyframesWithVars = false;
	                        if (settings.updateDOM) {
	                            counters.job++;
	                        }
	                        nodeArray.forEach((function(node, i) {
	                            var isSkip = !node.__cssVars.tree;
	                            if (node.__cssVars.tree) {
	                                try {
	                                    transformCss(node.__cssVars.tree, _extends$1({}, settings, {
	                                        variables: variableStore.job,
	                                        onWarning: handleWarning
	                                    }));
	                                    var outCss = stringifyCss(node.__cssVars.tree);
	                                    if (settings.updateDOM) {
	                                        var nodeCSS = cssArray[i];
	                                        var hasCSSVarFunc = regex.cssVarFunc.test(nodeCSS);
	                                        if (!node.getAttribute("data-cssvars")) {
	                                            node.setAttribute("data-cssvars", "src");
	                                        }
	                                        if (outCss.length && hasCSSVarFunc) {
	                                            var dataGroup = node.getAttribute("data-cssvars-group") || ++counters.group;
	                                            var outCssNoSpaces = outCss.replace(/\s/g, "");
	                                            var outNode = settings.rootElement.querySelector('[data-cssvars="out"][data-cssvars-group="'.concat(dataGroup, '"]')) || document.createElement("style");
	                                            hasKeyframesWithVars = hasKeyframesWithVars || regex.cssKeyframes.test(outCss);
	                                            if (settings.preserveStatic) {
	                                                node.sheet && (node.sheet.disabled = true);
	                                            }
	                                            if (!outNode.hasAttribute("data-cssvars")) {
	                                                outNode.setAttribute("data-cssvars", "out");
	                                            }
	                                            if (outCssNoSpaces === node.textContent.replace(/\s/g, "")) {
	                                                isSkip = true;
	                                                if (outNode && outNode.parentNode) {
	                                                    node.removeAttribute("data-cssvars-group");
	                                                    outNode.parentNode.removeChild(outNode);
	                                                }
	                                            } else if (outCssNoSpaces !== outNode.textContent.replace(/\s/g, "")) {
	                                                [ node, outNode ].forEach((function(n) {
	                                                    n.setAttribute("data-cssvars-job", counters.job);
	                                                    n.setAttribute("data-cssvars-group", dataGroup);
	                                                }));
	                                                outNode.textContent = outCss;
	                                                outCssArray.push(outCss);
	                                                outNodeArray.push(outNode);
	                                                if (!outNode.parentNode) {
	                                                    node.parentNode.insertBefore(outNode, node.nextSibling);
	                                                }
	                                            }
	                                        }
	                                    } else {
	                                        if (node.textContent.replace(/\s/g, "") !== outCss) {
	                                            outCssArray.push(outCss);
	                                        }
	                                    }
	                                } catch (err) {
	                                    handleError(err.message, node);
	                                }
	                            }
	                            if (isSkip) {
	                                node.setAttribute("data-cssvars", "skip");
	                            }
	                            if (!node.hasAttribute("data-cssvars-job")) {
	                                node.setAttribute("data-cssvars-job", counters.job);
	                            }
	                        }));
	                        cssVarsSrcNodeCount = settings.rootElement.querySelectorAll('[data-cssvars]:not([data-cssvars="out"])').length;
	                        if (settings.shadowDOM) {
	                            var elms = [].concat(settings.rootElement).concat(Array.apply(null, settings.rootElement.querySelectorAll("*")));
	                            for (var i = 0, elm; elm = elms[i]; ++i) {
	                                if (elm.shadowRoot && elm.shadowRoot.querySelector("style")) {
	                                    var shadowSettings = _extends$1({}, settings, {
	                                        rootElement: elm.shadowRoot
	                                    });
	                                    cssVars(shadowSettings);
	                                }
	                            }
	                        }
	                        if (settings.updateDOM && hasKeyframesWithVars) {
	                            fixKeyframes(settings.rootElement);
	                        }
	                        cssVarsIsRunning = false;
	                        settings.onComplete(outCssArray.join(""), outNodeArray, JSON.parse(JSON.stringify(variableStore.job)), getTimeStamp() - settings.__benchmark);
	                        handleFinally(outNodeArray.length);
	                    }
	                }
	            });
	        }
	    } else {
	        document.addEventListener("DOMContentLoaded", (function init(evt) {
	            cssVars(options);
	            document.removeEventListener("DOMContentLoaded", init);
	        }));
	    }
	}

	cssVars.reset = function() {
	    counters.job = 0;
	    counters.group = 0;
	    cssVarsIsRunning = false;
	    if (cssVarsObserver) {
	        cssVarsObserver.disconnect();
	        cssVarsObserver = null;
	    }
	    cssVarsSrcNodeCount = 0;
	    debounceTimer = null;
	    isShadowDOMReady = false;
	    for (var prop in variableStore) {
	        variableStore[prop] = {};
	    }
	};

	function addMutationObserver(settings) {
	    function isDisabled(node) {
	        var isDisabledAttr = isLink(node) && node.hasAttribute("disabled");
	        var isDisabledSheet = (node.sheet || {}).disabled;
	        return isDisabledAttr || isDisabledSheet;
	    }
	    function isLink(node) {
	        var isStylesheet = node.nodeName.toLowerCase() === "link" && (node.getAttribute("rel") || "").indexOf("stylesheet") !== -1;
	        return isStylesheet;
	    }
	    function isStyle(node) {
	        return node.nodeName.toLowerCase() === "style";
	    }
	    function isValidAttributeMutation(mutation) {
	        var isValid = false;
	        if (mutation.type === "attributes" && isLink(mutation.target) && !isDisabled(mutation.target)) {
	            var isEnabledMutation = mutation.attributeName === "disabled";
	            var isHrefMutation = mutation.attributeName === "href";
	            var isSkipNode = mutation.target.getAttribute("data-cssvars") === "skip";
	            var isSrcNode = mutation.target.getAttribute("data-cssvars") === "src";
	            if (isEnabledMutation) {
	                isValid = !isSkipNode && !isSrcNode;
	            } else if (isHrefMutation) {
	                if (isSkipNode) {
	                    mutation.target.setAttribute("data-cssvars", "");
	                } else if (isSrcNode) {
	                    resetCssNodes(settings.rootElement, true);
	                }
	                isValid = true;
	            }
	        }
	        return isValid;
	    }
	    function isValidStyleTextMutation(mutation) {
	        var isValid = false;
	        if (mutation.type === "childList") {
	            var isStyleElm = isStyle(mutation.target);
	            var isOutNode = mutation.target.getAttribute("data-cssvars") === "out";
	            isValid = isStyleElm && !isOutNode;
	        }
	        return isValid;
	    }
	    function isValidAddMutation(mutation) {
	        var isValid = false;
	        if (mutation.type === "childList") {
	            isValid = Array.apply(null, mutation.addedNodes).some((function(node) {
	                var isElm = node.nodeType === 1;
	                var hasAttr = isElm && node.hasAttribute("data-cssvars");
	                var isStyleWithVars = isStyle(node) && regex.cssVars.test(node.textContent);
	                var isValid = !hasAttr && (isLink(node) || isStyleWithVars);
	                return isValid && !isDisabled(node);
	            }));
	        }
	        return isValid;
	    }
	    function isValidRemoveMutation(mutation) {
	        var isValid = false;
	        if (mutation.type === "childList") {
	            isValid = Array.apply(null, mutation.removedNodes).some((function(node) {
	                var isElm = node.nodeType === 1;
	                var isOutNode = isElm && node.getAttribute("data-cssvars") === "out";
	                var isSrcNode = isElm && node.getAttribute("data-cssvars") === "src";
	                var isValid = isSrcNode;
	                if (isSrcNode || isOutNode) {
	                    var dataGroup = node.getAttribute("data-cssvars-group");
	                    var orphanNode = settings.rootElement.querySelector('[data-cssvars-group="'.concat(dataGroup, '"]'));
	                    if (isSrcNode) {
	                        resetCssNodes(settings.rootElement, true);
	                    }
	                    if (orphanNode) {
	                        orphanNode.parentNode.removeChild(orphanNode);
	                    }
	                }
	                return isValid;
	            }));
	        }
	        return isValid;
	    }
	    if (!window.MutationObserver) {
	        return;
	    }
	    if (cssVarsObserver) {
	        cssVarsObserver.disconnect();
	        cssVarsObserver = null;
	    }
	    cssVarsObserver = new MutationObserver((function(mutations) {
	        var hasValidMutation = mutations.some((function(mutation) {
	            return isValidAttributeMutation(mutation) || isValidStyleTextMutation(mutation) || isValidAddMutation(mutation) || isValidRemoveMutation(mutation);
	        }));
	        if (hasValidMutation) {
	            cssVars(settings);
	        }
	    }));
	    cssVarsObserver.observe(document.documentElement, {
	        attributes: true,
	        attributeFilter: [ "disabled", "href" ],
	        childList: true,
	        subtree: true
	    });
	}

	function cssVarsDebounced(settings) {
	    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
	    clearTimeout(debounceTimer);
	    debounceTimer = setTimeout((function() {
	        settings.__benchmark = null;
	        cssVars(settings);
	    }), delay);
	}

	function fixKeyframes(rootElement) {
	    var animationNameProp = [ "animation-name", "-moz-animation-name", "-webkit-animation-name" ].filter((function(prop) {
	        return getComputedStyle(document.body)[prop];
	    }))[0];
	    if (animationNameProp) {
	        var allNodes = rootElement.getElementsByTagName("*");
	        var keyframeNodes = [];
	        var nameMarker = "__CSSVARSPONYFILL-KEYFRAMES__";
	        for (var i = 0, len = allNodes.length; i < len; i++) {
	            var node = allNodes[i];
	            var animationName = getComputedStyle(node)[animationNameProp];
	            if (animationName !== "none") {
	                node.style[animationNameProp] += nameMarker;
	                keyframeNodes.push(node);
	            }
	        }
	        void document.body.offsetHeight;
	        for (var _i = 0, _len = keyframeNodes.length; _i < _len; _i++) {
	            var nodeStyle = keyframeNodes[_i].style;
	            nodeStyle[animationNameProp] = nodeStyle[animationNameProp].replace(nameMarker, "");
	        }
	    }
	}

	function fixRelativeCssUrls(cssText, baseUrl) {
	    var cssUrls = cssText.replace(regex.cssComments, "").match(regex.cssUrls) || [];
	    cssUrls.forEach((function(cssUrl) {
	        var oldUrl = cssUrl.replace(regex.cssUrls, "$1");
	        var newUrl = getFullUrl$1(oldUrl, baseUrl);
	        cssText = cssText.replace(cssUrl, cssUrl.replace(oldUrl, newUrl));
	    }));
	    return cssText;
	}

	function fixVarNames() {
	    var varObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
	    var reLeadingHyphens = /^-{2}/;
	    return Object.keys(varObj).reduce((function(obj, value) {
	        var key = reLeadingHyphens.test(value) ? value : "--".concat(value.replace(/^-+/, ""));
	        obj[key] = varObj[value];
	        return obj;
	    }), {});
	}

	function getFullUrl$1(url) {
	    var base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : location.href;
	    var d = document.implementation.createHTMLDocument("");
	    var b = d.createElement("base");
	    var a = d.createElement("a");
	    d.head.appendChild(b);
	    d.body.appendChild(a);
	    b.href = base;
	    a.href = url;
	    return a.href;
	}

	function getTimeStamp() {
	    return isBrowser && (window.performance || {}).now ? window.performance.now() : (new Date).getTime();
	}

	function resetCssNodes(rootElement) {
	    var resetDOMVariableStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
	    var resetNodes = Array.apply(null, rootElement.querySelectorAll('[data-cssvars="skip"],[data-cssvars="src"]'));
	    resetNodes.forEach((function(node) {
	        return node.setAttribute("data-cssvars", "");
	    }));
	    if (resetDOMVariableStore) {
	        variableStore.dom = {};
	    }
	}

	var nativeReverse = [].reverse;
	var test$2 = [1, 2];

	// `Array.prototype.reverse` method
	// https://tc39.es/ecma262/#sec-array.prototype.reverse
	// fix for Safari 12.0 bug
	// https://bugs.webkit.org/show_bug.cgi?id=188794
	_export({ target: 'Array', proto: true, forced: String(test$2) === String(test$2.reverse()) }, {
	  reverse: function reverse() {
	    // eslint-disable-next-line no-self-assign -- dirty hack
	    if (isArray(this)) this.length = this.length;
	    return nativeReverse.call(this);
	  }
	});

	var reverse = entryVirtual('Array').reverse;

	var ArrayPrototype$g = Array.prototype;

	var reverse_1 = function (it) {
	  var own = it.reverse;
	  return it === ArrayPrototype$g || (it instanceof Array && own === ArrayPrototype$g.reverse) ? reverse : own;
	};

	var reverse$1 = reverse_1;

	var reverse$2 = reverse$1;

	var createClass = createCommonjsModule(function (module) {
	function _defineProperties(target, props) {
	  for (var i = 0; i < props.length; i++) {
	    var descriptor = props[i];
	    descriptor.enumerable = descriptor.enumerable || false;
	    descriptor.configurable = true;
	    if ("value" in descriptor) descriptor.writable = true;

	    defineProperty$6(target, descriptor.key, descriptor);
	  }
	}

	function _createClass(Constructor, protoProps, staticProps) {
	  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
	  if (staticProps) _defineProperties(Constructor, staticProps);
	  return Constructor;
	}

	module.exports = _createClass;
	module.exports["default"] = module.exports, module.exports.__esModule = true;
	});

	var _createClass = unwrapExports(createClass);

	var lodash_clonedeep = createCommonjsModule(function (module, exports) {
	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag] = cloneableTags[arrayTag] =
	cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	cloneableTags[boolTag] = cloneableTags[dateTag] =
	cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	cloneableTags[int32Tag] = cloneableTags[mapTag] =
	cloneableTags[numberTag] = cloneableTags[objectTag] =
	cloneableTags[regexpTag] = cloneableTags[setTag] =
	cloneableTags[stringTag] = cloneableTags[symbolTag] =
	cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	cloneableTags[errorTag] = cloneableTags[funcTag] =
	cloneableTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/**
	 * Adds the key-value `pair` to `map`.
	 *
	 * @private
	 * @param {Object} map The map to modify.
	 * @param {Array} pair The key-value pair to add.
	 * @returns {Object} Returns `map`.
	 */
	function addMapEntry(map, pair) {
	  // Don't return `map.set` because it's not chainable in IE 11.
	  map.set(pair[0], pair[1]);
	  return map;
	}

	/**
	 * Adds `value` to `set`.
	 *
	 * @private
	 * @param {Object} set The set to modify.
	 * @param {*} value The value to add.
	 * @returns {Object} Returns `set`.
	 */
	function addSetEntry(set, value) {
	  // Don't return `set.add` because it's not chainable in IE 11.
	  set.add(value);
	  return set;
	}

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array ? array.length : 0;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array ? array.length : 0;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    getPrototype = overArg(Object.getPrototypeOf, Object),
	    objectCreate = Object.create,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  return this.has(key) && delete this.__data__[key];
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries ? entries.length : 0;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  return getMapData(this, key)['delete'](key);
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  getMapData(this, key).set(key, value);
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  this.__data__ = new ListCache(entries);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  return this.__data__['delete'](key);
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var cache = this.__data__;
	  if (cache instanceof ListCache) {
	    var pairs = cache.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      return this;
	    }
	    cache = this.__data__ = new MapCache(pairs);
	  }
	  cache.set(key, value);
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  // Safari 9 makes `arguments.length` enumerable in strict mode.
	  var result = (isArray(value) || isArguments(value))
	    ? baseTimes(value.length, String)
	    : [];

	  var length = result.length,
	      skipIndexes = !!length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    object[key] = value;
	  }
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @param {boolean} [isFull] Specify a clone including symbols.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
	  var result;
	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray(value, result);
	    }
	  } else {
	    var tag = getTag(value),
	        isFunc = tag == funcTag || tag == genTag;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	      if (isHostObject(value)) {
	        return object ? value : {};
	      }
	      result = initCloneObject(isFunc ? {} : value);
	      if (!isDeep) {
	        return copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, baseClone, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (!isArr) {
	    var props = isFull ? getAllKeys(value) : keys(value);
	  }
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
	  });
	  return result;
	}

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} prototype The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	function baseCreate(proto) {
	  return isObject(proto) ? objectCreate(proto) : {};
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var result = new buffer.constructor(buffer.length);
	  buffer.copy(result);
	  return result;
	}

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	/**
	 * Creates a clone of `map`.
	 *
	 * @private
	 * @param {Object} map The map to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned map.
	 */
	function cloneMap(map, isDeep, cloneFunc) {
	  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
	  return arrayReduce(array, addMapEntry, new map.constructor);
	}

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	/**
	 * Creates a clone of `set`.
	 *
	 * @private
	 * @param {Object} set The set to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned set.
	 */
	function cloneSet(set, isDeep, cloneFunc) {
	  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
	  return arrayReduce(array, addSetEntry, new set.constructor);
	}

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    assignValue(object, key, newValue === undefined ? source[key] : newValue);
	  }
	  return object;
	}

	/**
	 * Copies own symbol properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Creates an array of the own enumerable symbol properties of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {Function} cloneFunc The function to clone values.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, cloneFunc, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag:
	      return cloneArrayBuffer(object);

	    case boolTag:
	    case dateTag:
	      return new Ctor(+object);

	    case dataViewTag:
	      return cloneDataView(object, isDeep);

	    case float32Tag: case float64Tag:
	    case int8Tag: case int16Tag: case int32Tag:
	    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	      return cloneTypedArray(object, isDeep);

	    case mapTag:
	      return cloneMap(object, isDeep, cloneFunc);

	    case numberTag:
	    case stringTag:
	      return new Ctor(object);

	    case regexpTag:
	      return cloneRegExp(object);

	    case setTag:
	      return cloneSet(object, isDeep, cloneFunc);

	    case symbolTag:
	      return cloneSymbol(object);
	  }
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, true, true);
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = cloneDeep;
	});

	/** @module EventEmitter */

	/**
	 * EventEmitter is a base class for any object that wants to expose
	 * a pub/sub interface, for emitting messages and providing listeners.
	 */
	var EventEmitter = /*#__PURE__*/function () {
	  function EventEmitter() {
	    /**
	     * The subscribers of messages
	     * @type {object[]}
	     * @private
	     */
	    this._listeners = {};
	  }
	  /**
	   * on is the public interface for subscribing events that are emitted.
	   * @param {string} evt the event name to listen to
	   * @param {function} cb The callback to invoke when the {evt} is emitted
	   * @param {boolean} once Optional value which will only handle the message once
	   */


	  var _proto = EventEmitter.prototype;

	  _proto.on = function on(evt, cb, once) {
	    if (typeof cb !== 'function') {
	      throw new Error('callback handler should be of type {function}');
	    }

	    if (this._listeners[evt] === undefined) {
	      this._listeners[evt] = [];
	    }

	    this._listeners[evt].push({
	      event: evt,
	      cb: cb,
	      once: once || false
	    });

	    return this;
	  }
	  /**
	   * once is the public interface for subscribing events that are emitted.
	   * The handler will only be triggered once.
	   *
	   * @param {string} evt the event name to listen to
	   * @param {function} cb The callback to invoke when the {evt} is emitted
	   * @param {boolean} once Optional value which will only handle the message once
	   */
	  ;

	  _proto.once = function once(evt, cb) {
	    return this.on(evt, cb, true);
	  }
	  /**
	   * off is the public interface for unsubscribing from an event
	   * @param {string} evt the event name to unsubscribe from
	   */
	  ;

	  _proto.off = function off(evt) {
	    delete this._listeners[evt];
	    return this;
	  }
	  /**
	   * emit is the public interface for broadcasting messages/events
	   * @param {string} evt the event name to publish from
	   * @param {Object} data the data to send along to the subscribers
	   */
	  ;

	  _proto.emit = function emit(evt, data) {
	    var listeners = this._listeners[evt];

	    if (listeners === undefined) {
	      return;
	    } // Invoke each of all the listener handlers and remove the ones that should fire only once.


	    var keep = [];

	    for (var i = 0; i < listeners.length; i++) {
	      listeners[i].cb(data);

	      if (listeners[i].once === true) {
	        continue;
	      } // Instead of having a 'dirty' array with deleted or 'undefined' entries,
	      // we just create a brand new array without the listeners that were removed


	      keep.push(listeners[i]);
	    } // Update our old list of listeners to the newly created array


	    this._listeners[evt] = keep;
	    return this;
	  };

	  return EventEmitter;
	}();

	/**
	 * State contains the data for the component
	 * and exposes an {EventEmitter} interface so that external
	 * dependencies can listen/hook subscribe to messages/updates.
	 * @extends EventEmitter
	 */

	var State = /*#__PURE__*/function (_EventEmitter) {
	  _inheritsLoose(State, _EventEmitter);

	  function State(data) {
	    var _this;

	    _this = _EventEmitter.call(this) || this;
	    /**
	     * The initial state of the component
	     * @type {Object}
	     * @private
	     */

	    _this._state = data || {};
	    return _this;
	  }
	  /**
	   * Set the initial state of the component.
	   * NOTE(billy): Does not fire an update message
	   */


	  var _proto = State.prototype;

	  _proto.init = function init(prop, optVal) {
	    this._set(prop, optVal);
	  }
	  /**
	   * setter for the state
	   * @param prop {string|Object} The property to set
	   * @param optVal Optional, if prop is a {string}, it will assign the value to that property
	   */
	  ;

	  _proto.set = function set(prop, optVal) {
	    this._set(prop, optVal);

	    this.emit('update');
	  }
	  /**
	   * setter for the state enables you to update a single property, or complete state
	   * depending on the arguments provided.
	   * @param prop {string|Object} The property to set
	   * @param optVal If prop is a {string}, provide its value
	   * @private
	   */
	  ;

	  _proto._set = function _set(prop, optVal) {
	    if (optVal === undefined) {
	      this._state = prop;
	    } else {
	      this._state[prop] = optVal;
	    }
	  };

	  _proto.update = function update(data) {
	    this._state = data;
	    this.emit('update');
	  }
	  /**
	   * Retrieve a properties value from the state
	   * If no property provided, return the full state
	   * @param {string} optProp optional property to retrieve
	   */
	  ;

	  _proto.get = function get(optProp) {
	    if (optProp === undefined) {
	      return this._state;
	    }

	    return this._state[optProp];
	  };

	  _proto.has = function has(prop) {
	    return this._state[prop] !== undefined;
	  };

	  _proto.asJSON = function asJSON() {
	    return this._state;
	  };

	  return State;
	}(EventEmitter);

	/**
	 * Types of HTTP requests
	 */

	var Methods = {
	  GET: 'get',
	  POST: 'post',
	  PUT: 'put',
	  DELETE: 'delete'
	};
	/**
	 * HttpRequester is a wrapper around the native implementation of AJAX
	 * related matters. It's used to make all types of network requests
	 * and exposes a promise interface.
	 */

	var HttpRequester = /*#__PURE__*/function () {
	  function HttpRequester() {}

	  var _proto = HttpRequester.prototype;

	  /**
	   * Create a GET HTTP request
	   * @param {string} url The url to make a request to
	   * @param {Object} data The data to provide (gets encoded into the URL)
	   * @param {Object} opts Configuration options to use for the request
	   */
	  _proto.get = function get(url, data, opts) {
	    return this.request(Methods.GET, this.encodeParams(url, data), opts);
	  }
	  /**
	   * Create a POST HTTP request
	   * @param {string} url The url to make a request to
	   * @param {Object} urlParams The params to encode into the URL
	   * @param {Object} jsonBody The request body (json) to provide with the POST request
	   * @param {Object} requestConfig Configuration options to use for the request
	   */
	  ;

	  _proto.post = function post(url, urlParams, jsonBody, requestConfig) {
	    return this.request(Methods.POST, this.encodeParams(url, urlParams), _extends({}, {
	      body: stringify$2(jsonBody),
	      credentials: undefined
	    }, requestConfig));
	  };

	  _proto.request = function request(method, url, opts) {
	    var reqArgs = _extends({}, {
	      method: method,
	      credentials: 'include'
	    }, opts);

	    return this._fetch(url, reqArgs);
	  } // TODO (agrow) investigate removing this
	  // Use imported fetchPolyfill if it does not already exist on window
	  ;

	  _proto._fetch = function _fetch(url, reqArgs) {
	    if (!window.fetch) {
	      return browserPonyfill_1(url, reqArgs);
	    }

	    return fetch(url, reqArgs);
	  }
	  /**
	   * Send a beacon to the provided url which will send a non-blocking request
	   * to the server that is guaranteed to send before page load. No response is returned,
	   * so beacons are primarily used for analytics reporting.
	   * @param {string} url The url to send the beacon to
	   * @param {object} data The data payload to send in the beacon
	   * @return {boolean} true if the request is successfully queued
	   */
	  ;

	  _proto.beacon = function beacon(url, data) {
	    return this._sendBeacon(url, stringify$2(data));
	  } // TODO (agrow) investigate removing this
	  // Navigator.sendBeacon polyfill
	  // Combination of the compact Financial Times polyfill:
	  // https://github.com/Financial-Times/polyfill-library/blob/master/polyfills/navigator/sendBeacon/polyfill.js
	  // with the async-by-default behavior of Miguel Mota's polyfill:
	  // https://github.com/miguelmota/Navigator.sendBeacon/blob/master/sendbeacon.js
	  ;

	  _proto._sendBeacon = function _sendBeacon(url, data) {
	    if (window.navigator && window.navigator.sendBeacon) {
	      return window.navigator.sendBeacon(url, data);
	    }

	    var event = window.event && window.event.type;
	    var sync = event === 'unload' || event === 'beforeunload';
	    var xhr = 'XMLHttpRequest' in window ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP');
	    xhr.open('POST', url, !sync);
	    xhr.setRequestHeader('Accept', '*/*');

	    if (typeof data === 'string') {
	      xhr.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
	    } else if (Object.prototype.toString.call(data) === '[object Blob]') {
	      if (data.type) {
	        xhr.setRequestHeader('Content-Type', data.type);
	      }
	    }

	    xhr.send(data);
	    return true;
	  };

	  _proto.encodeParams = function encodeParams(url, params) {
	    if (typeof params !== 'object') {
	      return;
	    }

	    var hasParam = indexOf$3(url).call(url, '?') > -1;
	    var searchQuery = '';

	    for (var key in params) {
	      if (!hasParam) {
	        hasParam = true;
	        searchQuery += '?';
	      } else {
	        searchQuery += '&';
	      }

	      searchQuery += key + '=' + encodeURIComponent(params[key]);
	    }

	    return url + searchQuery;
	  };

	  return HttpRequester;
	}();

	function ownKeys$5(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$5(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$5(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

	/**
	 * Class for reporting analytics events to the server via HTTP
	 *
	 * @implements {AnalyticsReporterService}
	 */

	var AnalyticsReporter = /*#__PURE__*/function () {
	  function AnalyticsReporter(experienceKey, experienceVersion, businessId, analyticsEventsEnabled, globalOptions, environment) {
	    if (globalOptions === void 0) {
	      globalOptions = {};
	    }

	    if (environment === void 0) {
	      environment = PRODUCTION;
	    }

	    /**
	     * The internal business identifier used for reporting
	     * @type {number}
	     */
	    this._businessId = businessId;
	    /**
	     * Boolean indicating if the Answers Search UI submits analytic click events
	     * @type {boolean}
	     */

	    this._analyticsEventsEnabled = analyticsEventsEnabled;
	    /**
	     * Options to include with every analytic event reported to the server
	     * @type {object}
	     * @private
	     */

	    this._globalOptions = _extends({}, globalOptions, {
	      experienceKey: experienceKey
	    });
	    /**
	     * The environment of the Answers experience
	     * @type {string}
	     * @private
	     */

	    this._environment = environment;
	    /**
	     * Base URL for the analytics API
	     * @type {string}
	     * @private
	     */

	    this._baseUrl = getAnalyticsUrl(this._environment);
	    /**
	     * Boolean indicating if opted in or out of conversion tracking
	     * @type {boolean}
	     * @private
	     */

	    this._conversionTrackingEnabled = false;

	    if (experienceVersion) {
	      this._globalOptions.experienceVersion = experienceVersion;
	    }
	  }

	  var _proto = AnalyticsReporter.prototype;

	  _proto.getQueryId = function getQueryId() {
	    return this._globalOptions.queryId;
	  };

	  _proto.setQueryId = function setQueryId(queryId) {
	    this._globalOptions.queryId = queryId;
	  }
	  /**
	   * Opt in or out of analytics click events
	   * @param {boolean} analyticsEventsEnabled
	   */
	  ;

	  _proto.setAnalyticsOptIn = function setAnalyticsOptIn(analyticsEventsEnabled) {
	    this._analyticsEventsEnabled = analyticsEventsEnabled;
	  }
	  /** @inheritdoc */
	  ;

	  _proto.report = function report(event) {
	    if (!this._analyticsEventsEnabled) {
	      return false;
	    }

	    var cookieData = {};

	    if (this._conversionTrackingEnabled && typeof ytag === 'function') {
	      ytag('optin', true);
	      cookieData = ytag('yfpc', null);
	    } else if (this._conversionTrackingEnabled) {
	      throw new AnswersAnalyticsError('Tried to enable conversion tracking without including ytag');
	    }

	    if (!(event instanceof AnalyticsEvent)) {
	      throw new AnswersAnalyticsError('Tried to send invalid analytics event', event);
	    }

	    event.addOptions(this._globalOptions);
	    return new HttpRequester().beacon(this._baseUrl + "/realtimeanalytics/data/answers/" + this._businessId, _objectSpread$4({
	      data: event.toApiEvent()
	    }, cookieData));
	  }
	  /** @inheritdoc */
	  ;

	  _proto.setConversionTrackingEnabled = function setConversionTrackingEnabled(isEnabled) {
	    this._conversionTrackingEnabled = isEnabled;
	    this._baseUrl = getAnalyticsUrl(this._environment, isEnabled);
	  };

	  return AnalyticsReporter;
	}();

	/** @typedef {import('../services/analyticsreporterservice').default} AnalyticsReporterService */

	/**
	 * @implements {AnalyticsReporterService}
	 */
	var NoopAnalyticsReporter = /*#__PURE__*/function () {
	  function NoopAnalyticsReporter() {}

	  var _proto = NoopAnalyticsReporter.prototype;

	  /** @inheritdoc */
	  _proto.report = function report(event) {
	    return true;
	  }
	  /** @inheritdoc */
	  ;

	  _proto.setConversionTrackingEnabled = function setConversionTrackingEnabled(isEnabled) {};

	  return NoopAnalyticsReporter;
	}();

	var map$6 = map$3;

	var map$7 = map$6;

	function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var _context2; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context2 = it.next).call(_context2, it); }

	function _unsupportedIterableToArray$2(o, minLen) { var _context; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

	function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var urlutils$1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  exports.areEquivalentParams = void 0;
	  /**
	   * Returns if two SearchParams objects have the same key,value entries
	   *
	   * @param {SearchParams} params1
	   * @param {SearchParams} params2
	   * @return {boolean} true if params1 and params2 have the same key,value entries, false otherwise
	   */

	  function areEquivalentParams(params1, params2) {
	    var entries1 = from_1$2(entries$2(params1).call(params1));

	    var entries2 = from_1$2(entries$2(params2).call(params2));

	    if (entries1.length !== entries2.length) {
	      return false;
	    }

	    for (var _iterator = _createForOfIteratorHelperLoose$2(entries$2(params1).call(params1)), _step; !(_step = _iterator()).done;) {
	      var _step$value = _step.value,
	          key = _step$value[0],
	          val = _step$value[1];

	      if (val !== params2.get(key)) {
	        return false;
	      }
	    }

	    return true;
	  }

	  exports.areEquivalentParams = areEquivalentParams;
	});
	unwrapExports(urlutils$1);
	var urlutils_1$1 = urlutils$1.areEquivalentParams;

	var SearchParams_1 = createCommonjsModule(function (module, exports) {

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });
	  /**
	   * SearchParams is a class to get the search params in a URL.
	   * It is a replacement for URL.searchParams and URLSearchParams for browsers like IE11
	   */


	  var SearchParams = /*#__PURE__*/function () {
	    function SearchParams(url) {
	      if (url === void 0) {
	        url = '';
	      }

	      this.params = this.parse(url);
	    }
	    /**
	     * parse creates a mapping of all query params in a given url
	     * The query param values are decoded before being put in the map
	     * Three types of input are supported
	     *   (1) full URL e.g. http://www.yext.com/?q=hello
	     *   (2) params with ? e.g. ?q=hello
	     *   (1) params without ? e.g. q=hello
	     *
	     * @param {string} url The url
	     * @returns {StorageEntries} mapping from query param -> value where value is '' if no value is provided
	     */


	    var _proto = SearchParams.prototype;

	    _proto.parse = function parse(url) {
	      var params = new map$7();
	      var search = url;

	      if (!search) {
	        return params;
	      } // Normalize all url inputs to string of query params separated by &


	      if (indexOf$3(url).call(url, '?') > -1) {
	        search = slice$4(url).call(url, indexOf$3(url).call(url, '?') + 1);
	      }

	      var encodedParams = search.split('&');

	      for (var i = 0; i < encodedParams.length; i++) {
	        var keyVal = encodedParams[i].split('=');

	        if (keyVal.length > 1) {
	          params.set(keyVal[0], SearchParams.decode(keyVal[1]));
	        } else {
	          params.set(keyVal[0], '');
	        }
	      }

	      return params;
	    }
	    /**
	     * get returns the value of the given query param
	     *
	     * @param {string} query the query param key to get the value of
	     * @return {string} param value, undefined otherwise
	     */
	    ;

	    _proto.get = function get(query) {
	      return this.params.get(query);
	    }
	    /**
	     * set changes the value of a given query param
	     *
	     * @param {string} name the query param key
	     * @param {string} value the value of the query param update with
	     */
	    ;

	    _proto.set = function set(name, value) {
	      this.params.set(name, value);
	    }
	    /**
	     * has checks to see if the given query param key exists in the params object
	     *
	     * @param {string} query the query param to check
	     * @return {boolean} true if the query param is in the params object, false o/w
	     */
	    ;

	    _proto.has = function has(query) {
	      return query in this.params;
	    }
	    /**
	     * delete removes the given query param and its associated value from the params object
	     *
	     * @param {string} name the query param key
	     */
	    ;

	    _proto["delete"] = function _delete(name) {
	      this.params["delete"](name);
	    }
	    /**
	     * toString returns a url with all the query params in the params object (without a ?)
	     *
	     * @return {string}
	     */
	    ;

	    _proto.toString = function toString() {
	      var _context;

	      var stringParts = [];

	      forEach$2(_context = this.params).call(_context, function (val, key) {
	        var value = val || '';
	        stringParts.push(key + "=" + SearchParams.encode(value));
	      });

	      return stringParts.join('&');
	    }
	    /**
	     * Returns all entries of the current search params
	     * @return {[string, string][]}
	     */
	    ;

	    _proto.entries = function entries() {
	      var _context2;

	      var entries = [];

	      forEach$2(_context2 = this.params).call(_context2, function (val, key) {
	        entries.push([key, val]);
	      });

	      return entries;
	    }
	    /**
	     * decode returns the decoded representation of the given string
	     *
	     * @param {string} string the string to decode
	     * @return {string}
	     */
	    ;

	    SearchParams.decode = function decode(string) {
	      return decodeURIComponent(string.replace(/[ +]/g, '%20'));
	    }
	    /**
	     * encode returns the encoded representation of the given string (e.g. + -> %2B)
	     *
	     * @param {string} string the string to encode
	     * @return {string}
	     */
	    ;

	    SearchParams.encode = function encode(string) {
	      var replace = {
	        '!': '%21',
	        '\'': '%27',
	        '(': '%28',
	        ')': '%29',
	        '%20': '+'
	      };
	      return encodeURIComponent(string).replace(/[!'()]|%20/g, function (match) {
	        return replace[match];
	      });
	    };

	    return SearchParams;
	  }();

	  exports["default"] = SearchParams;
	});
	unwrapExports(SearchParams_1);

	function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var _context3; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context3 = it.next).call(_context3, it); }

	function _unsupportedIterableToArray$3(o, minLen) { var _context2; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = slice$4(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

	function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	var dist = createCommonjsModule(function (module, exports) {

	  var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function (mod) {
	    return mod && mod.__esModule ? mod : {
	      "default": mod
	    };
	  };

	  defineProperty$3(exports, "__esModule", {
	    value: true
	  });

	  var SearchParams_1$1 = __importDefault(SearchParams_1);
	  /**
	   * DefaultPersistentStorage is a container around interactions maintaining
	   * state in the URL. It should be used to encode the important parts of the
	   * current state so information can be preserved across different page
	   * sessions and page paths.
	   */


	  var DefaultPersistentStorage = /*#__PURE__*/function () {
	    /**
	     * @param {Function} popListener The callback after a popstate on the window (back nav)
	     */
	    function DefaultPersistentStorage(popListener) {
	      var _this = this;

	      this.popListener = popListener;
	      this.params = new SearchParams_1$1["default"]();
	      window.addEventListener('popstate', function () {
	        _this.params = new SearchParams_1$1["default"](window.location.search.substring(1));

	        _this.popListener(_this.getAll(), _this.getUrlWithCurrentState());
	      });
	    }
	    /**
	     * Decodes the initial state from the query params. This could be a
	     * direct mapping from query param to storage keys in the storage or
	     * could fetch a sessionId from some backend
	     *
	     * @param {string} urlSearchParams The starting URL search params
	     */


	    var _proto = DefaultPersistentStorage.prototype;

	    _proto.init = function init(urlSearchParams) {
	      this.params = new SearchParams_1$1["default"](urlSearchParams);
	    }
	    /**
	     * Adds the given key value pair to persistent storage. This does not
	     * encode the entry into the URL until pushStateToHistory is called.
	     *
	     * @param {string} key
	     * @param {string} value
	     */
	    ;

	    _proto.set = function set(key, value) {
	      if (typeof key !== 'string') {
	        throw new Error('Storage data key must be a string: ' + key);
	      }

	      if (typeof value !== 'string') {
	        throw new Error('Storage data value must be a string: ' + value);
	      }

	      this.params.set(key, value);
	    }
	    /**
	     * Replaces the last history state of the browser with the current state.
	     */
	    ;

	    _proto.replaceHistoryWithState = function replaceHistoryWithState() {
	      var currentParams = new SearchParams_1$1["default"](window.location.search.substring(1));

	      if (urlutils$1.areEquivalentParams(this.params, currentParams)) {
	        return;
	      }

	      window.history.replaceState(null, '', "?" + this.params.toString());
	    }
	    /**
	     * Updates the history of the browser with the current state, unless there is
	     * no change to to the current state
	     */
	    ;

	    _proto.pushStateToHistory = function pushStateToHistory() {
	      var currentParams = new SearchParams_1$1["default"](window.location.search.substring(1));

	      if (urlutils$1.areEquivalentParams(this.params, currentParams)) {
	        return;
	      }

	      window.history.pushState(null, '', "?" + this.params.toString());
	    }
	    /**
	     * Returns the value for the given key
	     *
	     * @param {string} key
	     * @return {string} Value for the given key if it exists, undefined o/w
	     */
	    ;

	    _proto.get = function get(key) {
	      if (typeof key !== 'string') {
	        throw new Error('Storage data key must be a string: ' + key);
	      }

	      return this.params.get(key);
	    }
	    /**
	     * Removes the given key from persistent storage. Does not reflect the
	     * state change in the URL until pushStateToHistory is called.
	     *
	     * @param {string} key
	     */
	    ;

	    _proto["delete"] = function _delete(key) {
	      if (typeof key !== 'string') {
	        throw new Error('Storage data key must be a string: ' + key);
	      }

	      this.params["delete"](key);
	    }
	    /**
	     * Returns a mapping of all key-values in persistent storage
	     *
	     * @return {@StorageEntries} Mapping from key to value for every entry in storage
	     */
	    ;

	    _proto.getAll = function getAll() {
	      var allParams = new map$7();

	      for (var _iterator = _createForOfIteratorHelperLoose$3(entries$2(_context = this.params).call(_context)), _step; !(_step = _iterator()).done;) {
	        var _context;

	        var _step$value = _step.value,
	            key = _step$value[0],
	            val = _step$value[1];
	        allParams.set(key, val);
	      }

	      return allParams;
	    }
	    /**
	     * Returns the query parameters to encode the current state
	     *
	     * @return {string} The query parameters for a page link with the
	     *                  current state encoded
	     * 		              e.g. ?query=all&context=%7Bkey:'hello'%7D
	     */
	    ;

	    _proto.getUrlWithCurrentState = function getUrlWithCurrentState() {
	      return this.params.toString();
	    };

	    return DefaultPersistentStorage;
	  }();

	  exports["default"] = DefaultPersistentStorage;
	});
	var DefaultPersistentStorage = unwrapExports(dist);

	/** @typedef {import('./storagelistener').default} StorageListener */

	/**
	 * Storage is a container around application state.  It
	 * exposes an interface for CRUD operations as well as listening
	 * for stateful changes.
	 *
	 * @param {Function} callback for state (persistent store) updates
	 * @param {Function} callback for state (persistent store) reset
	 */

	var Storage = /*#__PURE__*/function () {
	  function Storage(config) {
	    var _this = this;

	    if (config === void 0) {
	      config = {};
	    }

	    /**
	     * The listeners for changes in state (persistent storage changes)
	     */
	    this.persistedStateListeners = {
	      update: config.updateListener || function () {},
	      reset: config.resetListener || function () {}
	    };
	    /**
	     * A hook for parsing values from persistent storage on init.
	     *
	     * @type {Function}
	     */

	    this.persistedValueParser = config.persistedValueParser;
	    /**
	     * The listener for window.pop in the persistent storage
	     *
	     * @param {Map<string, string>} queryParamsMap A Map containing the persisted state,
	     *                                             for example a map of 'query' => 'virginia'
	     * @param {string} queryParamsString the url params of the persisted state
	     *                                   for the above case 'query=virginia'
	     */

	    this.popListener = function (queryParamsMap, queryParamsString) {
	      _this.persistedStateListeners.update(queryParamsMap, queryParamsString);

	      _this.persistedStateListeners.reset(queryParamsMap, queryParamsString);
	    };
	    /**
	     * The core data for the storage
	     *
	     * @type {Map<string, *>}
	     */


	    this.storage = new map$7();
	    /**
	     * The persistent storage implementation to store state
	     * across browser sessions and URLs
	     *
	     * @type {DefaultPersistentStorage}
	     */

	    this.persistentStorage = new DefaultPersistentStorage(this.popListener);
	    /**
	     * The listeners to apply on changes to storage
	     *
	     * @type {StorageListener[]}
	     */

	    this.listeners = [];
	  }
	  /**
	   * Decodes the initial state from the query params. This could be a
	   * direct mapping from query param to storage keys in the storage or
	   * could fetch a sessionId from some backend
	   *
	   * @param {string} url The starting URL
	   * @returns {Storage}
	   */


	  var _proto = Storage.prototype;

	  _proto.init = function init(url) {
	    var _context,
	        _this2 = this;

	    this.persistentStorage.init(url);

	    forEach$2(_context = this.persistentStorage.getAll()).call(_context, function (value, key) {
	      var parsedValue = _this2.persistedValueParser ? _this2.persistedValueParser(key, value) : value;

	      _this2.set(key, parsedValue);
	    });

	    return this;
	  }
	  /**
	   * Set the data in storage with the given key to the provided
	   * data, completely overwriting any existing data.
	   *
	   * @param {string} key The storage key to set
	   * @param {*} data The data to set
	   */
	  ;

	  _proto.set = function set(key, data) {
	    if (key === undefined || key === null || typeof key !== 'string') {
	      throw new AnswersStorageError('Storage key must be of type string', key, data);
	    }

	    if (typeof data === 'undefined') {
	      throw new AnswersStorageError('Data cannot be of type undefined', key, data);
	    }

	    this.storage.set(key, data);

	    this._callListeners('update', key);
	  }
	  /**
	   * Updates the storage with a new entry of [key, data].  The entry
	   * is not added to the URL until the history is updated.
	   *
	   * @param {string} key The storage key to set
	   * @param {*} data The data to set
	   */
	  ;

	  _proto.setWithPersist = function setWithPersist(key, data) {
	    this.set(key, data);
	    var serializedData = data;

	    if (typeof data !== 'string') {
	      serializedData = stringify$2(data);
	    }

	    this.persistentStorage.set(key, serializedData);
	  }
	  /**
	   * Adds all entries of the persistent storage to the URL,
	   * replacing the current history state.
	   */
	  ;

	  _proto.replaceHistoryWithState = function replaceHistoryWithState() {
	    this.persistentStorage.replaceHistoryWithState();
	    this.persistedStateListeners.update(this.persistentStorage.getAll(), this.getCurrentStateUrlMerged());
	  }
	  /**
	   * Adds all entries of the persistent storage to the URL.
	   */
	  ;

	  _proto.pushStateToHistory = function pushStateToHistory() {
	    this.persistentStorage.pushStateToHistory();
	    this.persistedStateListeners.update(this.persistentStorage.getAll(), this.getCurrentStateUrlMerged());
	  }
	  /**
	   * Get the current state for the provided key
	   *
	   * @param {string} key The storage key to get
	   * @return {*} The state for the provided key, undefined if key doesn't exist
	   */
	  ;

	  _proto.get = function get(key) {
	    return this.storage.get(key);
	  }
	  /**
	   * Get the current state for all key/value pairs in storage
	   *
	   * @return {Map<string, *>} mapping from key to value representing the current state
	   */
	  ;

	  _proto.getAll = function getAll() {
	    return new map$7(this.storage);
	  }
	  /**
	   * Remove the data in storage with the given key
	   *
	   * @param {string} key The storage key to delete
	   */
	  ;

	  _proto["delete"] = function _delete(key) {
	    if (key === undefined || key === null || typeof key !== 'string') {
	      throw new AnswersStorageError('Storage key must be of type string', key);
	    }

	    this.storage["delete"](key);
	    this.persistentStorage["delete"](key);
	  }
	  /**
	   * Whether the specified key exists or not
	   *
	   * @param {string} key the storage key
	   * @return {boolean}
	   */
	  ;

	  _proto.has = function has(key) {
	    return this.storage.has(key);
	  }
	  /**
	   * Returns the url representing the current persisted state, merged
	   * with any additional query params currently in the url.
	   *
	   * @returns {string}
	   */
	  ;

	  _proto.getCurrentStateUrlMerged = function getCurrentStateUrlMerged() {
	    var _context2;

	    var searchParams = new SearchParams(window.location.search.substring(1));

	    forEach$2(_context2 = this.persistentStorage.getAll()).call(_context2, function (value, key) {
	      searchParams.set(key, value);
	    });

	    return searchParams.toString();
	  }
	  /**
	   * Returns the query parameters to encode the current state
	   *
	   * @return {string} The query parameters for a page link with the
	   *                  current state encoded
	   *                  e.g. query=all&context=%7Bkey:'hello'%7D
	   */
	  ;

	  _proto.getUrlWithCurrentState = function getUrlWithCurrentState() {
	    return this.persistentStorage.getUrlWithCurrentState();
	  }
	  /**
	   * Adds a listener to the given module for a given event
	   *
	   * @param {StorageListener} listener the listener to add
	   */
	  ;

	  _proto.registerListener = function registerListener(listener) {
	    if (!listener.eventType || !listener.storageKey || !listener.callback || typeof listener.callback !== 'function') {
	      throw new AnswersStorageError("Invalid listener applied in storage: " + listener);
	    }

	    this.listeners.push(listener);
	  }
	  /**
	   * Removes a given listener from the set of listeners
	   *
	   * @param {StorageListener} listener the listener to remove
	   */
	  ;

	  _proto.removeListener = function removeListener(listener) {
	    var _context3;

	    this.listeners = filter$2(_context3 = this.listeners).call(_context3, function (l) {
	      return l !== listener;
	    });
	  }
	  /**
	   * @param {string} eventType
	   * @param {string} storageKey
	   */
	  ;

	  _proto._callListeners = function _callListeners(eventType, storageKey) {
	    var _context4,
	        _this3 = this;

	    forEach$2(_context4 = this.listeners).call(_context4, function (listener) {
	      if (listener.storageKey === storageKey && listener.eventType === eventType) {
	        listener.callback(_this3.get(storageKey));
	      }
	    });
	  };

	  return Storage;
	}();

	function ownKeys$6(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context10; forEach$2(_context10 = ownKeys$6(Object(source), true)).call(_context10, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context11; forEach$2(_context11 = ownKeys$6(Object(source))).call(_context11, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * Component is an abstraction that encapsulates state, behavior,
	 * and view for a particular chunk of functionality on the page.
	 *
	 * The API exposes event life cycle hooks for when things are rendered,
	 * mounted, created, etc.
	 */

	var Component = /*#__PURE__*/function () {
	  function Component(config, systemConfig) {
	    var _context, _context2, _context3;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    this.moduleId = null;
	    /**
	     * A unique id number for the component.
	     * @type {number}
	     */

	    this.uniqueId = systemConfig.uniqueId;
	    /**
	     * Name of this component instance.
	     * @type {String}
	     */

	    this.name = config.name || this.constructor.type;
	    /**
	     * Cache the options so that we can propogate properly to child components
	     * @type {Object}
	     */

	    this._config = config;
	    /**
	     * An identifier used to classify the type of component.
	     * The component manager uses this information in order to persist and organize components
	     * @type {string|ComponentType}
	     */

	    this._type = this.constructor.name;
	    /**
	     * A local reference to the parent component, if exists
	     * @type {Component}
	     */

	    this._parentContainer = config.parentContainer || null;
	    /**
	     * A container for all the child components
	     * @type {Component[]}
	     */

	    this._children = [];
	    /**
	     * The state (data) of the component to be provided to the template for rendering
	     * @type {object}
	     */

	    this._state = new State(config.state);
	    /**
	     * TODO(billy) This should be 'services'
	     */

	    this.core = systemConfig.core || null;
	    /**
	     * A local reference to the component manager, which contains all of the component classes
	     * eligible to be created
	     * @type {ComponentManager}
	     */

	    this.componentManager = systemConfig.componentManager || null;
	    /**
	     * A local reference to the analytics reporter, used to report events for this component
	     * @type {AnalyticsReporter}
	     */

	    this.analyticsReporter = systemConfig.analyticsReporter || null;
	    /**
	     * Options to include with all analytic events sent by this component
	     * @type {object}
	     * @private
	     */

	    this._analyticsOptions = config.analyticsOptions || {};
	    /**
	     * Allows the main thread to regain control while rendering child components
	     * @type {boolean}
	     */

	    this._progressivelyRenderChildren = config.progressivelyRenderChildren;
	    /**
	     * A reference to the DOM node that the component will be appended to when mounted/rendered.
	     * @type {HTMLElement}
	     */

	    if (this._parentContainer === null) {
	      if (typeof config.container === 'string') {
	        this._container = DOM.query(config.container) || null;

	        if (this._container === null) {
	          throw new Error('Cannot find container DOM node: ' + config.container);
	        }
	      }
	    } else {
	      this._container = DOM.query(this._parentContainer, config.container); // If we have a parent, and the container is missing from the DOM,
	      // we construct the container and append it to the parent

	      if (this._container === null) {
	        this._container = DOM.createEl('div', {
	          "class": config.container.substring(1, config.container.length)
	        });
	        DOM.append(this._parentContainer, this._container);
	      }
	    }
	    /**
	     * A custom class to be applied to {this._container} node. Note that the class
	     * 'yxt-Answers-component' will be included as well.
	     * @type {string}
	     */


	    this._className = config["class"] || 'component';
	    /**
	     * A custom render function to be used instead of using the default renderer
	     * @type {Renderer}
	     */

	    this._render = config.render || null;
	    /**
	     * A local reference to the default {Renderer} that will be used for rendering the template
	     * @type {Renderer}
	     */

	    this._renderer = systemConfig.renderer || Renderers.Handlebars;
	    /**
	     * The template string to use for rendering the component
	     * If this is left empty, we lookup the template the base templates using the templateName
	     * @type {string}
	     */

	    this._template = config.template ? this._renderer.compile(config.template) : null;
	    /**
	     * The templateName to use for rendering the component.
	     * This is only used if _template is empty.
	     * @type {string}
	     */

	    this._templateName = config.templateName || this.constructor.defaultTemplateName(config);
	    /**
	     * An internal state indicating whether or not the component has been mounted to the DOM
	     * @type {boolean}
	     */

	    this._isMounted = false;
	    /**
	     * A local reference to the callback, thats used to transform the internal data
	     * models of the components, before it gets applied to the component state.
	     * By default, no transformation happens.
	     * @type {function}
	     */

	    this.transformData = config.transformData;
	    /**
	     * The a local reference to the callback that will be invoked when a component is created.
	     * @type {function}
	     */

	    this.onCreate = config.onCreateOverride || this.onCreate || function () {};

	    this.onCreate = bind$2(_context = this.onCreate).call(_context, this);
	    /**
	     * The a local reference to the callback that will be invoked when a component is Mounted.
	     * @type {function}
	     */

	    this.onMount = config.onMountOverride || this.onMount || function () {};

	    this.onMount = bind$2(_context2 = this.onMount).call(_context2, this);
	    /**
	     * The a local reference to the callback that will be invoked when a components state is updated.
	     * @type {function}
	     */

	    this.onUpdate = config.onUpdateOverride || this.onUpdate || function () {};

	    this.onUpdate = bind$2(_context3 = this.onUpdate).call(_context3, this);
	    /**
	     * A user provided onCreate callback
	     * @type {function}
	     */

	    this.userOnCreate = config.onCreate || function () {};
	    /**
	     * A user provided onMount callback
	     * @type {function}
	     */


	    this.userOnMount = config.onMount || function () {};
	    /**
	     * A user provided onUpdate callback
	     * @type {function}
	     */


	    this.userOnUpdate = config.onUpdate || function () {};
	  }
	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */


	  Component.defaultTemplateName = function defaultTemplateName(config) {
	    return 'default';
	  };

	  Component.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return false;
	  };

	  var _proto = Component.prototype;

	  _proto.init = function init(opts) {
	    var _this = this;

	    try {
	      this.setState(opts.data || opts.state || {});
	      this.onCreate();
	      this.userOnCreate();
	    } catch (e) {
	      throw new AnswersComponentError('Error initializing component', this.constructor.type, e);
	    }

	    this._state.on('update', function () {
	      try {
	        _this.onUpdate();

	        _this.userOnUpdate();

	        _this.unMount();

	        _this.mount();
	      } catch (e) {
	        throw new AnswersComponentError('Error updating component', _this.constructor.type, e);
	      }
	    });

	    DOM.addClass(this._container, this._className);
	    DOM.addClass(this._container, 'yxt-Answers-component');
	    return this;
	  }
	  /**
	   * Adds a class to the container of the component.
	   * @param {string} className A comma separated value of classes
	   */
	  ;

	  _proto.addContainerClass = function addContainerClass(className) {
	    DOM.addClass(this._container, className);
	  }
	  /**
	   * Removes the specified classes from the container of the component
	   * @param {string} className A comma separated value of classes
	   */
	  ;

	  _proto.removeContainerClass = function removeContainerClass(className) {
	    DOM.removeClass(this._container, className);
	  };

	  _proto.setState = function setState(data) {
	    var newState = _extends({}, {
	      _config: this._config
	    }, data);

	    this._state.set(newState);

	    return this;
	  };

	  _proto.getState = function getState(prop) {
	    return this._state.get(prop);
	  };

	  _proto.hasState = function hasState(prop) {
	    return this._state.has(prop);
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    var childComponent = this.componentManager.create(type, _extends({
	      name: data.name,
	      parentContainer: this._container,
	      data: data
	    }, opts || {}, {
	      _parentOpts: this._config
	    }));

	    this._children.push(childComponent);

	    return childComponent;
	  }
	  /**
	   * Unmount and remove this component and its children from the list
	   * of active components
	   */
	  ;

	  _proto.remove = function remove() {
	    var _context4;

	    forEach$2(_context4 = this._children).call(_context4, function (c) {
	      return c.remove();
	    });

	    this.componentManager.remove(this);
	  }
	  /**
	   * Set the render method to be used for rendering the component
	   * @param {Function} render
	   * @return {string}
	   */
	  ;

	  _proto.setRender = function setRender(render) {
	    this._render = render;
	    return this;
	  }
	  /**
	   * Set the renderer for the component
	   * @param {RendererType} renderer
	   */
	  ;

	  _proto.setRenderer = function setRenderer(renderer) {
	    this._renderer = Renderers[renderer];
	    return this;
	  }
	  /**
	   * Sets the template for the component to use when rendering
	   * @param {string} template
	   */
	  ;

	  _proto.setTemplate = function setTemplate(template) {
	    this._template = this._renderer.compile(template);
	  };

	  _proto.unMount = function unMount() {
	    var _context5, _context6;

	    if (!this._container) {
	      return this;
	    }

	    forEach$2(_context5 = this._children).call(_context5, function (child) {
	      child.unMount();
	    });

	    DOM.empty(this._container);

	    forEach$2(_context6 = this._children).call(_context6, function (c) {
	      return c.remove();
	    });

	    this._children = [];
	    this.onUnMount();
	  };

	  _proto.mount = function mount(container) {
	    var _this2 = this;

	    if (container) {
	      this._container = container;
	    }

	    if (!this._container) {
	      return this;
	    }

	    if (this.beforeMount() === false) {
	      return this;
	    }

	    DOM.append(this._container, this.render(this._state.asJSON())); // Process the DOM to determine if we should create
	    // in-memory sub-components for rendering

	    var domComponents = DOM.queryAll(this._container, '[data-component]:not([data-is-component-mounted])');
	    var data = this.transformData ? this.transformData(lodash_clonedeep(this._state.get())) : this._state.get();

	    forEach$2(domComponents).call(domComponents, function (c) {
	      return _this2._createSubcomponent(c, data);
	    });

	    if (this._progressivelyRenderChildren) {
	      var _context7;

	      forEach$2(_context7 = this._children).call(_context7, function (child) {
	        setTimeout$2(function () {
	          child.mount();
	        });
	      });
	    } else {
	      var _context8;

	      forEach$2(_context8 = this._children).call(_context8, function (child) {
	        child.mount();
	      });
	    } // Attach analytics hooks as necessary


	    if (this.analyticsReporter) {
	      var _context9;

	      var domHooks = DOM.queryAll(this._container, '[data-eventtype]:not([data-is-analytics-attached])');

	      forEach$2(domHooks).call(domHooks, bind$2(_context9 = this._createAnalyticsHook).call(_context9, this));
	    }

	    this._isMounted = true;
	    this.onMount(this);
	    this.userOnMount(this);
	    DOM.removeClass(this._container, 'yxt-Answers-component--unmounted');
	    return this;
	  }
	  /**
	   * render the template using the {Renderer} with the current state and template of the component
	   * @returns {string}
	   */
	  ;

	  _proto.render = function render(data) {
	    if (data === void 0) {
	      data = this._state.get();
	    }

	    this.beforeRender(); // Temporary fix for passing immutable data to transformData().

	    data = this.transformData ? this.transformData(lodash_clonedeep(data)) : data;
	    var html = ''; // Use either the custom render function or the internal renderer
	    // dependant on the component configuration

	    if (typeof this._render === 'function') {
	      html = this._render(data);

	      if (typeof html !== 'string') {
	        throw new Error('Render method must return HTML as type {string}');
	      }
	    } else {
	      // Render the existing templates as a string
	      html = this._renderer.render({
	        template: this._template,
	        templateName: this._templateName
	      }, data);
	    }

	    this.afterRender();
	    return html;
	  };

	  _proto._createSubcomponent = function _createSubcomponent(domComponent, data) {
	    var _this3 = this;

	    domComponent.dataset.isComponentMounted = true;
	    var dataset = domComponent.dataset;
	    var type = dataset.component;
	    var prop = dataset.prop;
	    var opts = dataset.opts ? JSON.parse(dataset.opts) : {};
	    var childData = data[prop] || {};
	    opts = _objectSpread$5(_objectSpread$5({}, opts), {}, {
	      container: domComponent
	    }); // TODO(billy) Right now, if we provide an array as the data prop,
	    // the behavior is to create many components for each item in the array.
	    // THAT interface SHOULD change to use a different property that defines
	    // whether to array data should be used for a single component or
	    // to create many components for each item.
	    // Overloading and having this side effect is unintuitive and WRONG

	    if (!isArray$3(childData)) {
	      // Rendering a sub component should be within the context,
	      // of the node that we processed it from
	      this.addChild(childData, type, opts);
	      return;
	    }

	    reverse$2(childData).call(childData);

	    forEach$2(childData).call(childData, function (data) {
	      _this3.addChild(data, type, opts);
	    });
	  };

	  _proto._createAnalyticsHook = function _createAnalyticsHook(domComponent) {
	    var _this4 = this;

	    domComponent.dataset.isAnalyticsAttached = true;
	    var dataset = domComponent.dataset;
	    var type = dataset.eventtype;
	    var label = dataset.eventlabel;
	    var middleclick = dataset.middleclick;
	    var options = dataset.eventoptions ? JSON.parse(dataset.eventoptions) : {};
	    DOM.on(domComponent, 'mousedown', function (e) {
	      if (e.button === 0 || middleclick && e.button === 1) {
	        var event = new AnalyticsEvent(type, label);
	        event.addOptions(_this4._analyticsOptions);
	        event.addOptions(options);

	        _this4.analyticsReporter.report(event);
	      }
	    });
	  }
	  /**
	   * onCreate is triggered when the component is constructed
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.onCreate = function onCreate(cb) {}
	  /**
	   * onUpdate is triggered when the state of the component changes
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.onUpdate = function onUpdate(cb) {}
	  /**
	   * beforeRender event is triggered before the component is rendered
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.beforeRender = function beforeRender(cb) {}
	  /**
	   * afterRender event is triggered after the component is rendered
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.afterRender = function afterRender(cb) {}
	  /**
	   * onMount is triggered when the component is appended to the DOM
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.onMount = function onMount(cb) {}
	  /**
	   * onUnMount is triggered when the component is removed from the DOM
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.onUnMount = function onUnMount(cb) {}
	  /**
	   * beforeMount is triggered before the component is mounted to the DOM
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.beforeMount = function beforeMount(cb) {}
	  /**
	   * onDestroy is triggered when the component is destroyed
	   * @param {function} the callback to invoke upon emit
	   */
	  ;

	  _proto.onDestroy = function onDestroy(cb) {};

	  _createClass(Component, null, [{
	    key: "type",
	    get: function get() {
	      return 'Component';
	    }
	  }]);

	  return Component;
	}();

	/**
	 * ApiRequest is the base class for all API requests.
	 * It defines all of the core properties required to make a request
	 */

	var ApiRequest = /*#__PURE__*/function () {
	  // TODO (tmeyer): Create an ApiService interface and pass an implementation to the current
	  // consumers of ApiRequest as a dependency.
	  function ApiRequest(opts, storage) {
	    if (opts === void 0) {
	      opts = {};
	    }

	    if (storage === void 0) {
	      storage = undefined;
	    }

	    /**
	     * An abstraction used for making network request and handling errors
	     * @type {HttpRequester}
	     * @private
	     */
	    this._requester = new HttpRequester();
	    /**
	     * The environment the request should be made to
	     * @type {string}
	     * @private
	     */

	    this._environment = opts.environment || PRODUCTION;
	    /**
	     * The baseUrl to use for making a request
	     * @type {string}
	     * @private
	     */

	    this._baseUrl = opts.baseUrl || getLiveApiUrl(this._environment);
	    /**
	     * The endpoint to use in the url (appended to the {baseUrl})
	     * @type {string}
	     * @private
	     */

	    this._endpoint = opts.endpoint || null;
	    /**
	     * The API Key to use for the request
	     * @type {string}
	     * @private
	     */

	    this._apiKey = opts.apiKey || null;
	    /**
	     * The version of the API to make a request to
	     * @type {string}
	     * @private
	     */

	    this._version = opts.version || 20190101;
	    /**
	     * Additional data params that are sent along with the request
	     * @type {string}
	     * @private
	     */

	    this._params = opts.params || {};

	    if (!storage) {
	      throw new AnswersBasicError('Must include storage', 'ApiRequest');
	    }
	    /**
	     * @type {Storage}
	     * @private
	     */


	    this._storage = storage;
	  }
	  /**
	   * get creates a new `GET` request to the server using the configuration of the request class
	   *
	   * @param {Object} opts Any configuration options to use for the GET request.
	   * @returns {Promise<Response>}
	   */


	  var _proto = ApiRequest.prototype;

	  _proto.get = function get(opts) {
	    return this._requester.get(this._baseUrl + this._endpoint, _extends({}, this.baseParams(), this.sanitizeParams(this._params)), opts);
	  }
	  /**
	   * @param {Object} opts
	   * @returns {Promise<Response>}
	   */
	  ;

	  _proto.post = function post(opts) {
	    return this._requester.post(this._baseUrl + this._endpoint, this.baseParams()
	    /* urlParams */
	    , this.sanitizeParams(this._params)
	    /* jsonBody */
	    , opts
	    /* requestConfig */
	    );
	  }
	  /**
	   * @returns {Object}
	   * @private
	   */
	  ;

	  _proto.baseParams = function baseParams() {
	    var baseParams = {
	      v: this._version,
	      api_key: this._apiKey,
	      jsLibVersion: LIB_VERSION,
	      sessionTrackingEnabled: this._storage.get(StorageKeys.SESSIONS_OPT_IN).value
	    };
	    var urlParams = new SearchParams(this._storage.getCurrentStateUrlMerged());

	    if (urlParams.has('beta')) {
	      baseParams.beta = urlParams.get('beta');
	    }

	    return baseParams;
	  };

	  _proto.sanitizeParams = function sanitizeParams(params) {
	    var _context;

	    if (params === void 0) {
	      params = {};
	    }

	    // Remove any paramaters whos value is `undefined`.
	    //
	    // NOTE(billy) Probably better to be explicit about how to handle this at the request building level,
	    // but I can't see any cases where we'd ever want to send 'undefined' as a value to the server.
	    // So it's probably fine to 'clean' the params object here
	    forEach$2(_context = keys$3(params)).call(_context, function (key) {
	      if (params[key] === undefined || params[key] === null) {
	        delete params[key];
	      }
	    });

	    return params;
	  };

	  return ApiRequest;
	}();

	/** @module ErrorReporter */
	/** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

	/**
	 * ErrorReporter is used for reporting errors to the console and API
	 *
	 * @implements {ErrorReporterService}
	 */

	var ErrorReporter = /*#__PURE__*/function () {
	  function ErrorReporter(config, storage) {
	    var _this = this;

	    /**
	     * The apiKey to use for reporting
	     * @type {string}
	     */
	    this.apiKey = config.apiKey;
	    /**
	     * The experienceKey to use when reporting
	     * @type {string}
	     */

	    this.experienceKey = config.experienceKey;
	    /**
	     * The answers config version used for api requests
	     * @type {string|number}
	     */

	    this.experienceVersion = config.experienceVersion || 'config1.0';
	    /**
	     * If true, print entire error objects to the console for inspection
	     * @type {boolean}
	     */

	    this.printVerbose = config.printVerbose;
	    /**
	     * If true, report the error the server for logging and monitoring
	     * @type {boolean}
	     */

	    this.sendToServer = config.sendToServer;
	    /**
	     * The storage instance of the experience
	     * @type {Storage}
	     */

	    if (this.sendToServer && !storage) {
	      throw new AnswersBasicError('Must include storage to send errors to server', 'ErrorReporter');
	    }

	    this.storage = storage;
	    /**
	     * The environment of the Answers experience
	     * @type {string}
	     * @private
	     */

	    this.environment = config.environment; // Attach reporting listeners to window

	    window.addEventListener('error', function (e) {
	      return _this.report(e.error);
	    });
	    window.addEventListener('unhandledrejection', function (e) {
	      return _this.report(e.error);
	    });
	  }
	  /**
	   * report pretty prints the error to the console, optionally
	   * prints the entire error if `printVerbose` is true, and sends the
	   * error to the server to be logged if `sendToServer` is true
	   * @param {AnswersBaseError} err The error to be reported
	   * @returns {AnswersBaseError} The reported error
	   */


	  var _proto = ErrorReporter.prototype;

	  _proto.report = function report(err) {
	    if (!(err instanceof AnswersBaseError) || err.reported) {
	      return;
	    }

	    err.reported = true;
	    this.printError(err);

	    if (this.sendToServer) {
	      var requestConfig = {
	        endpoint: '/v2/accounts/me/answers/errors',
	        apiKey: this.apiKey,
	        version: 20190301,
	        environment: this.environment,
	        params: {
	          libVersion: LIB_VERSION,
	          experienceVersion: this.experienceVersion,
	          experienceKey: this.experienceKey,
	          error: err.toJson()
	        }
	      };
	      var request = new ApiRequest(requestConfig, this.storage); // TODO(amullings): We should probably change this endpoint to POST,
	      // ideally using the beacon API. Stack traces will likely easily hit URL
	      // length limits.

	      request.get()["catch"](console.err);
	    }

	    return err;
	  }
	  /**
	   * prints the given error to the browser console
	   * @param {AnswersBaseError} err The error to be printed
	   */
	  ;

	  _proto.printError = function printError(err) {
	    if (this.printVerbose) {
	      console.error("error: " + err.errorMessage + "\ncode: " + err.errorCode + "\nboundary: " + err.boundary + "\nstack: " + err.stack);
	    } else {
	      console.error(err.toString());
	    }
	  };

	  return ErrorReporter;
	}();

	/** @typedef {import('../services/errorreporterservice').default} ErrorReporterService */

	/**
	 * @implements {ErrorReporterService}
	 */
	var ConsoleErrorReporter = /*#__PURE__*/function () {
	  function ConsoleErrorReporter() {}

	  var _proto = ConsoleErrorReporter.prototype;

	  /** @inheritdoc */
	  _proto.report = function report(err) {
	    console.error(err.toString());
	  };

	  return ConsoleErrorReporter;
	}();

	/** @module SearchConfig */

	var SearchConfig = /*#__PURE__*/function () {
	  function SearchConfig(config) {
	    if (config === void 0) {
	      config = {};
	    }

	    /**
	     * The max results per search.
	     * Also defines the number of results per page, if pagination is enabled
	     * @type {number}
	     */
	    this.limit = config.limit || 20;
	    /**
	     * The vertical key to use for all searches
	     * @type {string}
	     */

	    this.verticalKey = config.verticalKey || null;
	    /**
	     * A default search to use on initialization when the user hasn't provided a query
	     * @type {string}
	     */

	    this.defaultInitialSearch = config.defaultInitialSearch;
	    this.validate();

	    freeze$2(this);
	  }

	  var _proto = SearchConfig.prototype;

	  _proto.validate = function validate() {
	    if (typeof this.limit !== 'number' || this.limit < 1 || this.limit > 50) {
	      throw new AnswersConfigError('Search Limit must be between 1 and 50', 'SearchConfig');
	    }
	  };

	  return SearchConfig;
	}();

	var HAS_SPECIES_SUPPORT$3 = arrayMethodHasSpeciesSupport('splice');

	var max$2 = Math.max;
	var min$3 = Math.min;
	var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
	var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

	// `Array.prototype.splice` method
	// https://tc39.es/ecma262/#sec-array.prototype.splice
	// with adding support of @@species
	_export({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT$3 }, {
	  splice: function splice(start, deleteCount /* , ...items */) {
	    var O = toObject(this);
	    var len = toLength(O.length);
	    var actualStart = toAbsoluteIndex(start, len);
	    var argumentsLength = arguments.length;
	    var insertCount, actualDeleteCount, A, k, from, to;
	    if (argumentsLength === 0) {
	      insertCount = actualDeleteCount = 0;
	    } else if (argumentsLength === 1) {
	      insertCount = 0;
	      actualDeleteCount = len - actualStart;
	    } else {
	      insertCount = argumentsLength - 2;
	      actualDeleteCount = min$3(max$2(toInteger(deleteCount), 0), len - actualStart);
	    }
	    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER$1) {
	      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
	    }
	    A = arraySpeciesCreate(O, actualDeleteCount);
	    for (k = 0; k < actualDeleteCount; k++) {
	      from = actualStart + k;
	      if (from in O) createProperty(A, k, O[from]);
	    }
	    A.length = actualDeleteCount;
	    if (insertCount < actualDeleteCount) {
	      for (k = actualStart; k < len - actualDeleteCount; k++) {
	        from = k + actualDeleteCount;
	        to = k + insertCount;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
	    } else if (insertCount > actualDeleteCount) {
	      for (k = len - actualDeleteCount; k > actualStart; k--) {
	        from = k + actualDeleteCount - 1;
	        to = k + insertCount - 1;
	        if (from in O) O[to] = O[from];
	        else delete O[to];
	      }
	    }
	    for (k = 0; k < insertCount; k++) {
	      O[k + actualStart] = arguments[k + 2];
	    }
	    O.length = len - actualDeleteCount + insertCount;
	    return A;
	  }
	});

	var splice = entryVirtual('Array').splice;

	var ArrayPrototype$h = Array.prototype;

	var splice_1 = function (it) {
	  var own = it.splice;
	  return it === ArrayPrototype$h || (it instanceof Array && own === ArrayPrototype$h.splice) ? splice : own;
	};

	var splice$1 = splice_1;

	var splice$2 = splice$1;

	var $findIndex = arrayIteration.findIndex;


	var FIND_INDEX = 'findIndex';
	var SKIPS_HOLES$1 = true;

	// Shouldn't skip holes
	if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES$1 = false; });

	// `Array.prototype.findIndex` method
	// https://tc39.es/ecma262/#sec-array.prototype.findindex
	_export({ target: 'Array', proto: true, forced: SKIPS_HOLES$1 }, {
	  findIndex: function findIndex(callbackfn /* , that = undefined */) {
	    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var findIndex = entryVirtual('Array').findIndex;

	var ArrayPrototype$i = Array.prototype;

	var findIndex_1 = function (it) {
	  var own = it.findIndex;
	  return it === ArrayPrototype$i || (it instanceof Array && own === ArrayPrototype$i.findIndex) ? findIndex : own;
	};

	var findIndex$1 = findIndex_1;

	var findIndex$2 = findIndex$1;

	function _createForOfIteratorHelperLoose$4(o, allowArrayLike) { var _context2; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context2 = it.next).call(_context2, it); }

	function _unsupportedIterableToArray$4(o, minLen) { var _context; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

	function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
	/**
	 * @param {string} urlParams a query param string like "query=hi&otherParam=hello"
	 * @returns {SearchParams}
	 */

	function getUrlParams(urlParams) {
	  return new SearchParams(urlParams);
	}
	function getDefaultTabOrder(tabsConfig, urlParams) {
	  var tabOrder = []; // Use the ordering from the URL as the primary configuration
	  // And then merge it with the local configuration, if provided.

	  if (urlParams && urlParams.has('tabOrder')) {
	    tabOrder = urlParams.get('tabOrder').split(',');
	  }

	  for (var _iterator = _createForOfIteratorHelperLoose$4(tabsConfig), _step; !(_step = _iterator()).done;) {
	    var tab = _step.value;
	    var verticalKeyOrUrl = tab.verticalKey || tab.url; // Avoid duplicates if config was provided from URL

	    if (includes$4(tabOrder).call(tabOrder, verticalKeyOrUrl)) {
	      continue;
	    } // isFirst should always be the first element in the list


	    if (tab.isFirst) {
	      tabOrder.unshift(verticalKeyOrUrl);
	    } else {
	      tabOrder.push(verticalKeyOrUrl);
	    }
	  }

	  return tabOrder;
	}
	/**
	 * mergeTabOrder merges two arrays into one
	 * by appending additional tabs to the end of the original array
	 * @param {string[]} tabOrder Tab order provided by the server
	 * @param {string[]} otherTabOrder Tab order provided by configuration
	 * @return {string[]}
	 */

	function mergeTabOrder(tabOrder, otherTabOrder, tabs) {
	  for (var _iterator2 = _createForOfIteratorHelperLoose$4(otherTabOrder), _step2; !(_step2 = _iterator2()).done;) {
	    var tabConfig = _step2.value;

	    if (includes$4(tabOrder).call(tabOrder, tabConfig)) {
	      continue;
	    } // isFirst should be an override to dynamic tab ordering.


	    if (tabs[tabConfig] && tabs[tabConfig].isFirst) {
	      tabOrder.unshift(tabConfig);
	    } else {
	      tabOrder.push(tabConfig);
	    }
	  }

	  return tabOrder;
	}
	function getTabOrder(tabsConfig, dataTabOrder, urlParams) {
	  var tabOrder = getDefaultTabOrder(tabsConfig, getUrlParams(urlParams)); // We want to persist the params from the existing URL to the new
	  // URLS we create.

	  if (tabOrder && dataTabOrder) {
	    tabOrder = mergeTabOrder(dataTabOrder, tabOrder, tabsConfig);
	  }

	  return tabOrder;
	}

	/**
	 * TranslationFlagger is a class used to flag Translation calls. The usages of this class
	 * are handled and removed during SDK bundling.
	 */
	var TranslationFlagger = /*#__PURE__*/function () {
	  function TranslationFlagger() {}

	  /**
	   * Any calls of this method will be removed during a preprocessing step during SDK
	   * bundling.
	   *
	   * To support cases where someone may want to bundle without using our
	   * bundling tasks, this function attempts to return the same-language interpolated
	   * and pluralized value based on the information given.
	   *
	   * @param {string} phrase
	   * @param {string} pluralForm
	   * @param {string | number} count
	   * @param {string} context
	   * @param {Object} interpolationValues
	   * @returns {string}
	   */
	  TranslationFlagger.flag = function flag(_ref) {
	    var phrase = _ref.phrase,
	        pluralForm = _ref.pluralForm,
	        count = _ref.count,
	        context = _ref.context,
	        interpolationValues = _ref.interpolationValues;
	    var isPlural = count && count > 1 && pluralForm;
	    var declensionOfPhrase = isPlural ? pluralForm : phrase;

	    if (!interpolationValues) {
	      return declensionOfPhrase;
	    }

	    var interpolatedPhrase = declensionOfPhrase;

	    for (var _i = 0, _Object$entries = entries$5(interpolationValues); _i < _Object$entries.length; _i++) {
	      var _Object$entries$_i = _Object$entries[_i],
	          key = _Object$entries$_i[0],
	          value = _Object$entries$_i[1];
	      interpolatedPhrase = interpolatedPhrase.replace("[[" + key + "]]", value);
	    }

	    return interpolatedPhrase;
	  };

	  return TranslationFlagger;
	}();

	function _createForOfIteratorHelperLoose$5(o, allowArrayLike) { var _context8; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context8 = it.next).call(_context8, it); }

	function _unsupportedIterableToArray$5(o, minLen) { var _context7; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = slice$4(_context7 = Object.prototype.toString.call(o)).call(_context7, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

	function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function ownKeys$7(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context5; forEach$2(_context5 = ownKeys$7(Object(source), true)).call(_context5, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context6; forEach$2(_context6 = ownKeys$7(Object(source))).call(_context6, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * The debounce duration for resize events
	 * @type {number}
	 */

	var RESIZE_DEBOUNCE = 100;
	/**
	 * The breakpoint for mobile
	 * @type {number}
	 */

	var MOBILE_BREAKPOINT = 767;
	/**
	 * Enum options for mobile overflow beahvior
	 * @type {Object.<string, string>}
	 */

	var MOBILE_OVERFLOW_BEHAVIOR_OPTION = {
	  COLLAPSE: 'COLLAPSE',
	  INNERSCROLL: 'INNERSCROLL'
	};
	/**
	 * The Tab is a model that is used to power the Navigation tabs in the view.
	 * It's initialized through the configuration provided to the component.
	 */

	var Tab = /*#__PURE__*/function () {
	  function Tab(config) {
	    /**
	     * The name of the tab that is exposed for the link
	     * @type {string}
	     */
	    this.label = config.label;

	    if (typeof this.label !== 'string') {
	      throw new AnswersComponentError('label is a required configuration option for tab.', 'NavigationComponent');
	    }
	    /**
	     * The complete URL, including the params
	     * @type {string}
	     */


	    this.url = config.url;

	    if (typeof this.url !== 'string') {
	      throw new AnswersComponentError('url is a required configuration option for tab.', 'NavigationComponent');
	    }
	    /**
	     * The serverside vertical config id that this is referenced to.
	     * By providing this, enables dynamic sorting based on results.
	     * @type {string}
	     */


	    this.verticalKey = config.verticalKey || null;
	    /**
	     * The base URL used for constructing the URL with params
	     * @type {string}
	     */

	    this.baseUrl = config.url;
	    /**
	     * Determines whether to show this tab first in the order
	     * @type {boolean}
	     */

	    this.isFirst = config.isFirst || false;
	    /**
	     * Determines whether or not to apply a special class to the
	     * markup to determine if it's an active tab
	     * @type {boolean}
	     */

	    this.isActive = config.isActive || false;
	  }
	  /**
	   * from will construct a map of verticalKey to {Tab} from
	   * a configuration file
	   * @param {object} tabsConfig the configuration to use
	   */


	  Tab.from = function from(tabsConfig) {
	    var tabs = {}; // Parse the options and build out our tabs and

	    for (var i = 0; i < tabsConfig.length; i++) {
	      var tab = _objectSpread$6({}, tabsConfig[i]); // If a tab is configured to be hidden in this component,
	      // do not process it


	      if (tab.hideInNavigation) {
	        continue;
	      } // For tabs without config ids, map their URL to the configID
	      // to avoid duplication of renders


	      if (!tab.verticalKey && !tabs[tab.url]) {
	        tab.verticalKey = tab.url;
	      }

	      tabs[tab.verticalKey] = new Tab(tab);
	    }

	    return tabs;
	  };

	  return Tab;
	}();
	/**
	 * NavigationComponent exposes an interface for building a dynamic
	 * navigation that is powered by universal search updates.
	 * @extends Component
	 */

	var NavigationComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(NavigationComponent, _Component);

	  function NavigationComponent(config, systemConfig) {
	    var _context, _context2;

	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    /**
	     * The label to show on the dropdown menu button when overflow
	     * @type {string}
	     */

	    _this.overflowLabel = config.overflowLabel || "More";
	    /**
	     * The optional icon to show on the dropdown menu button when overflow
	     * @type {string}
	     */

	    _this.overflowIcon = config.overflowIcon || 'kabob';
	    /**
	     * The data storage key
	     * @type {string}
	     */

	    _this.moduleId = StorageKeys.NAVIGATION;
	    /**
	     * Tabs config from global navigation config
	     * @type {Array.<object>}
	     * @private
	     */

	    _this._tabsConfig = config.verticalPages || _this.core.storage.get(StorageKeys.VERTICAL_PAGES_CONFIG).get();
	    /**
	     * Unordered map of each tab, keyed by VS verticalKey
	     * @type {Object.<String, Object>}
	     * @private
	     */

	    _this._tabs = Tab.from(_this._tabsConfig);
	    /**
	     * The order of the tabs, parsed from configuration or URL.
	     * This gets updated based on the server results
	     * @type {Array.<String>} The list of VS verticalKeys
	     * @private
	     */

	    _this._tabOrder = getDefaultTabOrder(_this._tabsConfig, getUrlParams(_this.core.storage.getCurrentStateUrlMerged()));
	    /**
	     * Breakpoints at which navigation items move to the "more" dropdown
	     * @type {number[]}
	     * @private
	     */

	    _this._navBreakpoints = [];
	    /**
	     *  The mobile overflow behavior config
	     *  @type {string}
	     */

	    _this._mobileOverflowBehavior = config.mobileOverflowBehavior || MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE;
	    /**
	     *  The ARIA label
	     *  @type {string}
	     */

	    _this._ariaLabel = config.ariaLabel || "Search Page Navigation";
	    _this.checkOutsideClick = bind$2(_context = _this.checkOutsideClick).call(_context, _assertThisInitialized(_this));
	    _this.checkMobileOverflowBehavior = bind$2(_context2 = _this.checkMobileOverflowBehavior).call(_context2, _assertThisInitialized(_this));

	    var reRender = function reRender() {
	      _this.setState(_this.core.storage.get(StorageKeys.NAVIGATION) || {});
	    };

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.API_CONTEXT,
	      callback: reRender
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.SESSIONS_OPT_IN,
	      callback: reRender
	    });

	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  NavigationComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'navigation/navigation';
	  };

	  var _proto = NavigationComponent.prototype;

	  _proto.onCreate = function onCreate() {
	    // TODO: Re-rendering and re-mounting the component every tim e the window changes size
	    // is not great.
	    DOM.on(window, 'resize', this.checkMobileOverflowBehavior);
	  };

	  _proto.onDestroy = function onDestroy() {
	    DOM.off(window, 'resize', this.checkMobileOverflowBehavior);
	  };

	  _proto.onMount = function onMount() {
	    if (this.shouldCollapse()) {
	      var _context3;

	      this._navBreakpoints = [];
	      this.bindOverflowHandlers();
	      this.refitNav();
	      DOM.on(DOM.query(this._container, '.yxt-Nav-more'), 'click', bind$2(_context3 = this.toggleMoreDropdown).call(_context3, this));
	    }
	  };

	  _proto.onUnMount = function onUnMount() {
	    this.unbindOverflowHandlers();
	  };

	  _proto.bindOverflowHandlers = function bindOverflowHandlers() {
	    DOM.on(window, 'click', this.checkOutsideClick);
	  };

	  _proto.unbindOverflowHandlers = function unbindOverflowHandlers() {
	    DOM.off(window, 'click', this.checkOutsideClick);
	  };

	  _proto.refitNav = function refitNav() {
	    var container = DOM.query(this._container, '.yxt-Nav-container');
	    var moreButton = DOM.query(this._container, '.yxt-Nav-more');
	    var mainLinks = DOM.query(this._container, '.yxt-Nav-expanded');
	    var collapsedLinks = DOM.query(this._container, '.yxt-Nav-modal');
	    var navWidth = moreButton.classList.contains('yxt-Nav-item--more') ? container.offsetWidth : container.offsetWidth - moreButton.offsetWidth;
	    var numBreakpoints = this._navBreakpoints.length; // sum child widths instead of using parent's width to avoid
	    // browser inconsistencies

	    var mainLinksWidth = 0;

	    for (var _iterator = _createForOfIteratorHelperLoose$5(mainLinks.children), _step; !(_step = _iterator()).done;) {
	      var el = _step.value;
	      mainLinksWidth += el.offsetWidth;
	    }

	    if (mainLinksWidth > navWidth) {
	      this._navBreakpoints.push(mainLinksWidth);

	      var lastLink = mainLinks.children.item(mainLinks.children.length - 1);

	      if (lastLink === null) {
	        return;
	      }

	      this._prepend(collapsedLinks, lastLink);

	      if (moreButton.classList.contains('yxt-Nav-item--more')) {
	        moreButton.classList.remove('yxt-Nav-item--more');
	      }
	    } else {
	      if (numBreakpoints && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
	        var firstLink = collapsedLinks.children.item(0);

	        if (firstLink === null) {
	          return;
	        }

	        mainLinks.append(firstLink);

	        this._navBreakpoints.pop();

	        numBreakpoints--;
	      }

	      if (collapsedLinks.children.length === 0) {
	        moreButton.classList.add('yxt-Nav-item--more');
	      }
	    }

	    this.closeMoreDropdown();

	    if (mainLinksWidth > navWidth || numBreakpoints > 0 && navWidth > this._navBreakpoints[numBreakpoints - 1]) {
	      this.refitNav();
	    }
	  };

	  _proto.closeMoreDropdown = function closeMoreDropdown() {
	    var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
	    collapsed.classList.remove('is-active');
	    var moreButton = DOM.query(this._container, '.yxt-Nav-more');
	    moreButton.setAttribute('aria-expanded', false);
	  };

	  _proto.openMoreDropdown = function openMoreDropdown() {
	    var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
	    collapsed.classList.add('is-active');
	    var moreButton = DOM.query(this._container, '.yxt-Nav-more');
	    moreButton.setAttribute('aria-expanded', true);
	  };

	  _proto.toggleMoreDropdown = function toggleMoreDropdown() {
	    var collapsed = DOM.query(this._container, '.yxt-Nav-modal');
	    collapsed.classList.toggle('is-active');
	    var moreButton = DOM.query(this._container, '.yxt-Nav-more');
	    moreButton.setAttribute('aria-expanded', collapsed.classList.contains('is-active'));
	  };

	  _proto.checkOutsideClick = function checkOutsideClick(e) {
	    if (this._closest(e.target, '.yxt-Nav-container')) {
	      return;
	    }

	    this.closeMoreDropdown();
	  };

	  _proto.checkMobileOverflowBehavior = function checkMobileOverflowBehavior() {
	    var _context4;

	    if (this._checkMobileOverflowBehaviorTimer) {
	      clearTimeout(this._checkMobileOverflowBehaviorTimer);
	    }

	    this._checkMobileOverflowBehaviorTimer = setTimeout$2(bind$2(_context4 = this.setState).call(_context4, this), RESIZE_DEBOUNCE);
	  }
	  /**
	   * Since the server data only provides a list of
	   * VS verticalKeys, we need to compute and transform
	   * the data into the proper format for rendering.
	   *
	   * @override
	   */
	  ;

	  _proto.setState = function setState(data) {
	    var _this2 = this;

	    if (data === void 0) {
	      data = {};
	    }

	    if (data.tabOrder !== undefined) {
	      this._tabOrder = mergeTabOrder(data.tabOrder, this._tabOrder, this._tabs);
	    }

	    var params = getUrlParams(this.core.storage.getCurrentStateUrlMerged());
	    params.set('tabOrder', this._tabOrder);
	    var context = this.core.storage.get(StorageKeys.API_CONTEXT);

	    if (context) {
	      params.set(StorageKeys.API_CONTEXT, context);
	    }

	    var referrerPageUrl = this.core.storage.get(StorageKeys.REFERRER_PAGE_URL);

	    if (referrerPageUrl !== undefined) {
	      params.set(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	    }

	    var filteredParams = filterParamsForExperienceLink(params, function (types) {
	      return _this2.componentManager.getComponentNamesForComponentTypes(types);
	    }); // Since the tab ordering can change based on the server data
	    // we need to update each tabs URL to include the order as part of their params.
	    // This helps with persisting state across verticals.

	    var tabs = [];

	    for (var i = 0; i < this._tabOrder.length; i++) {
	      var tab = this._tabs[this._tabOrder[i]];

	      if (tab !== undefined) {
	        tab.url = replaceUrlParams(tab.baseUrl, filteredParams);
	        tabs.push(tab);
	      }
	    }

	    return _Component.prototype.setState.call(this, {
	      tabs: tabs,
	      overflowLabel: this.overflowLabel,
	      overflowIcon: this.overflowIcon,
	      showCollapse: this.shouldCollapse(),
	      ariaLabel: this._ariaLabel
	    });
	  } // TODO (agrow) investigate removing this
	  // ParentNode.prepend polyfill
	  // https://developer.mozilla.org/en-US/docs/Web/API/ParentNode/prepend#Polyfill
	  ;

	  _proto._prepend = function _prepend(collapsedLinks, lastLink) {
	    if (!collapsedLinks.hasOwnProperty('prepend')) {
	      // eslint-disable-line no-prototype-builtins
	      var docFrag = document.createDocumentFragment();
	      var isNode = lastLink instanceof Node;
	      docFrag.appendChild(isNode ? lastLink : document.createTextNode(String(lastLink)));
	      collapsedLinks.insertBefore(docFrag, collapsedLinks.firstChild);
	      return;
	    }

	    collapsedLinks.prepend(lastLink);
	  } // TODO (agrow) investigate removing this
	  // Adapted from Element.closest polyfill
	  // https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#Polyfill
	  ;

	  _proto._closest = function _closest(el, closestElSelector) {
	    if (!el.hasOwnProperty('closest')) {
	      // eslint-disable-line no-prototype-builtins
	      do {
	        if (DOM.matches(el, closestElSelector)) return el;
	        el = el.parentElement || el.parentNode;
	      } while (el !== null && el.nodeType === 1);

	      return null;
	    }

	    return el.closest(closestElSelector);
	  };

	  _proto.shouldCollapse = function shouldCollapse() {
	    switch (this._mobileOverflowBehavior) {
	      case MOBILE_OVERFLOW_BEHAVIOR_OPTION.COLLAPSE:
	        return true;

	      case MOBILE_OVERFLOW_BEHAVIOR_OPTION.INNERSCROLL:
	        {
	          var container = DOM.query(this._container, '.yxt-Nav-container') || this._container;

	          var navWidth = container.offsetWidth;
	          return navWidth > MOBILE_BREAKPOINT;
	        }
	    }
	  };

	  _createClass(NavigationComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'Navigation';
	    }
	  }]);

	  return NavigationComponent;
	}(Component);

	/**
	 * SearchOptionsFactory is responsible for determining what search options to use
	 * for a given QUERY_TRIGGER.
	 */

	var SearchOptionsFactory = /*#__PURE__*/function () {
	  function SearchOptionsFactory() {}

	  var _proto = SearchOptionsFactory.prototype;

	  /**
	   * Given a QUERY_TRIGGER, return the search options for the given trigger.
	   *
	   * @returns {Object}
	   */
	  _proto.create = function create(queryTrigger) {
	    switch (queryTrigger) {
	      case QueryTriggers.FILTER_COMPONENT:
	        return {
	          setQueryParams: true,
	          resetPagination: true,
	          useFacets: true
	        };

	      case QueryTriggers.PAGINATION:
	        return {
	          setQueryParams: true,
	          resetPagination: false,
	          useFacets: true,
	          sendQueryId: true
	        };

	      case QueryTriggers.QUERY_PARAMETER:
	      case QueryTriggers.INITIALIZE:
	        return {
	          setQueryParams: true,
	          resetPagination: false,
	          useFacets: true
	        };

	      case QueryTriggers.SUGGEST:
	        return {
	          setQueryParams: true,
	          resetPagination: true,
	          useFacets: true
	        };

	      default:
	        return {
	          setQueryParams: true,
	          resetPagination: true
	        };
	    }
	  };

	  return SearchOptionsFactory;
	}();

	function ownKeys$8(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$8(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$8(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * QueryUpdateListener is responsible for running a vertical or universal search when
	 * the QUERY storage key is updated.
	 */

	var QueryUpdateListener = /*#__PURE__*/function () {
	  function QueryUpdateListener(core, config) {
	    var _this = this;

	    this.core = core;
	    this.config = _objectSpread$7({
	      searchCooldown: 300,
	      verticalKey: undefined,
	      allowEmptySearch: true,
	      defaultInitialSearch: undefined
	    }, config);
	    /**
	     * Middleware functions to be run before a search. Can be either async or sync.
	     */

	    this.middleware = [];
	    this.searchOptionsFactory = new SearchOptionsFactory();
	    this.core.storage.registerListener({
	      storageKey: StorageKeys.QUERY,
	      eventType: 'update',
	      callback: function callback(query) {
	        return _this._handleQueryUpdate(query);
	      }
	    });
	  }
	  /**
	   * Register a middleware, to be called before searches are run.
	   * Middleware must return a Promise if they are async.
	   *
	   * @param {Function} middlewareFunction
	   */


	  var _proto = QueryUpdateListener.prototype;

	  _proto.registerMiddleware = function registerMiddleware(middlewareFunction) {
	    this.middleware.push(middlewareFunction);
	  }
	  /**
	   * Runs a debounced search. If the query is null, set the query to the defaultInitialSearch,
	   * which retriggers the QUERY listener.
	   *
	   * @param {string} query
	   */
	  ;

	  _proto._handleQueryUpdate = function _handleQueryUpdate(query) {
	    if (query === null) {
	      if (this.config.defaultInitialSearch || this.config.defaultInitialSearch === '') {
	        this.core.storage.set(StorageKeys.QUERY_TRIGGER, QueryTriggers.INITIALIZE);
	        this.core.storage.set(StorageKeys.QUERY, this.config.defaultInitialSearch);
	      }

	      return;
	    }

	    this._debouncedSearch(query);
	  };

	  _proto._debouncedSearch = function _debouncedSearch(query) {
	    var _this2 = this;

	    if (this._throttled || !query && !this.config.allowEmptySearch && this.core.storage.get(StorageKeys.QUERY_TRIGGER) !== QueryTriggers.FILTER_COMPONENT) {
	      return;
	    }

	    this._setSearchLoadingState();

	    this._throttled = true;

	    setTimeout$2(function () {
	      _this2._throttled = false;
	    }, this._searchCooldown);

	    return this._search(query);
	  };

	  _proto._setSearchLoadingState = function _setSearchLoadingState() {
	    this.config.verticalKey ? this.core.storage.set(StorageKeys.VERTICAL_RESULTS, VerticalResults.searchLoading()) : this.core.storage.set(StorageKeys.UNIVERSAL_RESULTS, UniversalResults.searchLoading());
	  };

	  _proto._search = function _search(query) {
	    var _context,
	        _this3 = this;

	    var middlewarePromises = map$2(_context = this.middleware).call(_context, function (middleware) {
	      return middleware(query);
	    });

	    var queryTrigger = this.core.storage.get(StorageKeys.QUERY_TRIGGER);
	    return promise$3.all(middlewarePromises).then(function () {
	      if (_this3.config.verticalKey) {
	        return _this3.core.verticalSearch(_this3.config.verticalKey, _this3.searchOptionsFactory.create(queryTrigger), {
	          input: query
	        });
	      } else {
	        return _this3.core.search(query, _this3.searchOptionsFactory.create(queryTrigger));
	      }
	    });
	  };

	  return QueryUpdateListener;
	}();

	function ownKeys$9(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$9(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$9(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var IconState = {
	  YEXT: 0,
	  MAGNIFYING_GLASS: 1
	};
	/**
	 * SearchComponent exposes an interface in order to create
	 * a UI Search experience for vertical and universal search.
	 *
	 * @extends Component
	 */

	var SearchComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(SearchComponent, _Component);

	  function SearchComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    /**
	     * The optional vertical key for vertical search configuration
	     * If not provided, auto-complete and search will be based on universal
	     * @type {string}
	     */

	    _this._verticalKey = config.verticalKey || null;
	    /**
	     * Query submission can optionally be based on a form as context. Note that if
	     * a form is not used, the component has no guarantee of WCAG compliance.
	     */

	    _this._useForm = config.useForm !== undefined ? config.useForm : true;
	    /**
	     * Query submission is based on a form as context.
	     * Optionally provided, otherwise defaults to native form node within container
	     * @type {string} CSS selector
	     */

	    _this._formEl = config.formSelector || 'form';
	    /**
	     * The input element used for searching and wires up the keyboard interaction
	     * Optionally provided.
	     * @type {string} CSS selector
	     */

	    _this._inputEl = config.inputEl || '.js-yext-query';
	    /**
	     * The title used, provided to the template as a data point
	     * Optionally provided. If not provided, no title will be included.
	     * @type {string}
	     */

	    _this.title = config.title;
	    /**
	     * The label text is used for labeling the input box, also provided to template.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.labelText = config.labelText || "Conduct a search";
	    /**
	     * The submit text is used for labeling the submit button, also provided to the template.
	     * @type {string}
	     */

	    _this.submitText = config.submitText || "Submit";
	    /**
	     * The clear text is used for labeling the clear button, also provided to the template.
	     * @type {string}
	     */

	    _this.clearText = config.clearText || "Clear";
	    /**
	     * The submit icon is an icon for the submit button, if provided it will be displayed and the
	     * submit text will be used for screen readers.
	     * @type {string|null}
	     */

	    _this.submitIcon = config.submitIcon || null;
	    /**
	     * The query text to show as the first item for auto complete.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.promptHeader = config.promptHeader || null;
	    /**
	     * Auto focuses the input box if set to true.
	     * Optionally provided, defaults to false.
	     * @type {boolean}
	     */

	    _this.autoFocus = config.autoFocus === true;
	    /**
	     * If true, show an "x" that allows the user to clear the current
	     * query
	     * @type {boolean}
	     */

	    _this.clearButton = config.clearButton === undefined ? true : config.clearButton;
	    /**
	     * When autofocusing on load, optionally open the autocomplete
	     * (preset prompts)
	     * @type {boolean}
	     */

	    _this.autocompleteOnLoad = config.autocompleteOnLoad || false;
	    /**
	     * submitURL will force the search query submission to get
	     * redirected to the URL provided.
	     * Optional, defaults to null.
	     *
	     * If no redirectUrl provided, we keep the page as a single page app.
	     *
	     * @type {string}
	     */

	    _this.redirectUrl = config.redirectUrl || null;
	    /**
	     * redirectUrlTarget will force the search query submission to open in the frame specified if
	     * redirectUrl is also supplied.
	     * Optional, defaults to current frame.
	     *
	     * @type {string}
	     */

	    _this.redirectUrlTarget = config.redirectUrlTarget || '_self';
	    /**
	     * true if there is another search bar present on the page.
	     * Twins only update the query, and do not search
	     */

	    _this._isTwin = config.isTwin;
	    /**
	     * The search config from ANSWERS.init configuration
	     */

	    _this._globalSearchConfig = _this.core.storage.get(StorageKeys.SEARCH_CONFIG) || {};
	    /**
	     * The default initial search query, can be an empty string
	     */

	    _this._defaultInitialSearch = _this._globalSearchConfig.defaultInitialSearch;
	    /**
	     * The query string to use for the input box, provided to template for rendering.
	     * Optionally provided
	     * @type {string|null}
	     */

	    _this.query = config.query || _this.core.storage.get(StorageKeys.QUERY);

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.QUERY,
	      callback: function callback(q) {
	        _this.query = q;

	        if (_this.queryEl) {
	          _this.queryEl.value = q;
	        }

	        if (q === null) {
	          return;
	        }

	        _this._updateClearButtonVisibility(q);
	      }
	    });
	    /**
	     * The minimum time allowed in milliseconds between searches to prevent
	     * many duplicate searches back-to-back
	     * @type {number}
	     * @private
	     */


	    _this._searchCooldown = config.searchCooldown || 300;
	    /**
	     * When true and "near me" intent is expressed, prompt the user for their geolocation
	     * @type {boolean}
	     * @private
	     */

	    _this._promptForLocation = config.promptForLocation === undefined ? true : Boolean(config.promptForLocation);
	    /**
	     * Controls showing and hiding the search clear button
	     */

	    _this._showClearButton = _this.clearButton && _this.query;
	    /**
	     * Whether or not to allow empty searches.
	     * @type {boolean}
	     * @private
	     */

	    _this._allowEmptySearch = !!config.allowEmptySearch;
	    /**
	     * The name of the child AutoComplete component.
	     * @type {string}
	     * @private
	     */

	    _this._autoCompleteName = _this.name + ".autocomplete";
	    /**
	     * Options to pass to the geolocation api.
	     * @type {Object}
	     */

	    _this._geolocationOptions = _objectSpread$8({
	      enableHighAccuracy: false,
	      timeout: 1000,
	      maximumAge: 300000
	    }, config.geolocationOptions);
	    /**
	     * Options for the geolocation timeout alert.
	     * @type {Object}
	     */

	    _this._geolocationTimeoutAlert = _objectSpread$8({
	      enabled: false,
	      message: "We are unable to determine your location"
	    }, config.geolocationTimeoutAlert);
	    /**
	     * The unique HTML id name for the autocomplete container
	     * @type {string}
	     */

	    _this.autocompleteContainerIdName = "yxt-SearchBar-autocomplete--" + _this.name;
	    /**
	     * The unique HTML id name for the search input label
	     * @type {string}
	     */

	    _this.inputLabelIdName = "yxt-SearchBar-inputLabel--" + _this.name;
	    /**
	     * The unique HTML id name for the search input
	     * @type {string}
	     */

	    _this.inputIdName = "yxt-SearchBar-input--" + _this.name;
	    _this.customHooks = {
	      /**
	       * Callback invoked when the clear search button is clicked
	       */
	      onClearSearch: config.customHooks && config.customHooks.onClearSearch || function () {},

	      /**
	       * Callback invoked when a search is conducted
	       */
	      onConductSearch: config.customHooks && config.customHooks.onConductSearch || function () {}
	    };
	    /**
	     * Options to pass to the autocomplete component
	     * @type {Object}
	     */

	    _this._autocompleteConfig = {
	      shouldHideOnEmptySearch: config.autocomplete && config.autocomplete.shouldHideOnEmptySearch,
	      onOpen: config.autocomplete && config.autocomplete.onOpen,
	      onClose: config.autocomplete && config.autocomplete.onClose
	    };

	    if (!_this._isTwin) {
	      _this.initQueryUpdateListener();
	    }

	    return _this;
	  }
	  /**
	   * Updates the global search listener with the searchbar's config.
	   */


	  var _proto = SearchComponent.prototype;

	  _proto.initQueryUpdateListener = function initQueryUpdateListener() {
	    var _this2 = this;

	    var queryUpdateListener = new QueryUpdateListener(this.core, {
	      searchCooldown: this._searchCooldown,
	      verticalKey: this._verticalKey,
	      allowEmptySearch: this._allowEmptySearch,
	      defaultInitialSearch: this._defaultInitialSearch
	    });
	    this.core.setQueryUpdateListener(queryUpdateListener);
	    this.core.queryUpdateListener.registerMiddleware(function (query) {
	      return _this2.promptForLocation(query);
	    });
	    this.core.queryUpdateListener.registerMiddleware(function (query) {
	      return _this2.customHooks.onConductSearch(query);
	    });
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  SearchComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'search/search';
	  }
	  /**
	   * This method is called by answers-umd AFTER the onReady() is finished, and
	   * all components have been mounted.
	   */
	  ;

	  _proto.searchAfterAnswersOnReady = function searchAfterAnswersOnReady() {
	    if (this.query != null && !this.redirectUrl) {
	      this.core.setQuery(this.query);
	    }
	  };

	  _proto.onMount = function onMount() {
	    this.queryEl = DOM.query(this._container, this._inputEl);

	    if (this.autoFocus && !this.query && !this.autocompleteOnLoad) {
	      this.focusInputElement();
	    }

	    this.isUsingYextAnimatedIcon = !this._config.customIconUrl && !this.submitIcon;

	    if (this.isUsingYextAnimatedIcon) {
	      this.initAnimatedIcon();
	    } // Wire up our search handling and auto complete


	    this.initSearch(this._formEl);
	    this.initAutoComplete(this._inputEl);

	    if (this.clearButton) {
	      this.initClearButton();
	    }

	    if (this.autoFocus && !this.query && this.autocompleteOnLoad) {
	      this.focusInputElement();
	    }
	  };

	  _proto.requestIconAnimationFrame = function requestIconAnimationFrame(iconState) {
	    var _this3 = this;

	    if (this.iconState === iconState) {
	      return;
	    }

	    this.iconState = iconState;

	    if (!this.isRequestingAnimationFrame) {
	      this.isRequestingAnimationFrame = true;
	      window.requestAnimationFrame(function () {
	        _this3.forwardIcon.classList.remove('yxt-SearchBar-AnimatedIcon--paused');

	        _this3.reverseIcon.classList.remove('yxt-SearchBar-AnimatedIcon--paused');

	        if (_this3.iconState === IconState.MAGNIFYING_GLASS) {
	          _this3.forwardIcon.classList.remove('yxt-SearchBar-AnimatedIcon--inactive');

	          _this3.reverseIcon.classList.add('yxt-SearchBar-AnimatedIcon--inactive');
	        } else if (_this3.iconState === IconState.YEXT) {
	          _this3.forwardIcon.classList.add('yxt-SearchBar-AnimatedIcon--inactive');

	          _this3.reverseIcon.classList.remove('yxt-SearchBar-AnimatedIcon--inactive');
	        }

	        _this3.isRequestingAnimationFrame = false;
	      });
	    }
	  };

	  _proto.animateIconToMagnifyingGlass = function animateIconToMagnifyingGlass() {
	    if (this.iconIsFrozen) {
	      return;
	    }

	    this.requestIconAnimationFrame(IconState.MAGNIFYING_GLASS);
	  };

	  _proto.animateIconToYext = function animateIconToYext(e) {
	    var focusStillInSearchbar = false;

	    if (e && e.relatedTarget) {
	      focusStillInSearchbar = this._container.contains(e.relatedTarget);
	    }

	    if (this.iconIsFrozen || focusStillInSearchbar) {
	      return;
	    }

	    this.requestIconAnimationFrame(IconState.YEXT);
	  };

	  _proto.initAnimatedIcon = function initAnimatedIcon() {
	    var _this4 = this;

	    this.iconState = this.autoFocus && !this.query ? IconState.MAGNIFYING_GLASS : IconState.YEXT;
	    this.forwardIcon = DOM.query(this._container, '.js-yxt-AnimatedForward');
	    this.reverseIcon = DOM.query(this._container, '.js-yxt-AnimatedReverse');
	    var clickableElementSelectors = ['.js-yext-submit', '.js-yxt-SearchBar-clear'];

	    for (var _i = 0, _clickableElementSele = clickableElementSelectors; _i < _clickableElementSele.length; _i++) {
	      var selector = _clickableElementSele[_i];
	      var clickableEl = DOM.query(this._container, selector);

	      if (clickableEl) {
	        DOM.on(clickableEl, 'mousedown', function () {
	          _this4.iconIsFrozen = true;
	        });
	        DOM.on(clickableEl, 'mouseup', function () {
	          _this4.iconIsFrozen = false;
	        });
	      }
	    }

	    DOM.on(this.queryEl, 'focus', function () {
	      _this4.animateIconToMagnifyingGlass();
	    });
	    DOM.on(this._container, 'focusout', function (e) {
	      _this4.animateIconToYext(e);
	    });
	  };

	  _proto.remove = function remove() {
	    this._autocomplete.remove();

	    _Component.prototype.remove.call(this);
	  };

	  _proto.initClearButton = function initClearButton() {
	    var _this5 = this;

	    var button = this._getClearButton();

	    this._showClearButton = this._showClearButton || this.query;

	    if (this._showClearButton) {
	      button.classList.remove('yxt-SearchBar--hidden');
	    } else {
	      button.classList.add('yxt-SearchBar--hidden');
	    }

	    DOM.on(button, 'click', function () {
	      _this5.customHooks.onClearSearch();

	      _this5.query = '';
	      _this5._showClearButton = false;
	      button.classList.add('yxt-SearchBar--hidden');
	      _this5.queryEl.value = _this5.query;

	      _this5.core.storage["delete"](StorageKeys.SEARCH_OFFSET);

	      _this5.core.triggerSearch(QueryTriggers.SEARCH_BAR, _this5.query); // Focus the input element after clearing the query, regardless of whether
	      // or not the autoFocus option is enabled.
	      // NOTE(amullings): This depends heavily on the fact that the re-renders
	      // triggered by setState and core.setQuery happen synchronously; if this
	      // stops being the case at some point, we'll need an alternative solution


	      _this5.focusInputElement();
	    });
	    DOM.on(this.queryEl, 'input', function (e) {
	      var input = e.target.value;
	      _this5.query = input;

	      _this5._updateClearButtonVisibility(input);
	    });
	  }
	  /**
	   * Registers the different event handlers that can issue a search. Note that
	   * different handlers are used depending on whether or not a form is used as
	   * context.
	   *
	   * @param {string} formSelector CSS selector to bind our form submit handling to
	   */
	  ;

	  _proto.initSearch = function initSearch(formSelector) {
	    var _this6 = this;

	    this._formEl = formSelector;

	    this._container.classList.add('yxt-SearchBar-wrapper');

	    if (this._useForm) {
	      var form = DOM.query(this._container, formSelector);

	      if (!form) {
	        throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._formEl, '`.');
	      }

	      DOM.on(form, 'submit', function (e) {
	        e.preventDefault(); // TODO(oshi) we should not use the same css selector (this._inputEl)
	        // For both the autocomplete AND the search bar input
	        // This is incredibly confusing, and also makes the first DOM.query
	        // Rely on the order of the input el and autocomplete in the template

	        var inputEl = form.querySelector(_this6._inputEl);

	        _this6.onQuerySubmit(inputEl);
	      });
	    } else {
	      var inputEl = DOM.query(this._container, this._inputEl);

	      if (!inputEl) {
	        throw new Error('Could not initialize SearchBar; Can not find {HTMLElement} `', this._inputEl, '`.');
	      }

	      DOM.on(inputEl, 'keydown', function (e) {
	        if (e.key === 'Enter') {
	          e.preventDefault();

	          _this6.onQuerySubmit(inputEl);
	        }
	      });
	      var submitButton = DOM.query(this._container, '.js-yext-submit');
	      DOM.on(submitButton, 'click', function (e) {
	        e.preventDefault();

	        _this6.onQuerySubmit(inputEl);
	      });
	    }
	  }
	  /**
	   * The handler for a query submission. This method first sets the new query in
	   * persistent and storage, than performs a debounced search.
	   *
	   * @param {Node} inputEl The input element containing the query.
	   */
	  ;

	  _proto.onQuerySubmit = function onQuerySubmit(inputEl) {
	    var query = inputEl.value;
	    this.query = query;
	    var params = new SearchParams(this.core.storage.getCurrentStateUrlMerged());
	    params.set('query', query);
	    var context = this.core.storage.get(StorageKeys.API_CONTEXT);

	    if (context) {
	      params.set(StorageKeys.API_CONTEXT, context);
	    } // If we have a redirectUrl, we want the form to be
	    // serialized and submitted.


	    if (typeof this.redirectUrl === 'string') {
	      if (this._allowEmptySearch || query) {
	        // Fix issue with url construction not honoring existing query parameters
	        // var newUrl = this.redirectUrl + '?' + params.toString();
	        var newUrl = urlutils.addParamsToURL(this.redirectUrl, Object.fromEntries(params));
	        window.open(newUrl, this.redirectUrlTarget) || (window.location.href = newUrl);
	        return false;
	      }
	    }

	    inputEl.blur();
	    DOM.query(this._container, '.js-yext-submit').blur();

	    if (this.isUsingYextAnimatedIcon) {
	      this.animateIconToYext();
	    }

	    this.core.storage["delete"](StorageKeys.SEARCH_OFFSET);
	    this.core.triggerSearch(QueryTriggers.SEARCH_BAR, query);
	    return false;
	  }
	  /**
	   * A helper method to wire up our auto complete on an input selector
	   * @param {string} inputSelector CSS selector to bind our auto complete component to
	   */
	  ;

	  _proto.initAutoComplete = function initAutoComplete(inputSelector) {
	    var _this7 = this;

	    this._inputEl = inputSelector;

	    if (this._autocomplete) {
	      this._autocomplete.remove();
	    }

	    this._autocomplete = this.componentManager.create('AutoComplete', _objectSpread$8(_objectSpread$8({
	      parentContainer: this._container,
	      name: this._autoCompleteName,
	      container: '.yxt-SearchBar-autocomplete',
	      autoFocus: this.autoFocus && !this.autocompleteOnLoad,
	      verticalKey: this._verticalKey,
	      promptHeader: this.promptHeader,
	      originalQuery: this.query,
	      inputEl: inputSelector,
	      listLabelIdName: this.inputLabelIdName
	    }, this._autocompleteConfig), {}, {
	      onSubmit: function onSubmit() {
	        if (_this7._useForm) {
	          DOM.trigger(DOM.query(_this7._container, _this7._formEl), 'submit');
	        } else {
	          var inputEl = DOM.query(_this7._container, inputSelector);

	          _this7.onQuerySubmit(inputEl);
	        }
	      },
	      onChange: function onChange() {
	        DOM.trigger(DOM.query(_this7._container, inputSelector), 'input');
	      }
	    }));

	    this._autocomplete.mount();
	  }
	  /**
	   * If _promptForLocation is enabled, we will compute the query's intent and, from there,
	   * determine if it's necessary to prompt the user for their location information. It will
	   * be unnecessary if the query does not have near me intent or we already have their location
	   * stored.
	   * @param {string} query The string to query against.
	   * @returns {Promise} A promise that will perform the query and update storage accordingly.
	   */
	  ;

	  _proto.promptForLocation = function promptForLocation(query) {
	    var _this8 = this;

	    if (this._promptForLocation) {
	      return this.fetchQueryIntents(query).then(function (queryIntents) {
	        return includes$4(queryIntents).call(queryIntents, 'NEAR_ME');
	      }).then(function (queryHasNearMeIntent) {
	        if (queryHasNearMeIntent && !_this8.core.storage.get(StorageKeys.GEOLOCATION)) {
	          return new promise$3(function (resolve, reject) {
	            return navigator.geolocation.getCurrentPosition(function (position) {
	              _this8.core.storage.set(StorageKeys.GEOLOCATION, {
	                lat: position.coords.latitude,
	                lng: position.coords.longitude,
	                radius: position.coords.accuracy
	              });

	              resolve();
	            }, function () {
	              resolve();
	              var _this8$_geolocationTi = _this8._geolocationTimeoutAlert,
	                  enabled = _this8$_geolocationTi.enabled,
	                  message = _this8$_geolocationTi.message;

	              if (enabled) {
	                window.alert(message);
	              }
	            }, _this8._geolocationOptions);
	          });
	        }
	      });
	    } else {
	      return promise$3.resolve();
	    }
	  }
	  /**
	   * A helper method that computes the intents of the provided query. If the query was entered
	   * manually into the search bar or selected via autocomplete, its intents will have been stored
	   * already in storage. Otherwise, a new API call will have to be issued to determine
	   * intent.
	   * @param {string} query The query whose intent is needed.
	   * @returns {Promise} A promise containing the intents of the query.
	   */
	  ;

	  _proto.fetchQueryIntents = function fetchQueryIntents(query) {
	    var autocompleteData = this.core.storage.get(StorageKeys.AUTOCOMPLETE + "." + this._autoCompleteName);

	    if (!autocompleteData) {
	      var autocompleteRequest = this._verticalKey ? this.core.autoCompleteVertical(query, this._autoCompleteName, this._verticalKey) : this.core.autoCompleteUniversal(query, this._autoCompleteName);
	      return autocompleteRequest.then(function (data) {
	        return data.inputIntents;
	      });
	    } else {
	      var _context;

	      // There are two alternatives to consider here. The user could have selected the query
	      // as an autocomplete option or manually input it themselves. If the former, use the intents
	      // of the corresponding autocomplete option. If the latter, use the inputIntents of the
	      // autocompleteData.
	      var results = flatMap$2(_context = autocompleteData.sections).call(_context, function (section) {
	        return section.results;
	      });

	      var matchingResult = find$3(results).call(results, function (result) {
	        return result.value === query;
	      });

	      var queryIntents = matchingResult ? matchingResult.intents : autocompleteData.inputIntents;
	      return promise$3.resolve(queryIntents);
	    }
	  }
	  /**
	   * A helper method that constructs the meta information needed by the SEARCH_CLEAR_BUTTON
	   * analytics event.
	   */
	  ;

	  _proto.eventOptions = function eventOptions() {
	    var queryId = this.core.storage.get(StorageKeys.QUERY_ID);

	    var options = _extends({}, queryId && {
	      queryId: queryId
	    }, this._verticalKey && {
	      verticalKey: this._verticalKey
	    });

	    return stringify$2(options);
	  };

	  _proto.setState = function setState(data) {
	    var forwardIconOpts = {
	      iconName: 'yext_animated_forward',
	      classNames: 'Icon--lg',
	      complexContentsParams: {
	        iconPrefix: this.name
	      }
	    };
	    var reverseIconOpts = {
	      iconName: 'yext_animated_reverse',
	      classNames: 'Icon--lg',
	      complexContentsParams: {
	        iconPrefix: this.name
	      }
	    };
	    return _Component.prototype.setState.call(this, _extends({
	      title: this.title,
	      inputIdName: this.inputIdName,
	      labelText: this.labelText,
	      inputLabelIdName: this.inputLabelIdName,
	      submitIcon: this.submitIcon,
	      submitText: this.submitText,
	      clearText: this.clearText,
	      showClearButton: this._showClearButton,
	      query: this.query || '',
	      eventOptions: this.eventOptions(),
	      iconId: this.name,
	      forwardIconOpts: forwardIconOpts,
	      reverseIconOpts: reverseIconOpts,
	      autoFocus: this.autoFocus && !this.query,
	      useForm: this._useForm,
	      autocompleteContainerIdName: this.autocompleteContainerIdName
	    }, data));
	  };

	  _proto.focusInputElement = function focusInputElement() {
	    DOM.query(this._container, this._inputEl).focus();
	  }
	  /**
	   * Returns the clear button element, if exists
	   *
	   * @returns {Element}
	   */
	  ;

	  _proto._getClearButton = function _getClearButton() {
	    return DOM.query(this._container, '.js-yxt-SearchBar-clear');
	  }
	  /**
	   * Updates the Search inputs clear button based on the current input value
	   *
	   * @param {string} input
	   */
	  ;

	  _proto._updateClearButtonVisibility = function _updateClearButtonVisibility(input) {
	    var clearButton = this._getClearButton();

	    if (!this._showClearButton && input.length > 0) {
	      this._showClearButton = true;
	      clearButton.classList.remove('yxt-SearchBar--hidden');
	    } else if (this._showClearButton && input.length === 0) {
	      this._showClearButton = false;
	      clearButton.classList.add('yxt-SearchBar--hidden');
	    }
	  };

	  _createClass(SearchComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'SearchBar';
	    }
	  }]);

	  return SearchComponent;
	}(Component);

	function ownKeys$a(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$a(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$a(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	/** @module SearchParamsParser */
	function buildSearchParameters(searchParameterConfigs) {
	  var searchParameters = {
	    sectioned: false,
	    fields: []
	  };

	  if (searchParameterConfigs === undefined) {
	    return searchParameters;
	  }

	  if (searchParameterConfigs.sectioned) {
	    searchParameters.sectioned = searchParameterConfigs.sectioned;
	  }

	  searchParameters.fields = buildFields(searchParameterConfigs.fields);
	  return searchParameters;
	}

	function buildFields(fieldConfigs) {
	  if (fieldConfigs === undefined) {
	    return [];
	  }

	  return map$2(fieldConfigs).call(fieldConfigs, function (fc) {
	    return _objectSpread$9({
	      fetchEntities: false
	    }, fc);
	  });
	}

	/**
	 * FilterSearchComponent is used for autocomplete using the FilterSearch backend.
	 * It'll allow you to pick pre-set filters that are setup on the backend within
	 * a vertical search context.
	 *
	 * @extends Component
	 */

	var FilterSearchComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(FilterSearchComponent, _Component);

	  function FilterSearchComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    /**
	     * The vertical key for vertical search configuration
	     * @type {string}
	     */

	    _this._verticalKey = config.verticalKey || null;
	    /**
	     * If true, store the filter value but do not search on change
	     * @type {boolean}
	     * @private
	     */

	    _this._storeOnChange = config.storeOnChange || false;
	    /**
	     * Query submission is based on a form as context.
	     * Optionally provided, otherwise defaults to native form node within container
	     * @type {string} CSS selector
	     */

	    _this._formEl = config.formSelector || 'form';
	    /**
	     * The input element used for searching and wires up the keyboard interaction
	     * Optionally provided.
	     * @type {string} CSS selector
	     */

	    _this._inputEl = config.inputEl || '.js-yext-query';
	    /**
	     * The title used, provided to the template as a data point
	     * Optionally provided.
	     * @type {string}
	     */

	    _this.title = config.title;
	    /**
	     * The search text used for labeling the input box, also provided to template.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.searchText = config.searchText || "What are you interested in?";
	    /**
	     * The query text to show as the first item for auto complete.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.promptHeader = config.promptHeader || null;
	    /**
	     * Auto focuses the input box if set to true.
	     * Optionally provided, defaults to false.
	     * @type {boolean}
	     */

	    _this.autoFocus = config.autoFocus === true;
	    /**
	     * submitURL will force the search query submission to get
	     * redirected to the URL provided.
	     * Optional, defaults to null.
	     *
	     * If no redirectUrl provided, we keep the page as a single page app.
	     *
	     * @type {boolean}
	     */

	    _this.redirectUrl = config.redirectUrl || null;
	    /**
	     * The query string to use for the input box, provided to template for rendering.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.query = config.query || _this.core.storage.get(StorageKeys.QUERY + "." + _this.name) || '';

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.HISTORY_POP_STATE,
	      callback: function callback(data) {
	        var query = data.get(StorageKeys.QUERY + "." + _this.name) || '';
	        var filter = data.get(StorageKeys.FILTER + "." + _this.name);

	        if (filter && query) {
	          _this.query = query;
	          _this.filter = JSON.parse(filter);

	          _this._saveFilterNodeToStorage();
	        } else {
	          _this._removeFilterNode();
	        }

	        _this.setState();
	      }
	    });
	    /**
	     * The filter string to use for the provided query
	     * Optionally provided
	     * @type {string}
	     */


	    _this.filter = filter$2(config) || _this.core.storage.get(StorageKeys.FILTER + "." + _this.name);

	    if (typeof filter$2(_this) === 'string') {
	      try {
	        _this.filter = JSON.parse(filter$2(_this));
	      } catch (e) {}
	    }

	    if (_this.query && filter$2(_this)) {
	      _this._saveFilterNodeToStorage();
	    }

	    _this.searchParameters = buildSearchParameters(config.searchParameters);
	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  FilterSearchComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'search/filtersearch';
	  };

	  var _proto = FilterSearchComponent.prototype;

	  _proto.onMount = function onMount() {
	    if (this.autoCompleteComponent) {
	      this.autoCompleteComponent.remove();
	    } // Wire up our search handling and auto complete


	    this.initAutoComplete(this._inputEl);

	    if (this.autoFocus === true && this.query.length === 0) {
	      DOM.query(this._container, this._inputEl).focus();
	    }
	  };

	  _proto._saveFilterNodeToStorage = function _saveFilterNodeToStorage() {
	    var filterNode = this._buildFilterNode(this.query, filter$2(this));

	    this.core.setStaticFilterNodes(this.name, filterNode);
	  };

	  _proto._removeFilterNode = function _removeFilterNode() {
	    this.query = '';
	    this.core.storage.setWithPersist(StorageKeys.QUERY + "." + this.name, this.query);
	    this.core.clearStaticFilterNode(this.name);
	    this.setState();
	  };

	  _proto._buildFilterNode = function _buildFilterNode(query, filter) {
	    var _this2 = this;

	    return FilterNodeFactory.from({
	      filter: filter,
	      metadata: {
	        fieldName: this.title,
	        displayValue: "" + query
	      },
	      remove: function remove() {
	        return _this2._removeFilterNode();
	      }
	    });
	  }
	  /**
	   * A helper method to wire up our auto complete on an input selector
	   * @param {string} inputSelector CSS selector to bind our auto complete component to
	   */
	  ;

	  _proto.initAutoComplete = function initAutoComplete(inputSelector) {
	    var _this3 = this;

	    this._inputEl = inputSelector;
	    this.autoCompleteComponent = this.componentManager.create('AutoComplete', {
	      parentContainer: this._container,
	      name: this.name + ".autocomplete",
	      isFilterSearch: true,
	      container: '.yxt-SearchBar-autocomplete',
	      promptHeader: this.promptHeader,
	      originalQuery: this.query,
	      inputEl: inputSelector,
	      verticalKey: this._verticalKey,
	      searchParameters: this.searchParameters,
	      onSubmit: function onSubmit(query, filter) {
	        _this3.filter = Filter.fromResponse(filter);

	        var filterNode = _this3._buildFilterNode(query, filter$2(_this3));

	        var params = new SearchParams(_this3.core.storage.getCurrentStateUrlMerged());
	        params.set(_this3.name + ".query", query);
	        params.set(_this3.name + ".filter", filter); // If we have a redirectUrl, we want the params to be
	        // serialized and submitted.

	        if (typeof _this3.redirectUrl === 'string') {
	          window.location.href = _this3.redirectUrl + '?' + params.toString();
	          return false;
	        } // save the filter to storage for the next search


	        _this3.query = query;

	        _this3.core.storage.setWithPersist(StorageKeys.QUERY + "." + _this3.name, _this3.query);

	        _this3.core.storage.setWithPersist(StorageKeys.FILTER + "." + _this3.name, filterNode.getFilter());

	        _this3.core.setStaticFilterNodes(_this3.name, filterNode);

	        _this3.search(QueryTriggers.FILTER_COMPONENT);
	      }
	    });
	  }
	  /**
	   * Perform the vertical search with all saved filters and query,
	   * optionally redirecting based on config. Uses window.setTimeout to allow
	   * other filters to finish rendering before searching.
	   */
	  ;

	  _proto.search = function search(queryTrigger) {
	    if (this._storeOnChange) {
	      return;
	    }

	    this.core.triggerSearch(queryTrigger);
	  };

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _extends({
	      title: this.title,
	      searchText: this.searchText,
	      query: this.query
	    }, data));
	  };

	  _createClass(FilterSearchComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.FILTER_SEARCH;
	    }
	  }]);

	  return FilterSearchComponent;
	}(Component);

	var Keys = {
	  BACKSPACE: 8,
	  TAB: 9,
	  ENTER: 13,
	  SHIFT: 16,
	  CTRL: 17,
	  ALT: 18,
	  ESCAPE: 27,
	  LEFT: 37,
	  RIGHT: 39,
	  UP: 38,
	  DELETE: 46,
	  DOWN: 40,
	  LEFT_OS_KEY: 91,
	  RIGHT_OS_KEY: 92,
	  SELECT_KEY: 93
	};

	var AutoCompleteComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(AutoCompleteComponent, _Component);

	  function AutoCompleteComponent(opts, systemOpts) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    if (systemOpts === void 0) {
	      systemOpts = {};
	    }

	    _this = _Component.call(this, opts, systemOpts) || this;
	    /**
	     * Whether autocomplete is simple or filter
	     * @type {boolean}
	     */

	    _this.isFilterSearch = opts.isFilterSearch || false;
	    /**
	     * The `verticalKey` of the vertical search to use for auto-complete
	     * @type {string}
	     */

	    _this._verticalKey = opts.verticalKey || null;
	    /**
	     * A reference to the input el selector for auto complete
	     * @type {string}
	     */

	    _this._inputEl = opts.inputEl || '.js-yext-query';
	    /**
	     * A selector for the autocomplete elementes
	     * @type {string}
	     */

	    _this._autocompleteEls = opts.autoCompleteEls || '.js-yext-autocomplete-option';
	    /**
	     * An internal reference for the data-storage to listen for updates from the server
	     * @type {string}
	     */

	    _this.moduleId = StorageKeys.AUTOCOMPLETE + "." + _this.name;
	    /**
	     * An internal reference to the input value when typing.
	     * We use this for resetting the state of the input value when other interactions (e.g. result navigation)
	     * change based on interactions. For instance, hitting escape should reset the value to the original typed query.
	     * @type {string}
	     */

	    _this._originalQuery = opts.originalQuery || '';
	    /**
	     * Used for keyboard navigation through results.
	     * An internal reference to the current section we're navigating in.
	     * @type {number}
	     */

	    _this._sectionIndex = 0;
	    /**
	     * Used for keyboard navigation through results.
	     * An internal reference to the current result index we're navigating on.
	     * @type {number}
	     */

	    _this._resultIndex = -1;
	    /**
	     * The query text to show as the first item for auto complete.
	     * Optionally provided
	     * @type {string}
	     */

	    _this.promptHeader = opts.promptHeader || null;
	    /**
	     * Whether the input is autocomatically focused or not
	     * @type {boolean}
	     */

	    _this._autoFocus = opts.autoFocus || false;
	    /**
	     * Callback invoked when the `Enter` key is pressed on auto complete.
	     */

	    _this._onSubmit = opts.onSubmit || function () {};
	    /**
	     * Callback invoked when keys are used to navigate through the auto complete. Note that this is
	     * not called when either the `Enter` key is pressed or the mouse is used to select an
	     * autocomplete option.
	     */


	    _this._onChange = opts.onChange || function () {};

	    _this._searchParameters = opts.searchParameters || null;
	    /**
	     * HTML id for the aria-labelledby in the autocomplete list
	     * @type {string}
	     */

	    _this.listLabelIdName = opts.listLabelIdName || 'yxt-SearchBar-listLabel--SearchBar';
	    /**
	     * Whether to hide the autocomplete when the search input is empty
	     * @type {boolean}
	     */

	    _this._shouldHideOnEmptySearch = opts.shouldHideOnEmptySearch || false;
	    /**
	     * Callback invoked when the autocomplete component changes from closed to open.
	     * @type {function}
	     */

	    _this._onOpen = opts.onOpen || function () {};
	    /**
	     * Callback invoked when the autocomplete component changes from open to closed.
	     * @type {function}
	     */


	    _this._onClose = opts.onClose || function () {};
	    /**
	     * Indicates the initial open/closed status of this component
	     * @type {boolean}
	     */


	    _this._isOpen = false;
	    return _this;
	  }
	  /**
	   * The aliased used by the component manager for creation.
	   */


	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  AutoCompleteComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'search/autocomplete';
	  }
	  /**
	   * setState is overridden so that we can provide additional meta data
	   * to the template (e.g. the sectionIndex and resultIndex), since
	   * those are client-interaction specific values and aren't returned from the server.
	   */
	  ;

	  var _proto = AutoCompleteComponent.prototype;

	  _proto.setState = function setState(data) {
	    var queryInputEl = DOM.query(this._parentContainer, this._inputEl);
	    var shouldHideAutocomplete = this._shouldHideOnEmptySearch && !queryInputEl.value;
	    var wasOpen = this._isOpen;

	    if (!this.isQueryInputFocused() || shouldHideAutocomplete) {
	      this._isOpen = false;
	      this._sectionIndex = 0;
	      this._resultIndex = -1;
	      data = {};
	    } else {
	      this._isOpen = true;
	    }

	    if (wasOpen && !this._isOpen) {
	      this._onClose();
	    } else if (!wasOpen && this._isOpen) {
	      this._onOpen();
	    }

	    _Component.prototype.setState.call(this, _extends({}, data, {
	      hasResults: this.hasResults(data),
	      sectionIndex: this._sectionIndex,
	      resultIndex: this._resultIndex,
	      promptHeader: this._originalQuery.length === 0 ? this.promptHeader : null,
	      listLabelIdName: this.listLabelIdName
	    }));
	  };

	  _proto.isQueryInputFocused = function isQueryInputFocused() {
	    var _context;

	    return document.activeElement && document.activeElement.getAttribute('class') && includes$4(_context = document.activeElement.getAttribute('class')).call(_context, this._inputEl.substring(1));
	  }
	  /**
	   * updateState is a helper to apply the current state with new client-state.
	   */
	  ;

	  _proto.updateState = function updateState() {
	    this.setState(this._state.get());
	  }
	  /**
	   * onCreate is triggered when the component is constructed from the framework.
	   * Once we're initalized, we wire up all of our user interactions
	   */
	  ;

	  _proto.onCreate = function onCreate() {
	    var _this2 = this;

	    // Use the context of the parent component to find the input node.
	    var queryInput = DOM.query(this._parentContainer, this._inputEl);

	    if (!queryInput) {
	      throw new Error('Could not initialize AutoComplete. Can not find {HTMLElement} `', this._inputEl, '`.');
	    } // Disable the native autocomplete, autocorrect & spellcheck


	    DOM.attributes(queryInput, {
	      autocomplete: 'off',
	      autocorrect: 'off',
	      spellcheck: 'false'
	    }); // The user exits the input, so we want to reset the state and close
	    // the auto complete
	    // TODO(jdelerme): Close logic to be moved to parent

	    DOM.on(document, 'click', function (e) {
	      if (DOM.matches(e.target, '.js-yxt-AutoComplete-wrapper *') || DOM.matches(e.target, _this2._inputEl)) {
	        return;
	      }

	      _this2.close();
	    }); // When a user focuses the input, we should populate the autocomplete based
	    // on the current value

	    DOM.on(queryInput, 'focus', function () {
	      _this2.reset();

	      _this2.autoComplete(queryInput.value);
	    }); // Allow the user to navigate between the results using the keyboard

	    DOM.on(queryInput, 'keydown', function (e) {
	      _this2.handleNavigateResults(e.keyCode, e);

	      _this2.handleSubmitResult(e.keyCode, queryInput.value, e);
	    });

	    if (this._autoFocus) {
	      DOM.once(queryInput, 'click', function () {
	        _this2.autoComplete(queryInput.value);
	      });
	    } // Allow the user to select a result with the mouse


	    DOM.delegate(this._container, '.js-yext-autocomplete-option', 'click', function (evt, target) {
	      var data = target.dataset;
	      var val = data["short"];

	      _this2.updateQuery(val);

	      _this2._onSubmit(val, filter$2(data));

	      _this2.close();
	    }); // When the user is typing in the input, process the auto complete.

	    DOM.on(queryInput, 'keyup', function (e) {
	      _this2.handleTyping(e.keyCode, queryInput.value, e);
	    });
	  }
	  /**
	   * close will hide the auto complete results and reset the state.
	   */
	  ;

	  _proto.close = function close() {
	    this.setState({});
	    this.reset();
	  }
	  /**
	   * resets the client state to their original values and triggers
	   * a template-rerender via updateState
	   */
	  ;

	  _proto.reset = function reset() {
	    this._sectionIndex = 0;
	    this._resultIndex = -1;
	    this.updateState();
	  }
	  /**
	   * Helper method to update the input text
	   * @param {string} optValue Option value provided.
	   * If no value provided, we'll try to find it based on the selection indexes.
	   */
	  ;

	  _proto.updateQuery = function updateQuery(optValue) {
	    // Only want to update the query string if theres a value.
	    // If one is provided, great.
	    // Otherwise, lets try to find it from the current selection in the results.
	    if (optValue === undefined) {
	      var sections = this._state.get('sections');

	      var results = sections[this._sectionIndex].results;
	      optValue = results[this._resultIndex].shortValue;
	    }

	    var queryEl = DOM.query(this._parentContainer, this._inputEl);
	    queryEl.value = optValue;
	  };

	  _proto.handleTyping = function handleTyping(key, value, e) {
	    var ignoredKeys = [Keys.DOWN, Keys.UP, Keys.CTRL, Keys.ALT, Keys.SHIFT, Keys.LEFT, Keys.RIGHT, Keys.LEFT_OS_KEY, Keys.RIGHT_OS_KEY, Keys.ENTER, Keys.TAB, Keys.SELECT_KEY];

	    if (indexOf$3(ignoredKeys).call(ignoredKeys, key) > -1) {
	      return;
	    } // User escapes out of auto complete, so we reset it to the original input


	    if (key === Keys.ESCAPE) {
	      this.updateQuery(this._originalQuery);
	      this.close();
	      return;
	    } // Update the original value based on the user input


	    this._originalQuery = value;
	    this.reset();
	    this.autoComplete(value);
	  };

	  _proto.autoComplete = function autoComplete(input) {
	    if (this.isFilterSearch) {
	      this.core.autoCompleteFilter(input, {
	        namespace: this.name,
	        verticalKey: this._verticalKey,
	        searchParameters: this._searchParameters
	      });
	    } else if (this._verticalKey) {
	      this.core.autoCompleteVertical(input, this.name, this._verticalKey);
	    } else {
	      this.core.autoCompleteUniversal(input, this.name);
	    }
	  }
	  /**
	   * returns true if we have results in any section
	   * @returns boolean
	   */
	  ;

	  _proto.hasResults = function hasResults(data) {
	    if (!data) {
	      return false;
	    }

	    var sections = data.sections;

	    if (!sections) {
	      return false;
	    }

	    for (var i = 0; i < sections.length; i++) {
	      var _data = sections[i];

	      if (!_data) {
	        continue;
	      }

	      var results = _data.results;

	      if (!results) {
	        continue;
	      }

	      if (results.length > 0) {
	        return true;
	      }
	    }

	    return false;
	  };

	  _proto.handleNavigateResults = function handleNavigateResults(key, e) {
	    var sections = this._state.get('sections');

	    if (sections === undefined || sections.length <= 0) {
	      return;
	    } // Tabbing out or enter should close the auto complete.


	    if (key === Keys.TAB) {
	      this.close();
	      return;
	    }

	    var results = sections[this._sectionIndex].results;

	    if (key === Keys.UP) {
	      e.preventDefault();

	      if (this._resultIndex <= 0) {
	        if (this._sectionIndex > 0) {
	          this._sectionIndex--;
	          this._resultIndex = sections[this._sectionIndex].results.length - 1;
	        } else {
	          this.updateQuery(this._originalQuery);
	          this.reset();
	          return;
	        }

	        this.updateQuery();
	        this.updateState();
	        return;
	      }

	      this._resultIndex--;
	      this.updateState();
	      this.updateQuery();
	      return;
	    }

	    if (key === Keys.DOWN) {
	      e.preventDefault();

	      if (this._resultIndex >= results.length - 1) {
	        if (this._sectionIndex < sections.length - 1) {
	          this._sectionIndex++;
	          this._resultIndex = 0;
	        }

	        this.updateQuery();
	        this.updateState();
	        return;
	      }

	      this._resultIndex++;
	      this.updateQuery();
	      this.updateState();
	    }
	  };

	  _proto.handleSubmitResult = function handleSubmitResult(key, value, e) {
	    var sections = this._state.get('sections');

	    if (sections === undefined || sections.length <= 0) {
	      if (this.isFilterSearch) {
	        this.autoComplete(value);
	      }

	      return;
	    } // submit the search on enter


	    if (key === Keys.ENTER) {
	      e.preventDefault();

	      if (this.isFilterSearch && this._resultIndex === -1) {
	        return;
	      }

	      var filter = '';

	      if (this._sectionIndex >= 0 && this._resultIndex >= 0) {
	        filter = stringify$2(filter$2(sections[this._sectionIndex].results[this._resultIndex]));
	      }

	      this.updateQuery(value);
	      this._originalQuery = value;

	      this._onSubmit(value, filter);

	      this.close();
	    } else {
	      this._onChange();
	    }
	  };

	  _createClass(AutoCompleteComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'AutoComplete';
	    }
	  }]);

	  return AutoCompleteComponent;
	}(Component);

	function ownKeys$b(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$b(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$b(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var DEFAULT_CONFIG = {
	  suggestionHelpText: "Did you mean:"
	};
	/**
	 * SpellCheckComponent will support displaying suggestion, autocorrect and combined(maybe in the future)
	 * provided from spelling correction.
	 *
	 * @extends Component
	 */

	var SpellCheckComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(SpellCheckComponent, _Component);

	  function SpellCheckComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$a(_objectSpread$a({}, DEFAULT_CONFIG), config), systemConfig) || this;
	    _this.moduleId = StorageKeys.SPELL_CHECK;
	    return _this;
	  }

	  SpellCheckComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'search/spellcheck';
	  };

	  var _proto = SpellCheckComponent.prototype;

	  _proto.setState = function setState(data, val) {
	    return _Component.prototype.setState.call(this, _extends({}, data, {
	      shouldShow: data.correctedQuery !== undefined,
	      correctedQueryUrl: this._buildRedirectQueryUrl(data.correctedQuery, data.type),
	      helpText: this._getHelpText(data.type)
	    }, val));
	  };

	  _proto._buildRedirectQueryUrl = function _buildRedirectQueryUrl(query, type) {
	    if (query === undefined) {
	      return '';
	    }

	    var params = new SearchParams(this.core.storage.getCurrentStateUrlMerged());
	    params.set(StorageKeys.QUERY, query.value);
	    params.set(StorageKeys.SKIP_SPELL_CHECK, true);
	    params.set(StorageKeys.QUERY_TRIGGER, type.toLowerCase());
	    return '?' + params.toString();
	  };

	  _proto._getHelpText = function _getHelpText(type) {
	    switch (type) {
	      case 'SUGGEST':
	        return this._config.suggestionHelpText;

	      default:
	        return '';
	    }
	  };

	  _createClass(SpellCheckComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'SpellCheck';
	    }
	  }]);

	  return SpellCheckComponent;
	}(Component);

	var lodash_isequal = createCommonjsModule(function (module, exports) {
	/**
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    arrayTag = '[object Array]',
	    asyncTag = '[object AsyncFunction]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    nullTag = '[object Null]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    proxyTag = '[object Proxy]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    symbolTag = '[object Symbol]',
	    undefinedTag = '[object Undefined]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype,
	    funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    Symbol = root.Symbol,
	    Uint8Array = root.Uint8Array,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable,
	    splice = arrayProto.splice,
	    symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols,
	    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap'),
	    nativeCreate = getNative(Object, 'create');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty.call(data, key) ? data[key] : undefined;
	}

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	}

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	  return this;
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag : getTag(object),
	      othTag = othIsArr ? arrayTag : getTag(other);

	  objTag = objTag == argsTag ? objectTag : objTag;
	  othTag = othTag == argsTag ? objectTag : othTag;

	  var objIsObj = objTag == objectTag,
	      othIsObj = othTag == objectTag,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	        return false;
	      }
	      return true;

	    case boolTag:
	    case dateTag:
	    case numberTag:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag:
	    case stringTag:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag:
	      var convert = mapToArray;

	    case setTag:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag:
	      if (symbolValueOf) {
	        return symbolValueOf.call(object) == symbolValueOf.call(other);
	      }
	  }
	  return false;
	}

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable.call(object, symbol);
	  });
	};

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return !!length &&
	    (typeof value == 'number' || reIsUint.test(value)) &&
	    (value > -1 && value % 1 == 0 && value < length);
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEqual;
	});

	function ownKeys$c(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$c(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$c(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var DEFAULT_CONFIG$1 = {
	  ipAccuracyHelpText: "based on your internet address",
	  deviceAccuracyHelpText: "based on your device",
	  updateLocationButtonText: "Update your location"
	};
	/**
	 * LocationBiasComponent will show the user where is used for location bias and allow user to
	 * improve accuracy with HTML5 geolocation.
	 *
	 * @extends Component
	 */

	var LocationBiasComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(LocationBiasComponent, _Component);

	  function LocationBiasComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$b(_objectSpread$b({}, DEFAULT_CONFIG$1), config), systemConfig) || this;
	    /**
	     * Recieve updates from storage based on this index
	     * @type {StorageKey}
	     */

	    _this.core.storage.registerListener({
	      storageKey: StorageKeys.LOCATION_BIAS,
	      eventType: 'update',
	      callback: function callback(data) {
	        var searchIsLoading = data.searchState === SearchStates.SEARCH_LOADING;

	        if (!searchIsLoading && !lodash_isequal(data, _this.getState('locationBias'))) {
	          _this.setState(data);
	        }
	      }
	    });
	    /**
	     * The optional vertical key for vertical search configuration
	     * If not provided, when location updated,
	     * a universal search will be triggered.
	     * @type {string}
	     */
	    // TODO: Remove config.verticalKey


	    _this._verticalKey = config.verticalKey || _this.core.storage.get(StorageKeys.SEARCH_CONFIG).verticalKey || null;
	    /**
	     * The element used for updating location
	     * Optionally provided.
	     * @type {string} CSS selector
	     */

	    _this._updateLocationEl = config.updateLocationEl || '.js-locationBias-update-location';
	    _this._locationDisplayName = '';
	    _this._accuracy = '';
	    _this._allowUpdate = true;
	    /**
	     * Options to pass to the geolocation api.
	     * @type {Object}
	     */

	    _this._geolocationOptions = _objectSpread$b({
	      enableHighAccuracy: false,
	      timeout: 6000,
	      maximumAge: 300000
	    }, config.geolocationOptions);
	    /**
	     * Options for the geolocation timeout alert.
	     * @type {Object}
	     */

	    _this._geolocationTimeoutAlert = _objectSpread$b({
	      enabled: false,
	      message: "We are unable to determine your location"
	    }, config.geolocationTimeoutAlert);
	    return _this;
	  }

	  LocationBiasComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'search/locationbias';
	  };

	  var _proto = LocationBiasComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    if (!this._allowUpdate) {
	      return;
	    }

	    this._disableLocationUpdateIfGeolocationDenied();

	    DOM.on(this._updateLocationEl, 'click', function (e) {
	      if ('geolocation' in navigator) {
	        navigator.geolocation.getCurrentPosition(function (position) {
	          _this2.core.storage.set(StorageKeys.GEOLOCATION, {
	            lat: position.coords.latitude,
	            lng: position.coords.longitude,
	            radius: position.coords.accuracy
	          });

	          _this2.core.triggerSearch();
	        }, function (err) {
	          return _this2._handleGeolocationError(err);
	        }, _this2._geolocationOptions);
	      } // TODO: Should we throw error or warning here if no geolocation?

	    });
	  };

	  _proto._handleGeolocationError = function _handleGeolocationError(err) {
	    if (err.code === 1) {
	      this._disableLocationUpdate();
	    }

	    var _this$_geolocationTim = this._geolocationTimeoutAlert,
	        enabled = _this$_geolocationTim.enabled,
	        message = _this$_geolocationTim.message;

	    if (enabled) {
	      window.alert(message);
	    }
	  };

	  _proto.setState = function setState(data, val) {
	    this._locationDisplayName = data.locationDisplayName;
	    this._accuracy = data.accuracy;
	    return _Component.prototype.setState.call(this, _extends({}, data, {
	      locationDisplayName: this._getLocationDisplayName(data),
	      accuracyText: this._getAccuracyHelpText(data.accuracy),
	      isPreciseLocation: data.accuracy === 'DEVICE' && this._allowUpdate,
	      isUnknownLocation: data.accuracy === 'UNKNOWN',
	      shouldShow: data.accuracy !== undefined && data.accuracy !== null,
	      allowUpdate: this._allowUpdate,
	      locationBias: data
	    }, val));
	  };

	  _proto._getLocationDisplayName = function _getLocationDisplayName(data) {
	    if (data.accuracy === 'UNKNOWN') {
	      return "Unknown Location";
	    }

	    return data.locationDisplayName;
	  };

	  _proto._getAccuracyHelpText = function _getAccuracyHelpText(accuracy) {
	    switch (accuracy) {
	      case 'IP':
	        return this._config.ipAccuracyHelpText;

	      case 'DEVICE':
	        return this._config.deviceAccuracyHelpText;

	      default:
	        return '';
	    }
	  };

	  _proto._disableLocationUpdateIfGeolocationDenied = function _disableLocationUpdateIfGeolocationDenied() {
	    var _this3 = this;

	    if ('permissions' in navigator) {
	      navigator.permissions.query({
	        name: 'geolocation'
	      }).then(function (result) {
	        if (result.state === 'denied') {
	          _this3._disableLocationUpdate();
	        }
	      });
	    }
	  };

	  _proto._disableLocationUpdate = function _disableLocationUpdate() {
	    this.core.storage["delete"](StorageKeys.GEOLOCATION);
	    this._allowUpdate = false;
	    this.setState({
	      locationDisplayName: this._locationDisplayName,
	      accuracy: this._accuracy
	    });
	  };

	  _createClass(LocationBiasComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'LocationBias';
	    }
	  }]);

	  return LocationBiasComponent;
	}(Component);

	function ownKeys$d(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context11; forEach$2(_context11 = ownKeys$d(Object(source), true)).call(_context11, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context12; forEach$2(_context12 = ownKeys$d(Object(source))).call(_context12, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var FilterBoxConfig = /*#__PURE__*/function () {
	  function FilterBoxConfig(config) {
	    var _context;

	    /**
	     * The title to display above the controls
	     * @type {string}
	     */
	    this.title = config.title || "Filters";
	    /**
	     * If true, display the number of results next to each facet
	     * @type {boolean}
	     */

	    this.showCount = config.showCount === undefined ? true : config.showCount;
	    /**
	     * If true, trigger a search on each change to a filter
	     * @type {boolean}
	     */

	    this.searchOnChange = config.searchOnChange || false;
	    /**
	     * If true, show a button to reset for each facet group
	     * @type {boolean}
	     */

	    this.resetFilter = config.resetFilter || false;
	    /**
	     * The label to show for the reset button
	     * @type {string}
	     */

	    this.resetFilterLabel = config.resetFilterLabel || "reset";
	    /**
	     * If true, show a "reset all" button to reset all facets
	     * @type {boolean}
	     */

	    this.resetFilters = config.resetFilters === undefined ? !config.searchOnChange : config.resetFilters;
	    /**
	     * The label to show for the "reset all" button
	     * @type {string}
	     */

	    this.resetFiltersLabel = config.resetFiltersLabel || "reset all";
	    /**
	     * The max number of facets to show before displaying "show more"/"show less"
	     * @type {number}
	     */

	    this.showMoreLimit = config.showMoreLimit || 5;
	    /**
	     * The label to show for displaying more facets
	     * @type {string}
	     */

	    this.showMoreLabel = config.showMoreLabel || "show more";
	    /**
	     * The label to show for displaying less facets
	     * @type {string}
	     */

	    this.showLessLabel = config.showLessLabel || "show less";
	    /**
	     * If true, enable hiding excess facets in each group with a "show more"/"show less" button
	     * @type {boolean}
	     */

	    this.showMore = config.showMore === undefined ? true : config.showMore;
	    /**
	     * If true, allow expanding and collapsing each group of facets
	     * @type {boolean}
	     */

	    this.expand = config.expand === undefined ? true : config.expand;
	    /**
	     * If true, display the number of currently applied filters when collapsed
	     * @type {boolean}
	     */

	    this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
	    /**
	     * Text to display on the apply button
	     * @type {string}
	     */

	    this.applyLabel = config.applyLabel || "apply";
	    /**
	     * The selector of the apply button
	     * @type {string}
	     */

	    this.applyButtonSelector = config.applyButtonSelector || '.js-yext-filterbox-apply';
	    /**
	     * The list of filters to display and control, ignoring empty sections
	     * @type {object[]}
	     */

	    this.filterConfigs = filter$2(_context = config.filters).call(_context, function (f) {
	      return f.options.length;
	    });
	    /**
	     * Whether or not this filterbox contains facets. This affects the
	     * the way the filters are used in the search
	     * @type {boolean}
	     */

	    this.isDynamic = config.isDynamic || false;
	    this.validate();
	  }

	  var _proto = FilterBoxConfig.prototype;

	  _proto.validate = function validate() {};

	  return FilterBoxConfig;
	}();
	/**
	 * Renders a set of filters, and searches with them when applied.
	 * Multiple FilterBox components will AND together but will not share state.
	 * @extends Component
	 */


	var FilterBoxComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(FilterBoxComponent, _Component);

	  function FilterBoxComponent(config, systemConfig) {
	    var _context2;

	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    _this.config = new FilterBoxConfig(config);

	    if (!config.filters || !(config.filters instanceof Array)) {
	      throw new AnswersComponentError('FilterBox requires filters to be provided as an array', 'FilterBox');
	    }
	    /**
	     * The vertical key for the search
	     * @type {string}
	     * @private
	     */


	    _this._verticalKey = config.verticalKey || null;
	    /**
	     * The components created for each filter config
	     * @type {Component[]}
	     * @private
	     */

	    _this._filterComponents = [];
	    /**
	     * The current state of the filter components in the box
	     * @type {Array<FilterNode>}
	     * @private
	     */

	    _this._filterNodes = [];

	    forEach$2(_context2 = _this.config.filterConfigs).call(_context2, function (config) {
	      var hideCount = config.showCount === undefined ? !_this.config.showCount : !config.showCount;

	      if (hideCount) {
	        var _context3;

	        forEach$2(_context3 = config.options).call(_context3, function (option) {
	          option.countLabel = null;
	        });
	      }
	    });

	    return _this;
	  }

	  FilterBoxComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'filters/filterbox';
	  };

	  var _proto2 = FilterBoxComponent.prototype;

	  _proto2.setState = function setState(data) {
	    _Component.prototype.setState.call(this, _extends({}, data, this.config, {
	      showReset: this.config.resetFilters,
	      resetLabel: this.config.resetFiltersLabel,
	      showApplyButton: !this.config.searchOnChange
	    }));
	  };

	  _proto2.onMount = function onMount() {
	    var _this2 = this;

	    if (this._filterComponents.length) {
	      var _context4;

	      forEach$2(_context4 = this._filterComponents).call(_context4, function (c) {
	        return c.remove();
	      });

	      this._filterComponents = [];
	      this._filterNodes = [];
	    } // Initialize filters from configs


	    var _loop = function _loop(i) {
	      var config = _this2.config.filterConfigs[i];

	      var component = _this2.componentManager.create(config.type, _objectSpread$c(_objectSpread$c(_objectSpread$c({}, _this2.config), {}, {
	        parentContainer: _this2._container,
	        name: _this2.name + ".filter" + i,
	        storeOnChange: false,
	        container: ".js-yext-filterbox-filter" + i,
	        showReset: _this2.config.resetFilter,
	        resetLabel: _this2.config.resetFilterLabel,
	        isDynamic: _this2.config.isDynamic
	      }, config), {}, {
	        showExpand: config.showExpand === undefined ? _this2.config.expand : config.showExpand,
	        onChange: function onChange(filterNode, alwaysSaveFilterNodes, blockSearchOnChange) {
	          var _saveFilterNodes = _this2.config.searchOnChange || alwaysSaveFilterNodes;

	          var _searchOnChange = _this2.config.searchOnChange && !blockSearchOnChange;

	          _this2.onFilterNodeChange(i, filterNode, _saveFilterNodes, _searchOnChange);

	          config.onChange && config.onChange();
	        }
	      }));

	      if (_this2.config.isDynamic && typeof component.floatSelected === 'function') {
	        component.floatSelected();
	      }

	      component.mount();

	      _this2._filterComponents.push(component);

	      _this2._filterNodes[i] = component.getFilterNode();
	    };

	    for (var i = 0; i < this.config.filterConfigs.length; i++) {
	      _loop(i);
	    }

	    this._saveFilterNodesToStorage(); // Initialize apply button


	    if (!this.config.searchOnChange) {
	      var button = DOM.query(this._container, this.config.applyButtonSelector);

	      if (button) {
	        DOM.on(button, 'click', function () {
	          _this2._saveFilterNodesToStorage();

	          _this2.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	        });
	      }
	    } // Initialize reset button


	    var resetEl = DOM.query(this._container, '.js-yxt-FilterBox-reset');

	    if (resetEl) {
	      var _context5;

	      DOM.on(resetEl, 'click', bind$2(_context5 = this.resetFilters).call(_context5, this));
	    }
	  };

	  _proto2._getValidFilterNodes = function _getValidFilterNodes() {
	    var _context6;

	    return filter$2(_context6 = this._filterNodes).call(_context6, function (fn) {
	      return fn.getFilter().getFilterKey();
	    });
	  };

	  _proto2.resetFilters = function resetFilters() {
	    var _context7;

	    forEach$2(_context7 = this._filterComponents).call(_context7, function (filter) {
	      return filter.clearOptions();
	    });
	  }
	  /**
	   * Handle changes to child filter components
	   * @param {number} index The index of the changed filter
	   * @param {FilterNode} filterNode The new filter node
	   * @param {boolean} saveFilterNodes Whether to save filternodes to storage
	   * @param {boolean} searchOnChange Whether to conduct a search
	   */
	  ;

	  _proto2.onFilterNodeChange = function onFilterNodeChange(index, filterNode, saveFilterNodes, searchOnChange) {
	    this._filterNodes[index] = filterNode;

	    if (saveFilterNodes || searchOnChange) {
	      this._saveFilterNodesToStorage();
	    }

	    if (searchOnChange) {
	      this.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	    }
	  }
	  /**
	   * Remove all filter components along with this component
	   */
	  ;

	  _proto2.remove = function remove() {
	    var _context8;

	    forEach$2(_context8 = this._filterComponents).call(_context8, function (c) {
	      return c.remove();
	    });

	    _Component.prototype.remove.call(this);
	  }
	  /**
	   * Save current filters to storage to be used in the next search
	   * @private
	   */
	  ;

	  _proto2._saveFilterNodesToStorage = function _saveFilterNodesToStorage() {
	    if (this.config.isDynamic) {
	      var _context9;

	      var availableFieldIds = map$2(_context9 = this.config.filterConfigs).call(_context9, function (config) {
	        return config.fieldId;
	      });

	      this.core.setFacetFilterNodes(availableFieldIds, this._getValidFilterNodes());
	    } else {
	      var _context10;

	      forEach$2(_context10 = this._filterComponents).call(_context10, function (fc) {
	        return fc.apply();
	      });
	    }
	  };

	  _createClass(FilterBoxComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.FILTER_BOX;
	    }
	  }]);

	  return FilterBoxComponent;
	}(Component);

	var $values = objectToArray.values;

	// `Object.values` method
	// https://tc39.es/ecma262/#sec-object.values
	_export({ target: 'Object', stat: true }, {
	  values: function values(O) {
	    return $values(O);
	  }
	});

	var values = path.Object.values;

	var values$1 = values;

	var values$2 = values$1;

	var jsLevenshtein = (function()
	{
	  function _min(d0, d1, d2, bx, ay)
	  {
	    return d0 < d1 || d2 < d1
	        ? d0 > d2
	            ? d2 + 1
	            : d0 + 1
	        : bx === ay
	            ? d1
	            : d1 + 1;
	  }

	  return function(a, b)
	  {
	    if (a === b) {
	      return 0;
	    }

	    if (a.length > b.length) {
	      var tmp = a;
	      a = b;
	      b = tmp;
	    }

	    var la = a.length;
	    var lb = b.length;

	    while (la > 0 && (a.charCodeAt(la - 1) === b.charCodeAt(lb - 1))) {
	      la--;
	      lb--;
	    }

	    var offset = 0;

	    while (offset < la && (a.charCodeAt(offset) === b.charCodeAt(offset))) {
	      offset++;
	    }

	    la -= offset;
	    lb -= offset;

	    if (la === 0 || lb < 3) {
	      return lb;
	    }

	    var x = 0;
	    var y;
	    var d0;
	    var d1;
	    var d2;
	    var d3;
	    var dd;
	    var dy;
	    var ay;
	    var bx0;
	    var bx1;
	    var bx2;
	    var bx3;

	    var vector = [];

	    for (y = 0; y < la; y++) {
	      vector.push(y + 1);
	      vector.push(a.charCodeAt(offset + y));
	    }

	    var len = vector.length - 1;

	    for (; x < lb - 3;) {
	      bx0 = b.charCodeAt(offset + (d0 = x));
	      bx1 = b.charCodeAt(offset + (d1 = x + 1));
	      bx2 = b.charCodeAt(offset + (d2 = x + 2));
	      bx3 = b.charCodeAt(offset + (d3 = x + 3));
	      dd = (x += 4);
	      for (y = 0; y < len; y += 2) {
	        dy = vector[y];
	        ay = vector[y + 1];
	        d0 = _min(dy, d0, d1, bx0, ay);
	        d1 = _min(d0, d1, d2, bx1, ay);
	        d2 = _min(d1, d2, d3, bx2, ay);
	        dd = _min(d2, d3, dd, bx3, ay);
	        vector[y] = dd;
	        d3 = d2;
	        d2 = d1;
	        d1 = d0;
	        d0 = dy;
	      }
	    }

	    for (; x < lb;) {
	      bx0 = b.charCodeAt(offset + (d0 = x));
	      dd = ++x;
	      for (y = 0; y < len; y += 2) {
	        dy = vector[y];
	        vector[y] = dd = _min(dy, d0, dd, bx0, vector[y + 1]);
	        d0 = dy;
	      }
	    }

	    return dd;
	  };
	})();

	/**
	 * Groups an array into an object using a given key and value function, and an initial object
	 * to add to. By default the key and value functions will not perform any transformations
	 * on the array elements.
	 * @param {Array<any>} arr array to be grouped
	 * @param {Function} keyFunc function that evaluates what key to give an array element.
	 * @param {Function} valueFunc function that evaluates what value to give an array element.
	 * @param {Object} intitial the initial object to add to, defaulting to {}
	 * @returns {Object}
	 */
	function groupArray(arr, keyFunc, valueFunc, initial) {
	  keyFunc = keyFunc || function (key) {
	    return key;
	  };

	  valueFunc = valueFunc || function (value) {
	    return value;
	  };

	  return reduce$2(arr).call(arr, function (groups, element, idx) {
	    var key = keyFunc(element, idx);
	    var value = valueFunc(element, idx);

	    if (!groups[key]) {
	      groups[key] = [value];
	    } else {
	      groups[key].push(value);
	    }

	    return groups;
	  }, initial || {});
	}

	/**
	 * Checks whether a filter is equal to or included somewhere within the persistedFilter.
	 * Assumes the given filter is a simple filter, i.e. does not have any child filters.
	 * The persistedFilter can be either combined or simple.
	 *
	 * @param {Filter} filter
	 * @param {Filter} persistedFilter
	 * @returns {boolean}
	 */

	function filterIsPersisted(filter, persistedFilter) {
	  var childFilters = persistedFilter[FilterCombinators.AND] || persistedFilter[FilterCombinators.OR];

	  if (childFilters) {
	    return !!find$3(childFilters).call(childFilters, function (childFilter) {
	      return filterIsPersisted(filter, Filter.from(childFilter));
	    });
	  }

	  return lodash_isequal(filter, persistedFilter);
	}
	/**
	 * Given a filter, return an array of all it's descendants, including itself, that
	 * filter on the given fieldId.
	 *
	 * @param {Filter} persistedFilter
	 * @param {string} fieldId
	 *
	 * @returns {Array<Filter>}
	 */

	function findSimpleFiltersWithFieldId(persistedFilter, fieldId) {
	  var childFilters = persistedFilter[FilterCombinators.AND] || persistedFilter[FilterCombinators.OR];

	  if (childFilters) {
	    return flatMap$2(childFilters).call(childFilters, function (childFilter) {
	      return findSimpleFiltersWithFieldId(Filter.from(childFilter), fieldId);
	    });
	  }

	  if (Filter.from(persistedFilter).getFilterKey() === fieldId) {
	    return [persistedFilter];
	  }

	  return [];
	}
	/**
	 * Finds a persisted range filter for the given fieldId, and returns its contents.
	 *
	 * @param {Filter} persistedFilter
	 * @param {string} fieldId
	 * @returns {{minVal: number, maxVal: number}}
	 */

	function getPersistedRangeFilterContents(persistedFilter, fieldId) {
	  var _context;

	  if (!persistedFilter || !persistedFilter.getFilterKey()) {
	    return {};
	  }

	  var rangeFiltersForFieldId = filter$2(_context = findSimpleFiltersWithFieldId(persistedFilter, fieldId)).call(_context, function (f) {
	    return f.isRangeFilter();
	  });

	  if (rangeFiltersForFieldId.length < 1) {
	    return {};
	  }

	  return rangeFiltersForFieldId[0][fieldId];
	}

	function _createForOfIteratorHelperLoose$6(o, allowArrayLike) { var _context16; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context16 = it.next).call(_context16, it); }

	function _unsupportedIterableToArray$6(o, minLen) { var _context15; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = slice$4(_context15 = Object.prototype.toString.call(o)).call(_context15, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

	function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	function ownKeys$e(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context13; forEach$2(_context13 = ownKeys$e(Object(source), true)).call(_context13, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context14; forEach$2(_context14 = ownKeys$e(Object(source))).call(_context14, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * The currently supported controls
	 * @type {string[]}
	 */

	var SUPPORTED_CONTROLS = ['singleoption', 'multioption'];
	/**
	 * The currently supported option types.
	 */

	var OptionTypes = {
	  RADIUS_FILTER: 'RADIUS_FILTER',
	  STATIC_FILTER: 'STATIC_FILTER'
	};

	var FilterOptionsConfig = /*#__PURE__*/function () {
	  function FilterOptionsConfig(config, persistedState) {
	    var _context, _context2;

	    /**
	     * The type of control to display
	     * @type {string}
	     */
	    this.control = config.control;
	    /**
	     * The type of filtering to apply to the options.
	     * @type {string}
	     */

	    this.optionType = config.optionType || OptionTypes.STATIC_FILTER;
	    /**
	     * The list of filter options to display with checked status as
	     * initially specified in the user configuration
	     * @type {object[]}
	     */

	    this.initialOptions = map$2(_context = config.options).call(_context, function (o) {
	      return _objectSpread$d({}, o);
	    });
	    /**
	     * The list of filter options to display.
	     * @type {object[]}
	     */

	    this.options = map$2(_context2 = config.options).call(_context2, function (o) {
	      return _objectSpread$d({}, o);
	    });
	    /**
	     * The label to be used in the legend
	     * @type {string}
	     */

	    this.label = config.label || "Filters";
	    /**
	     * The callback function to call when changed
	     * @type {function}
	     */

	    this.onChange = config.onChange || function () {};
	    /**
	     * If true, stores the filter to global and persistent storage on each change
	     * @type {boolean}
	     */


	    this.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
	    /**
	     * If true, show a button to reset the current filter selection
	     * @type {boolean}
	     */

	    this.showReset = config.showReset && this.options.length > 0;
	    /**
	     * Whether this FilterOptions is part of a dynamic FilterBox component (i.e. is
	     * part of a FacetsComponent). Used to correctly set the {@link FilterType} of
	     * the created {@link FilterNode}.
	     * @type {boolean}
	     */

	    this.isDynamic = config.isDynamic;
	    /**
	     * The label to show for the reset button
	     * @type {string}
	     */

	    this.resetLabel = config.resetLabel || "reset";
	    /**
	     * The max number of facets to show before displaying "show more"/"show less"
	     * @type {number}
	     */

	    this.showMoreLimit = config.showMoreLimit || 5;
	    /**
	     * The label to show for displaying more facets
	     * @type {string}
	     */

	    this.showMoreLabel = config.showMoreLabel || "show more";
	    /**
	     * The label to show for displaying less facets
	     * @type {string}
	     */

	    this.showLessLabel = config.showLessLabel || "show less";
	    /**
	     * If true, enable hiding excess facets with a "show more"/"show less" button
	     * @type {boolean}
	     */

	    this.showMore = config.showMore === undefined ? true : config.showMore;
	    this.showMore = this.showMore && this.options.length > this.showMoreLimit;
	    /**
	     * If true, allow expanding and collapsing the group of facets
	     * @type {boolean}
	     */

	    this.showExpand = config.showExpand === undefined ? true : config.showExpand;
	    /**
	     * If true, display the number of currently applied filters when collapsed
	     * @type {boolean}
	     */

	    this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
	    /**
	     * The selector used for options in the template
	     * @type {string}
	     */

	    this.optionSelector = config.optionSelector || '.js-yext-filter-option';
	    /**
	     * The placeholder text used for the filter option search input
	     * @type {string}
	     */

	    this.placeholderText = config.placeholderText || "Search here...";
	    /**
	     * If true, display the filter option search input
	     * @type {boolean}
	     */

	    this.searchable = config.searchable || false;
	    /**
	     * The form label text for the search input
	     * @type {boolean}
	     */

	    this.searchLabelText = config.searchLabelText || "Search for a filter option";
	    this.validate();
	    var persistedFilter = persistedState.persistedFilter,
	        persistedLocationRadius = persistedState.persistedLocationRadius;

	    if (!this.isDynamic) {
	      var hasPersistedLocationRadius = persistedLocationRadius || persistedLocationRadius === 0;

	      if (this.optionType === OptionTypes.STATIC_FILTER && persistedFilter) {
	        this.options = this.getPersistedStaticFilterOptions(this.options, persistedFilter);
	      } else if (this.optionType === OptionTypes.RADIUS_FILTER && hasPersistedLocationRadius) {
	        this.options = this.getPersistedLocationRadiusOptions(this.options, persistedLocationRadius);
	      }
	    }
	  }
	  /**
	   * Returns the initial options from config, but with the persisted filters set to
	   * selected = true.
	   *
	   * @param {Array<{{
	   *  label: string,
	   *  value: string,
	   *  field: string,
	   *  selected?: boolean
	   * }}>} initialOptions Options from the component configuration.
	   * @param {Object} persistedFilter A persisted filter, can be combined or simple
	   * @returns {Array<Object>} The options in the same format as initialOptions with updated
	   *                          selected values
	   */


	  var _proto = FilterOptionsConfig.prototype;

	  _proto.getPersistedStaticFilterOptions = function getPersistedStaticFilterOptions(initialOptions, persistedFilter) {
	    return map$2(initialOptions).call(initialOptions, function (o) {
	      var filterForOption = Filter.equal(o.field, o.value);
	      var isPersisted = filterIsPersisted(filterForOption, persistedFilter);
	      return _objectSpread$d(_objectSpread$d({}, o), {}, {
	        selected: isPersisted
	      });
	    });
	  }
	  /**
	   * Returns the initial options from config, but with the persisted location radius filter
	   * set to selected = true.
	   *
	   * @param {Array<{{
	   *  label: string,
	   *  value: string,
	   *  selected?: boolean
	   * }}>} initialOptions Options from the component configuration.
	    * @param {number} persistedLocationRadius The value of the persisted locationRadius
	    * @returns {Array<Object>} The options in the same format as initialOptions with updated
	    *                          selected values
	    */
	  ;

	  _proto.getPersistedLocationRadiusOptions = function getPersistedLocationRadiusOptions(initialOptions, persistedLocationRadius) {
	    return map$2(initialOptions).call(initialOptions, function (o) {
	      var isPersisted = o.value === persistedLocationRadius;
	      return _objectSpread$d(_objectSpread$d({}, o), {}, {
	        selected: isPersisted
	      });
	    });
	  };

	  _proto.getInitialSelectedCount = function getInitialSelectedCount() {
	    var _context3;

	    return reduce$2(_context3 = this.options).call(_context3, function (numSelected, option) {
	      return option.selected ? numSelected + 1 : numSelected;
	    }, 0);
	  };

	  _proto.validate = function validate() {
	    var _context4;

	    if (!this.control || !includes$4(SUPPORTED_CONTROLS).call(SUPPORTED_CONTROLS, this.control)) {
	      throw new AnswersComponentError('FilterOptions requires a valid "control" to be provided', 'FilterOptions');
	    }

	    if (!(this.optionType in OptionTypes)) {
	      var possibleTypes = values$2(OptionTypes).join(', ');

	      throw new AnswersComponentError("Invalid optionType " + this.optionType + " passed to FilterOptions. Expected one of " + possibleTypes, 'FilterOptions');
	    }

	    if (this.optionType === OptionTypes.RADIUS_FILTER && this.control !== 'singleoption') {
	      throw new AnswersComponentError("FilterOptions of optionType " + OptionTypes.RADIUS_FILTER + " requires control \"singleoption\"", 'FilterOptions');
	    }

	    if (!this.options) {
	      throw new AnswersComponentError('FilterOptions component requires options to be provided', 'FilterOptions');
	    }

	    if (this.control === 'singleoption' && filter$2(_context4 = this.options).call(_context4, function (o) {
	      return o.selected;
	    }).length > 1) {
	      throw new AnswersComponentError('FilterOptions component with "singleoption" control cannot have multiple selected options', 'FilterOptions');
	    }
	  };

	  return FilterOptionsConfig;
	}();
	/**
	 * Renders a set of options, each one representing a filter in a search.
	 */


	var FilterOptionsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(FilterOptionsComponent, _Component);

	  function FilterOptionsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;

	    _this._initVariables(config);

	    if (_this.config.storeOnChange) {
	      _this.apply();
	    }

	    if (!_this.config.isDynamic) {
	      _this._registerBackNavigationListener();
	    }

	    return _this;
	  }
	  /**
	   * Initializes the component's instance variables.
	   *
	   * @param {Object} config
	   */


	  var _proto2 = FilterOptionsComponent.prototype;

	  _proto2._initVariables = function _initVariables(config) {
	    var persistedFilter = this.core.storage.get(StorageKeys.PERSISTED_FILTER);
	    var persistedLocationRadius = this.core.storage.get(StorageKeys.PERSISTED_LOCATION_RADIUS);
	    var persistedState = {
	      persistedFilter: persistedFilter,
	      persistedLocationRadius: persistedLocationRadius
	    };
	    /**
	     * The component config
	     * @type {FilterOptionsConfig}
	     */

	    this.config = new FilterOptionsConfig(config, persistedState);
	    var selectedCount = this.config.getInitialSelectedCount();
	    /**
	     * True if the option list is expanded and visible
	     * @type {boolean}
	     */

	    this.expanded = this.config.showExpand ? selectedCount > 0 : true;
	    /**
	     * Whether the current is currently showing more or less. If true, is currently "show more".
	     * Only used if config.showMore is true.
	     * @type {boolean}
	     */

	    this.showMoreState = this.config.showMore;
	  };

	  _proto2._registerBackNavigationListener = function _registerBackNavigationListener() {
	    var _this2 = this;

	    this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.HISTORY_POP_STATE,
	      callback: function callback() {
	        _this2._initVariables(_this2._config);

	        _this2.updateListeners(true, true);

	        _this2.setState();
	      }
	    });
	  };

	  /**
	   * The template to render, based on the control
	   * @returns {string}
	   * @override
	   */
	  FilterOptionsComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'controls/filteroptions';
	  };

	  _proto2.setState = function setState(data) {
	    var selectedCount = this._getSelectedCount();

	    _Component.prototype.setState.call(this, _extends({}, data, _objectSpread$d(_objectSpread$d({
	      name: this.name.toLowerCase()
	    }, this.config), {}, {
	      showMoreState: this.showMoreState,
	      displayReset: this.config.showReset && selectedCount > 0,
	      expanded: this.expanded,
	      selectedCount: selectedCount,
	      isSingleOption: this.config.control === 'singleoption'
	    })));
	  };

	  _proto2.onMount = function onMount() {
	    var _this3 = this;

	    DOM.delegate(DOM.query(this._container, '.yxt-FilterOptions-options'), this.config.optionSelector, 'click', function (event) {
	      var selectedCountEl = DOM.query(_this3._container, '.js-yxt-FilterOptions-selectedCount');

	      if (selectedCountEl) {
	        selectedCountEl.innerText = _this3._getSelectedCount();
	      }

	      _this3._updateOption(_parseInt$2(event.target.dataset.index), event.target.checked);
	    }); // Initialize reset element if present

	    var resetEl = DOM.query(this._container, '.js-yxt-FilterOptions-reset');

	    if (resetEl) {
	      var _context5;

	      DOM.on(resetEl, 'click', bind$2(_context5 = this.clearOptions).call(_context5, this));
	    } // show more/less button


	    if (this.config.showMore) {
	      var showLessEl = DOM.query(this._container, '.js-yxt-FilterOptions-showLess');
	      var showMoreEl = DOM.query(this._container, '.js-yxt-FilterOptions-showMore');
	      var optionsOverLimitEls = DOM.queryAll(this._container, '.js-yxt-FilterOptions-aboveShowMoreLimit');
	      DOM.on(showLessEl, 'click', function () {
	        _this3.showMoreState = true;
	        showLessEl.classList.add('hidden');
	        showMoreEl.classList.remove('hidden');

	        for (var _iterator = _createForOfIteratorHelperLoose$6(optionsOverLimitEls), _step; !(_step = _iterator()).done;) {
	          var optionEl = _step.value;
	          optionEl.classList.add('hidden');
	        }
	      });
	      DOM.on(showMoreEl, 'click', function () {
	        _this3.showMoreState = false;
	        showLessEl.classList.remove('hidden');
	        showMoreEl.classList.add('hidden');

	        for (var _iterator2 = _createForOfIteratorHelperLoose$6(optionsOverLimitEls), _step2; !(_step2 = _iterator2()).done;) {
	          var optionEl = _step2.value;
	          optionEl.classList.remove('hidden');
	        }
	      });
	    } // searchable option list


	    if (this.config.searchable) {
	      var clearSearchEl = DOM.query(this._container, '.js-yxt-FilterOptions-clearSearch');
	      var searchInputEl = DOM.query(this._container, '.js-yxt-FilterOptions-filter');
	      var filterOptionEls = DOM.queryAll(this._container, '.js-yxt-FilterOptions-option');
	      var filterContainerEl = DOM.query(this._container, '.js-yxt-FilterOptions-container'); // On clearSearchEl click, clear search input

	      if (clearSearchEl && searchInputEl) {
	        DOM.on(clearSearchEl, 'click', function (event) {
	          searchInputEl.value = '';
	          DOM.trigger(searchInputEl, 'input');
	          searchInputEl.focus();
	        });
	      }

	      DOM.on(searchInputEl, 'input', function (event) {
	        var filter = event.target.value;

	        if (!filter) {
	          filterContainerEl.classList.remove('yxt-FilterOptions-container--searching');
	          clearSearchEl.classList.add('js-hidden');
	        } else {
	          filterContainerEl.classList.add('yxt-FilterOptions-container--searching');
	          clearSearchEl.classList.remove('js-hidden');
	        }

	        for (var _iterator3 = _createForOfIteratorHelperLoose$6(filterOptionEls), _step3; !(_step3 = _iterator3()).done;) {
	          var filterOption = _step3.value;
	          var labelEl = DOM.query(filterOption, '.js-yxt-FilterOptions-optionLabel--name');
	          var labelText = labelEl.textContent || labelEl.innerText || '';
	          labelText = trim$3(labelText).call(labelText);

	          if (!filter) {
	            filterOption.classList.remove('hiddenSearch');
	            filterOption.classList.remove('displaySearch');
	            labelEl.innerHTML = labelText;
	          } else {
	            var matchedSubstring = _this3._getMatchedSubstring(labelText.toLowerCase(), filter.toLowerCase());

	            if (matchedSubstring) {
	              filterOption.classList.add('displaySearch');
	              filterOption.classList.remove('hiddenSearch');
	              labelEl.innerHTML = new HighlightedValue({
	                value: labelText,
	                matchedSubstrings: [matchedSubstring]
	              }).get();
	            } else {
	              filterOption.classList.add('hiddenSearch');
	              filterOption.classList.remove('displaySearch');
	              labelEl.innerHTML = labelText;
	            }
	          }
	        }
	      });
	    } // expand button


	    if (this.config.showExpand) {
	      var legend = DOM.query(this._container, '.yxt-FilterOptions-clickableLegend');
	      DOM.on(legend, 'mousedown', function (click) {
	        if (click.button === 0) {
	          _this3.expanded = !_this3.expanded;

	          _this3.setState();
	        }
	      });
	      DOM.on(legend, 'keydown', function (key) {
	        if (key.key === ' ' || key.key === 'Enter') {
	          key.preventDefault();
	          _this3.expanded = !_this3.expanded;

	          _this3.setState();
	        }
	      });
	    }
	  }
	  /**
	   * Returns the count of currently selected options
	   * @returns {number}
	   * @private
	   */
	  ;

	  _proto2._getSelectedCount = function _getSelectedCount() {
	    var _context6;

	    return filter$2(_context6 = this.config.options).call(_context6, function (o) {
	      return o.selected;
	    }).length;
	  }
	  /**
	   * Toggles the display of the reset element based on the selected count. If there are selected
	   * options, show the reset element, if not, hide it.
	   *
	   * Note: this will not have any effect if the reset element isn't in the DOM.
	   *
	   * @returns {number}
	   * @private
	   */
	  ;

	  _proto2._toggleReset = function _toggleReset() {
	    var resetEl = DOM.query(this._container, '.js-yxt-FilterOptions-reset');

	    var selectedCount = this._getSelectedCount();

	    if (selectedCount > 0) {
	      resetEl.classList.remove('js-hidden');
	    } else if (!resetEl.classList.contains('js-hidden')) {
	      resetEl.classList.add('js-hidden');
	    }
	  }
	  /**
	   * Finds the length and offset of the substring where (string) option and
	   * (string) filter "match".
	   *
	   * "Match" is defined as an exact text match, or -- if the length of filter
	   * is greater than the `minFilterSizeForLevenshtein` -- a "match" can occur if
	   * any "n length" substring of option (where "n length" is the length of filter)
	   * is within the `maxLevenshteinDistance` levenshtein distance of the filter.
	   *
	   * Note: this is case sensitive.
	   *
	   * @returns {Object}
	   * @private
	   */
	  ;

	  _proto2._getMatchedSubstring = function _getMatchedSubstring(option, filter) {
	    var offset = this._getOffset(option, filter);

	    if (offset > -1) {
	      return {
	        length: filter.length,
	        offset: offset
	      };
	    }

	    var minFilterSizeForLevenshtein = 3;
	    var maxLevenshteinDistance = 1;

	    if (filter.length > minFilterSizeForLevenshtein) {
	      // Break option into X filter.length size substrings
	      var substrings = [];

	      for (var start = 0; start <= option.length - filter.length; start++) {
	        substrings.push(option.substr(start, filter.length));
	      } // Find the substring that is the closest in levenshtein distance to filter


	      var minLevDist = filter.length;
	      var minLevSubstring = filter;

	      for (var _i = 0, _substrings = substrings; _i < _substrings.length; _i++) {
	        var substring = _substrings[_i];

	        var levDist = this._calcLevenshteinDistance(substring, filter);

	        if (levDist < minLevDist) {
	          minLevDist = levDist;
	          minLevSubstring = substring;
	        }
	      } // If the min levenshtein distance is below the max, count it as a match


	      if (minLevDist <= maxLevenshteinDistance) {
	        offset = this._getOffset(option, minLevSubstring);

	        if (offset > -1) {
	          return {
	            length: filter.length,
	            offset: offset
	          };
	        }
	      }
	    }
	  }
	  /**
	   * Calculate the levenshtein distance for two strings
	   * @returns {number}
	   * @private
	   */
	  ;

	  _proto2._calcLevenshteinDistance = function _calcLevenshteinDistance(a, b) {
	    return jsLevenshtein(a, b);
	  }
	  /**
	   * Returns the starting index of first occurance of the (string) filter in
	   * the (string) option, or -1 if not present
	   * @returns {number}
	   * @private
	   */
	  ;

	  _proto2._getOffset = function _getOffset(option, filter) {
	    return option && filter ? indexOf$3(option).call(option, filter) : -1;
	  }
	  /**
	   * Clears all selected options.
	   */
	  ;

	  _proto2.clearOptions = function clearOptions() {
	    var _context7;

	    this.config.options = map$2(_context7 = this.config.options).call(_context7, function (o) {
	      return _extends({}, o, {
	        selected: false
	      });
	    });
	    this.updateListeners();
	    this.setState();
	  }
	  /**
	   * Call the config.onChange callback with the FilterNode corresponding to the
	   * component state.
	   * @param {boolean} alwaysSaveFilterNodes
	   * @param {boolean} blockSearchOnChange
	   */
	  ;

	  _proto2.updateListeners = function updateListeners(alwaysSaveFilterNodes, blockSearchOnChange) {
	    var filterNode = this.getFilterNode();

	    if (this.config.storeOnChange) {
	      this.apply();
	    }

	    this.config.onChange(filterNode, alwaysSaveFilterNodes, blockSearchOnChange);
	  };

	  _proto2._updateOption = function _updateOption(index, selected) {
	    if (this.config.control === 'singleoption') {
	      var _context8;

	      this.config.options = map$2(_context8 = this.config.options).call(_context8, function (o) {
	        return _extends({}, o, {
	          selected: false
	        });
	      });
	    }

	    this.config.options[index] = _extends({}, this.config.options[index], {
	      selected: selected
	    });

	    if (this.config.showReset) {
	      this._toggleReset();
	    }

	    this.updateListeners();
	  }
	  /**
	   * Apply filter changes
	   */
	  ;

	  _proto2.apply = function apply() {
	    switch (this.config.optionType) {
	      case OptionTypes.RADIUS_FILTER:
	        this.core.setLocationRadiusFilterNode(this.getLocationRadiusFilterNode());
	        break;

	      case OptionTypes.STATIC_FILTER:
	        this.core.setStaticFilterNodes(this.name, this.getFilterNode());
	        break;

	      default:
	        throw new AnswersComponentError("Unknown optionType " + this.config.optionType, 'FilterOptions');
	    }
	  };

	  _proto2.floatSelected = function floatSelected() {
	    var _context9;

	    this.config.options = sort$2(_context9 = this.config.options).call(_context9, function (a, b) {
	      return b.selected - a.selected;
	    });
	  };

	  _proto2._buildFilter = function _buildFilter(option) {
	    return filter$2(option) ? filter$2(option) : Filter.equal(option.field, option.value);
	  };

	  _proto2._getFilterType = function _getFilterType() {
	    if (this.config.isDynamic) {
	      return FilterType.FACET;
	    }

	    return this.config.optionType === 'RADIUS_FILTER' ? FilterType.RADIUS : FilterType.STATIC;
	  };

	  _proto2._buildFilterMetadata = function _buildFilterMetadata(option) {
	    return new FilterMetadata({
	      fieldName: this.config.label,
	      displayValue: option.label,
	      filterType: this._getFilterType()
	    });
	  }
	  /**
	   * Return the FilterNode when this is a RADIUS_FILTER.
	   * @type {FilterNode}
	   */
	  ;

	  _proto2.getLocationRadiusFilterNode = function getLocationRadiusFilterNode() {
	    var _context10,
	        _this4 = this;

	    var selectedOption = find$3(_context10 = this.config.options).call(_context10, function (o) {
	      return o.selected;
	    });

	    if (!selectedOption) {
	      return FilterNodeFactory.from();
	    }

	    var filterNode = {
	      metadata: this._buildFilterMetadata(selectedOption),
	      filter: {
	        value: selectedOption.value
	      },
	      remove: function remove() {
	        return _this4._clearSingleOption(selectedOption);
	      }
	    };
	    return FilterNodeFactory.from(filterNode);
	  };

	  _proto2._clearSingleOption = function _clearSingleOption(option) {
	    option.selected = false;
	    this.updateListeners(true, true);
	    this.setState();
	  }
	  /**
	   * Returns this component's filter node when it is a STATIC_FILTER.
	   * This method is exposed so that components like {@link FilterBoxComponent}
	   * can access them.
	   * @returns {FilterNode}
	   */
	  ;

	  _proto2.getFilterNode = function getFilterNode() {
	    var _context11,
	        _context12,
	        _this5 = this;

	    var filterNodes = map$2(_context11 = filter$2(_context12 = this.config.options).call(_context12, function (o) {
	      return o.selected;
	    })).call(_context11, function (o) {
	      return FilterNodeFactory.from({
	        filter: _this5._buildFilter(o),
	        metadata: _this5._buildFilterMetadata(o),
	        remove: function remove() {
	          return _this5._clearSingleOption(o);
	        }
	      });
	    });

	    var fieldIdToFilterNodes = groupArray(filterNodes, function (fn) {
	      return fn.getFilter().getFilterKey();
	    }); // OR together filter nodes for the same field id.

	    var totalFilterNodes = [];

	    for (var _i2 = 0, _Object$values2 = values$2(fieldIdToFilterNodes); _i2 < _Object$values2.length; _i2++) {
	      var sameIdNodes = _Object$values2[_i2];
	      totalFilterNodes.push(FilterNodeFactory.or.apply(FilterNodeFactory, sameIdNodes));
	    } // AND all of the ORed together nodes.


	    return FilterNodeFactory.and.apply(FilterNodeFactory, totalFilterNodes);
	  };

	  _createClass(FilterOptionsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.FILTER_OPTIONS;
	    }
	  }]);

	  return FilterOptionsComponent;
	}(Component);

	// `Number.parseInt` method
	// https://tc39.es/ecma262/#sec-number.parseint
	_export({ target: 'Number', stat: true, forced: Number.parseInt != numberParseInt }, {
	  parseInt: numberParseInt
	});

	var _parseInt$3 = path.Number.parseInt;

	var _parseInt$4 = _parseInt$3;

	var _parseInt$5 = _parseInt$4;

	function ownKeys$f(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context3; forEach$2(_context3 = ownKeys$f(Object(source), true)).call(_context3, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context4; forEach$2(_context4 = ownKeys$f(Object(source))).call(_context4, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var DEFAULT_CONFIG$2 = {
	  minPlaceholderText: "Min",
	  maxPlaceholderText: "Max"
	};

	var RangeFilterComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(RangeFilterComponent, _Component);

	  function RangeFilterComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$e(_objectSpread$e({}, DEFAULT_CONFIG$2), config), systemConfig) || this;
	    /**
	     * The field to filter on
	     * @type {string}
	     * @private
	     */

	    _this._field = config.field;
	    /**
	     * The callback function to call when the filter value changes
	     * @type {function}
	     * @private
	     */

	    _this._onChange = config.onChange || function () {};
	    /**
	     * If true, stores the filter to storage on each change
	     * @type {boolean}
	     * @private
	     */


	    _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
	    /**
	     * The title to display for the range control
	     * @type {string}
	     * @private
	     */

	    _this._title = config.title;
	    /**
	     * The optional label to display for the min input
	     * @type {string}
	     * @private
	     */

	    _this._minLabel = config.minLabel || null;
	    /**
	     * The optional label to display for the max input
	     * @type {string}
	     * @private
	     */

	    _this._maxLabel = config.maxLabel || null;

	    _this.seedFromPersistedFilter();

	    _this.core.storage.registerListener({
	      storageKey: StorageKeys.HISTORY_POP_STATE,
	      eventType: 'update',
	      callback: function callback() {
	        _this.seedFromPersistedFilter();

	        _this.setState();
	      }
	    });

	    return _this;
	  }
	  /**
	   * Reseeds the component state from the PERSISTED_FILTER in storage.
	   * If there is an active filter, store it in core.
	   */


	  var _proto = RangeFilterComponent.prototype;

	  _proto.seedFromPersistedFilter = function seedFromPersistedFilter() {
	    if (this.core.storage.has(StorageKeys.PERSISTED_FILTER)) {
	      var persistedFilter = this.core.storage.get(StorageKeys.PERSISTED_FILTER);
	      var persistedFilterContents = getPersistedRangeFilterContents(persistedFilter, this._field);
	      var minVal = persistedFilterContents[Matcher.GreaterThanOrEqualTo],
	          maxVal = persistedFilterContents[Matcher.LessThanOrEqualTo];
	      this._range = {
	        min: minVal,
	        max: maxVal
	      };
	    } else {
	      var _context, _context2;

	      this._range = {
	        min: find$3(_context = [this._config.initialMin, 0]).call(_context, function (v) {
	          return v !== undefined;
	        }),
	        max: find$3(_context2 = [this._config.initialMax, 10]).call(_context2, function (v) {
	          return v !== undefined;
	        })
	      };
	    }

	    if (this._range.min != null || this._range.max != null) {
	      var filterNode = this.getFilterNode();
	      this.core.setStaticFilterNodes(this.name, filterNode);
	    }
	  };

	  RangeFilterComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'controls/range';
	  };

	  _proto.setState = function setState(data) {
	    _Component.prototype.setState.call(this, _extends({}, data, {
	      name: this.name,
	      title: this._title,
	      minLabel: this._minLabel,
	      maxLabel: this._maxLabel,
	      minValue: this._range.min,
	      maxValue: this._range.max
	    }));
	  };

	  _proto.onCreate = function onCreate() {
	    var _this2 = this;

	    DOM.delegate(this._container, '.js-yext-range', 'change', function (event) {
	      _this2._updateRange(event.target.dataset.key, _parseInt$5(event.target.value));
	    });
	  };

	  _proto.setMin = function setMin(value) {
	    this._updateRange('min', value);
	  };

	  _proto.setMax = function setMax(value) {
	    this._updateRange('max', value);
	  };

	  _proto._removeFilterNode = function _removeFilterNode() {
	    this._range = {
	      min: null,
	      max: null
	    };
	    this.setState();

	    this._onChange(FilterNodeFactory.from());

	    this.core.clearStaticFilterNode(this.name);
	    this.core.storage["delete"](this.name + ".min");
	    this.core.storage["delete"](this.name + ".max");
	  }
	  /**
	   * Returns this component's filter node.
	   * This method is exposed so that components like {@link FilterBoxComponent}
	   * can access them.
	   * @returns {FilterNode}
	   */
	  ;

	  _proto.getFilterNode = function getFilterNode() {
	    var _this3 = this;

	    return FilterNodeFactory.from({
	      filter: this._buildFilter(),
	      metadata: this._buildFilterMetadata(),
	      remove: function remove() {
	        return _this3._removeFilterNode();
	      }
	    });
	  }
	  /**
	   * Update the current range state
	   * @param {string} key The range key to update
	   * @param {number} value The new value for the key
	   */
	  ;

	  _proto._updateRange = function _updateRange(key, value) {
	    var _extends2;

	    this._range = _extends({}, this._range, (_extends2 = {}, _extends2[key] = value, _extends2));
	    this.setState();
	    var filterNode = this.getFilterNode();

	    if (this._storeOnChange) {
	      this.core.setStaticFilterNodes(this.name, filterNode);
	    }

	    this._onChange(filterNode);
	  }
	  /**
	   * Build the filter representation of the current state
	   * @returns {Filter}
	   */
	  ;

	  _proto._buildFilter = function _buildFilter() {
	    var _this$_range = this._range,
	        min = _this$_range.min,
	        max = _this$_range.max;
	    var falsyMin = !min && min !== 0;
	    var falsyMax = !max && max !== 0;

	    var _min = falsyMin ? null : _parseInt$2(min);

	    var _max = falsyMax ? null : _parseInt$2(max);

	    return Filter.range(this._field, _min, _max, false);
	  }
	  /**
	   * Helper method for creating range filter metadata
	   * @returns {FilterMetadata}
	   */
	  ;

	  _proto._buildFilterMetadata = function _buildFilterMetadata() {
	    var _this$_range2 = this._range,
	        min = _this$_range2.min,
	        max = _this$_range2.max;
	    var falsyMin = !min && min !== 0;
	    var falsyMax = !max && max !== 0;

	    if (falsyMin && falsyMax) {
	      return new FilterMetadata({
	        fieldName: this._title
	      });
	    } // TODO add config option to range filter component for exclusive ranges.
	    var displayValue;

	    if (falsyMax) {
	      displayValue =  "\u2265 " + min;
	    } else if (falsyMin) {
	      displayValue =  "\u2264 " + max;
	    } else if (min === max) {
	      displayValue =  min;
	    } else {
	      displayValue =  min + " - " + max;
	    }

	    return new FilterMetadata({
	      fieldName: this._title,
	      displayValue: displayValue
	    });
	  };

	  _createClass(RangeFilterComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.RANGE_FILTER;
	    }
	  }]);

	  return RangeFilterComponent;
	}(Component);

	// `String.prototype.repeat` method implementation
	// https://tc39.es/ecma262/#sec-string.prototype.repeat
	var stringRepeat = ''.repeat || function repeat(count) {
	  var str = String(requireObjectCoercible(this));
	  var result = '';
	  var n = toInteger(count);
	  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
	  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
	  return result;
	};

	// https://github.com/tc39/proposal-string-pad-start-end




	var ceil$1 = Math.ceil;

	// `String.prototype.{ padStart, padEnd }` methods implementation
	var createMethod$6 = function (IS_END) {
	  return function ($this, maxLength, fillString) {
	    var S = String(requireObjectCoercible($this));
	    var stringLength = S.length;
	    var fillStr = fillString === undefined ? ' ' : String(fillString);
	    var intMaxLength = toLength(maxLength);
	    var fillLen, stringFiller;
	    if (intMaxLength <= stringLength || fillStr == '') return S;
	    fillLen = intMaxLength - stringLength;
	    stringFiller = stringRepeat.call(fillStr, ceil$1(fillLen / fillStr.length));
	    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
	    return IS_END ? S + stringFiller : stringFiller + S;
	  };
	};

	var stringPad = {
	  // `String.prototype.padStart` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padstart
	  start: createMethod$6(false),
	  // `String.prototype.padEnd` method
	  // https://tc39.es/ecma262/#sec-string.prototype.padend
	  end: createMethod$6(true)
	};

	// https://github.com/zloirock/core-js/issues/280


	// eslint-disable-next-line unicorn/no-unsafe-regex -- safe
	var stringPadWebkitBug = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(engineUserAgent);

	var $padStart = stringPad.start;


	// `String.prototype.padStart` method
	// https://tc39.es/ecma262/#sec-string.prototype.padstart
	_export({ target: 'String', proto: true, forced: stringPadWebkitBug }, {
	  padStart: function padStart(maxLength /* , fillString = ' ' */) {
	    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
	  }
	});

	var padStart = entryVirtual('String').padStart;

	var StringPrototype$3 = String.prototype;

	var padStart_1 = function (it) {
	  var own = it.padStart;
	  return typeof it === 'string' || it === StringPrototype$3
	    || (it instanceof String && own === StringPrototype$3.padStart) ? padStart : own;
	};

	var padStart$1 = padStart_1;

	var padStart$2 = padStart$1;

	/**
	 * A filter for a range of dates
	 */

	var DateRangeFilterComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(DateRangeFilterComponent, _Component);

	  function DateRangeFilterComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    /**
	     * The api field this filter controls
	     * @type {string}
	     * @private
	     */

	    _this._field = config.field;
	    /**
	     * The title to display for the date range
	     * @type {string}
	     * @private
	     */

	    _this._title = config.title;
	    /**
	     * The optional label to show for the min date input
	     * @type {string}
	     * @private
	     */

	    _this._minLabel = config.minLabel || null;
	    /**
	     * The optional label to show for the max date input
	     * @type {string}
	     * @private
	     */

	    _this._maxLabel = config.maxLabel || null;
	    /**
	     * The callback used when a date is changed
	     * @type {function}
	     * @private
	     */

	    _this._onChange = config.onChange || function () {};
	    /**
	     * If true, stores the filter to storage on each change
	     * @type {boolean}
	     * @private
	     */


	    _this._storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
	    /**
	     * If true, this filter represents an exclusive range, rather than an inclusive one
	     * @type {boolean}
	     * @private
	     */

	    _this._isExclusive = config.isExclusive;

	    _this.seedFromPersistedFilter();

	    _this.core.storage.registerListener({
	      storageKey: StorageKeys.HISTORY_POP_STATE,
	      eventType: 'update',
	      callback: function callback() {
	        _this.seedFromPersistedFilter();

	        _this.setState();
	      }
	    });

	    return _this;
	  }
	  /**
	   * Reseeds the component state from the PERSISTED_FILTER in storage.
	   * If there is an active filter, store it in core.
	   */


	  var _proto = DateRangeFilterComponent.prototype;

	  _proto.seedFromPersistedFilter = function seedFromPersistedFilter() {
	    if (this.core.storage.has(StorageKeys.PERSISTED_FILTER)) {
	      var persistedFilter = this.core.storage.get(StorageKeys.PERSISTED_FILTER);
	      var persistedFilterContents = getPersistedRangeFilterContents(persistedFilter, this._field);
	      var minVal, maxVal;

	      if (this._isExclusive) {
	        minVal = persistedFilterContents[Matcher.GreaterThan];
	        maxVal = persistedFilterContents[Matcher.LessThan];
	      } else {
	        minVal = persistedFilterContents[Matcher.GreaterThanOrEqualTo];
	        maxVal = persistedFilterContents[Matcher.LessThanOrEqualTo];
	      }

	      this._date = {
	        min: minVal,
	        max: maxVal
	      };
	    } else {
	      var _context, _context2, _context3, _context4;

	      var today = new Date();

	      var todayString = today.getFullYear() + "-" + padStart$2(_context = "" + (today.getMonth() + 1)).call(_context, 2, '0') + "-" + padStart$2(_context2 = "" + today.getDate()).call(_context2, 2, '0');

	      this._date = {
	        min: find$3(_context3 = [this._config.initialMin, todayString]).call(_context3, function (v) {
	          return v !== undefined;
	        }),
	        max: find$3(_context4 = [this._config.initialMax, todayString]).call(_context4, function (v) {
	          return v !== undefined;
	        })
	      };
	    }

	    if (this._date.min != null || this._date.max != null) {
	      var filterNode = this.getFilterNode();
	      this.core.setStaticFilterNodes(this.name, filterNode);
	    }
	  };

	  DateRangeFilterComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'controls/date';
	  };

	  _proto.setState = function setState(data) {
	    _Component.prototype.setState.call(this, _extends({}, data, {
	      name: this.name,
	      title: this._title,
	      minLabel: this._minLabel,
	      maxLabel: this._maxLabel,
	      dateMin: this._date.min,
	      dateMax: this._date.max
	    }));
	  };

	  _proto.onCreate = function onCreate() {
	    var _this2 = this;

	    DOM.delegate(this._container, '.js-yext-date', 'change', function (event) {
	      _this2._updateRange(event.target.dataset.key, event.target.value);
	    });
	  }
	  /**
	   * Set the min date to the one provided
	   * @param {string} date Date to set in yyyy-mm-dd string format
	   */
	  ;

	  _proto.setMin = function setMin(date) {
	    this._updateRange('min', date);
	  }
	  /**
	   * Set the max date to the one provided
	   * @param {string} date Date to set in yyyy-mm-dd string format
	   */
	  ;

	  _proto.setMax = function setMax(date) {
	    this._updateRange('max', date);
	  };

	  _proto._removeFilterNode = function _removeFilterNode() {
	    this._date = {
	      min: null,
	      max: null
	    };
	    this.setState();

	    this._onChange(FilterNodeFactory.from());

	    this.core.clearStaticFilterNode(this.name);
	    this.core.storage["delete"](this.name + ".min");
	    this.core.storage["delete"](this.name + ".max");
	  }
	  /**
	   * Returns this component's filter node.
	   * This method is exposed so that components like {@link FilterBoxComponent}
	   * can access them.
	   * @returns {FilterNode}
	   */
	  ;

	  _proto.getFilterNode = function getFilterNode() {
	    var _this3 = this;

	    return FilterNodeFactory.from({
	      filter: this._buildFilter(),
	      metadata: this._buildFilterMetadata(),
	      remove: function remove() {
	        return _this3._removeFilterNode();
	      }
	    });
	  }
	  /**
	   * Updates the current state of the date range
	   * @param {string} key The key for the date value
	   * @param {string} value The string date value
	   * @private
	   */
	  ;

	  _proto._updateRange = function _updateRange(key, value) {
	    var _extends2;

	    this._date = _extends({}, this._date, (_extends2 = {}, _extends2[key] = value, _extends2));
	    this.setState();
	    var filterNode = this.getFilterNode();

	    if (this._storeOnChange) {
	      this.core.setStaticFilterNodes(this.name, filterNode);
	    }

	    this.core.storage.setWithPersist(this.name + ".min", this._date.min);
	    this.core.storage.setWithPersist(this.name + ".max", this._date.max);

	    this._onChange(filterNode);
	  }
	  /**
	   * Construct an api filter with the current date state
	   * @private
	   */
	  ;

	  _proto._buildFilter = function _buildFilter() {
	    return Filter.range(this._field, this._date.min, this._date.max, this._isExclusive);
	  }
	  /**
	   * Helper method for creating a date range filter metadata
	   * @returns {FilterMetadata}
	   */
	  ;

	  _proto._buildFilterMetadata = function _buildFilterMetadata() {
	    var _this$_date = this._date,
	        min = _this$_date.min,
	        max = _this$_date.max;

	    if (!min && !max) {
	      return new FilterMetadata({
	        fieldName: this._title
	      });
	    }

	    var displayValue;

	    if (!max) {
	      displayValue = this._isExclusive ? ANSWERS.processTranslation('After [[date]]', {date:min}) : ANSWERS.processTranslation('[[date]] or later', {date:min});
	    } else if (!min) {
	      displayValue = this._isExclusive ? ANSWERS.processTranslation('Before [[date]]', {date:max}) : ANSWERS.processTranslation('[[date]] and earlier', {date:max});
	    } else if (min === max) {
	      displayValue = this._isExclusive ? '' : min;
	    } else {
	      displayValue = ANSWERS.processTranslation('[[start]] - [[end]]', {start:min,end:max});
	    }

	    return new FilterMetadata({
	      fieldName: this._title,
	      displayValue: displayValue
	    });
	  };

	  _createClass(DateRangeFilterComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.DATE_RANGE_FILTER;
	    }
	  }]);

	  return DateRangeFilterComponent;
	}(Component);

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	var _listCacheClear = listCacheClear;

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	var eq_1 = eq;

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq_1(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	var _assocIndexOf = assocIndexOf;

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice$3 = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice$3.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	var _listCacheDelete = listCacheDelete;

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	var _listCacheGet = listCacheGet;

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return _assocIndexOf(this.__data__, key) > -1;
	}

	var _listCacheHas = listCacheHas;

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = _assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	var _listCacheSet = listCacheSet;

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = _listCacheClear;
	ListCache.prototype['delete'] = _listCacheDelete;
	ListCache.prototype.get = _listCacheGet;
	ListCache.prototype.has = _listCacheHas;
	ListCache.prototype.set = _listCacheSet;

	var _ListCache = ListCache;

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new _ListCache;
	  this.size = 0;
	}

	var _stackClear = stackClear;

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	var _stackDelete = stackDelete;

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	var _stackGet = stackGet;

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	var _stackHas = stackHas;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	var _freeGlobal = freeGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = _freeGlobal || freeSelf || Function('return this')();

	var _root = root;

	/** Built-in value references. */
	var Symbol$2 = _root.Symbol;

	var _Symbol = Symbol$2;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty$1.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	var _getRawTag = getRawTag;

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString$1(value) {
	  return nativeObjectToString$1.call(value);
	}

	var _objectToString = objectToString$1;

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? _getRawTag(value)
	    : _objectToString(value);
	}

	var _baseGetTag = baseGetTag;

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject$1(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	var isObject_1 = isObject$1;

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject_1(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = _baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	var isFunction_1 = isFunction;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = _root['__core-js_shared__'];

	var _coreJsData = coreJsData;

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	var _isMasked = isMasked;

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	var _toSource = toSource;

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject_1(value) || _isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(_toSource(value));
	}

	var _baseIsNative = baseIsNative;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	var _getValue = getValue;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = _getValue(object, key);
	  return _baseIsNative(value) ? value : undefined;
	}

	var _getNative = getNative;

	/* Built-in method references that are verified to be native. */
	var Map = _getNative(_root, 'Map');

	var _Map = Map;

	/* Built-in method references that are verified to be native. */
	var nativeCreate = _getNative(Object, 'create');

	var _nativeCreate = nativeCreate;

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
	  this.size = 0;
	}

	var _hashClear = hashClear;

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _hashDelete = hashDelete;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (_nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
	}

	var _hashGet = hashGet;

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$4.call(data, key);
	}

	var _hashHas = hashHas;

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	var _hashSet = hashSet;

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = _hashClear;
	Hash.prototype['delete'] = _hashDelete;
	Hash.prototype.get = _hashGet;
	Hash.prototype.has = _hashHas;
	Hash.prototype.set = _hashSet;

	var _Hash = Hash;

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new _Hash,
	    'map': new (_Map || _ListCache),
	    'string': new _Hash
	  };
	}

	var _mapCacheClear = mapCacheClear;

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	var _isKeyable = isKeyable;

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return _isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	var _getMapData = getMapData;

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = _getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	var _mapCacheDelete = mapCacheDelete;

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return _getMapData(this, key).get(key);
	}

	var _mapCacheGet = mapCacheGet;

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return _getMapData(this, key).has(key);
	}

	var _mapCacheHas = mapCacheHas;

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = _getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	var _mapCacheSet = mapCacheSet;

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = _mapCacheClear;
	MapCache.prototype['delete'] = _mapCacheDelete;
	MapCache.prototype.get = _mapCacheGet;
	MapCache.prototype.has = _mapCacheHas;
	MapCache.prototype.set = _mapCacheSet;

	var _MapCache = MapCache;

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof _ListCache) {
	    var pairs = data.__data__;
	    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new _MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	var _stackSet = stackSet;

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new _ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = _stackClear;
	Stack.prototype['delete'] = _stackDelete;
	Stack.prototype.get = _stackGet;
	Stack.prototype.has = _stackHas;
	Stack.prototype.set = _stackSet;

	var _Stack = Stack;

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	var _arrayEach = arrayEach;

	var defineProperty$a = (function() {
	  try {
	    var func = _getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	var _defineProperty$1 = defineProperty$a;

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && _defineProperty$1) {
	    _defineProperty$1(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	var _baseAssignValue = baseAssignValue;

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$5.call(object, key) && eq_1(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    _baseAssignValue(object, key, value);
	  }
	}

	var _assignValue = assignValue;

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      _baseAssignValue(object, key, newValue);
	    } else {
	      _assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	var _copyObject = copyObject;

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	var _baseTimes = baseTimes;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	var isObjectLike_1 = isObjectLike;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
	}

	var _baseIsArguments = baseIsArguments;

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
	  return isObjectLike_1(value) && hasOwnProperty$6.call(value, 'callee') &&
	    !propertyIsEnumerable$1.call(value, 'callee');
	};

	var isArguments_1 = isArguments;

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray$4 = Array.isArray;

	var isArray_1 = isArray$4;

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	var stubFalse_1 = stubFalse;

	var isBuffer_1 = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse_1;

	module.exports = isBuffer;
	});

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$2 = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER$2 : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	var _isIndex = isIndex;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$3 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$3;
	}

	var isLength_1 = isLength;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike_1(value) &&
	    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
	}

	var _baseIsTypedArray = baseIsTypedArray;

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	var _baseUnary = baseUnary;

	var _nodeUtil = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports && _freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule && freeModule.require && freeModule.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	module.exports = nodeUtil;
	});

	/* Node.js helper references. */
	var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

	var isTypedArray_1 = isTypedArray;

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$7.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray_1(value),
	      isArg = !isArr && isArguments_1(value),
	      isBuff = !isArr && !isArg && isBuffer_1(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? _baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$7.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           _isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _arrayLikeKeys = arrayLikeKeys;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$8;

	  return value === proto;
	}

	var _isPrototype = isPrototype;

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	var _overArg = overArg;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = _overArg(Object.keys, Object);

	var _nativeKeys = nativeKeys;

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!_isPrototype(object)) {
	    return _nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$8.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeys = baseKeys;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength_1(value.length) && !isFunction_1(value);
	}

	var isArrayLike_1 = isArrayLike;

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys$9(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
	}

	var keys_1$1 = keys$9;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && _copyObject(source, keys_1$1(source), object);
	}

	var _baseAssign = baseAssign;

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _nativeKeysIn = nativeKeysIn;

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject_1(object)) {
	    return _nativeKeysIn(object);
	  }
	  var isProto = _isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	var _baseKeysIn = baseKeysIn;

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  return isArrayLike_1(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
	}

	var keysIn_1 = keysIn;

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && _copyObject(source, keysIn_1(source), object);
	}

	var _baseAssignIn = baseAssignIn;

	var _cloneBuffer = createCommonjsModule(function (module, exports) {
	/** Detect free variable `exports`. */
	var freeExports =  exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? _root.Buffer : undefined,
	    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	module.exports = cloneBuffer;
	});

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	var _copyArray = copyArray;

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	var _arrayFilter = arrayFilter;

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	var stubArray_1 = stubArray;

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$2 = objectProto$b.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$2.call(object, symbol);
	  });
	};

	var _getSymbols = getSymbols;

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return _copyObject(source, _getSymbols(source), object);
	}

	var _copySymbols = copySymbols;

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	var _arrayPush = arrayPush;

	/** Built-in value references. */
	var getPrototype = _overArg(Object.getPrototypeOf, Object);

	var _getPrototype = getPrototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray_1 : function(object) {
	  var result = [];
	  while (object) {
	    _arrayPush(result, _getSymbols(object));
	    object = _getPrototype(object);
	  }
	  return result;
	};

	var _getSymbolsIn = getSymbolsIn;

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return _copyObject(source, _getSymbolsIn(source), object);
	}

	var _copySymbolsIn = copySymbolsIn;

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
	}

	var _baseGetAllKeys = baseGetAllKeys;

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return _baseGetAllKeys(object, keys_1$1, _getSymbols);
	}

	var _getAllKeys = getAllKeys;

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return _baseGetAllKeys(object, keysIn_1, _getSymbolsIn);
	}

	var _getAllKeysIn = getAllKeysIn;

	/* Built-in method references that are verified to be native. */
	var DataView$1 = _getNative(_root, 'DataView');

	var _DataView = DataView$1;

	/* Built-in method references that are verified to be native. */
	var Promise$2 = _getNative(_root, 'Promise');

	var _Promise = Promise$2;

	/* Built-in method references that are verified to be native. */
	var Set = _getNative(_root, 'Set');

	var _Set = Set;

	/* Built-in method references that are verified to be native. */
	var WeakMap$2 = _getNative(_root, 'WeakMap');

	var _WeakMap = WeakMap$2;

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$1 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = _toSource(_DataView),
	    mapCtorString = _toSource(_Map),
	    promiseCtorString = _toSource(_Promise),
	    setCtorString = _toSource(_Set),
	    weakMapCtorString = _toSource(_WeakMap);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = _baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (_Map && getTag(new _Map) != mapTag$1) ||
	    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
	    (_Set && getTag(new _Set) != setTag$1) ||
	    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = _baseGetTag(value),
	        Ctor = result == objectTag$1 ? value.constructor : undefined,
	        ctorString = Ctor ? _toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var _getTag = getTag;

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$a.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	var _initCloneArray = initCloneArray;

	/** Built-in value references. */
	var Uint8Array$1 = _root.Uint8Array;

	var _Uint8Array = Uint8Array$1;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
	  return result;
	}

	var _cloneArrayBuffer = cloneArrayBuffer;

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	var _cloneDataView = cloneDataView;

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	var _cloneRegExp = cloneRegExp;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = _Symbol ? _Symbol.prototype : undefined,
	    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	var _cloneSymbol = cloneSymbol;

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	var _cloneTypedArray = cloneTypedArray;

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return _cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return _cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return _cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return _cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag:
	      return _cloneSymbol(object);
	  }
	}

	var _initCloneByTag = initCloneByTag;

	/** Built-in value references. */
	var objectCreate$1 = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject_1(proto)) {
	      return {};
	    }
	    if (objectCreate$1) {
	      return objectCreate$1(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	var _baseCreate = baseCreate;

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !_isPrototype(object))
	    ? _baseCreate(_getPrototype(object))
	    : {};
	}

	var _initCloneObject = initCloneObject;

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike_1(value) && _getTag(value) == mapTag$3;
	}

	var _baseIsMap = baseIsMap;

	/* Node.js helper references. */
	var nodeIsMap = _nodeUtil && _nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

	var isMap_1 = isMap;

	/** `Object#toString` result references. */
	var setTag$3 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike_1(value) && _getTag(value) == setTag$3;
	}

	var _baseIsSet = baseIsSet;

	/* Node.js helper references. */
	var nodeIsSet = _nodeUtil && _nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

	var isSet_1 = isSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$1 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$2 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$1 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
	cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
	cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$2] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$1] =
	cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
	cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
	cloneableTags[errorTag$1] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject_1(value)) {
	    return value;
	  }
	  var isArr = isArray_1(value);
	  if (isArr) {
	    result = _initCloneArray(value);
	    if (!isDeep) {
	      return _copyArray(value, result);
	    }
	  } else {
	    var tag = _getTag(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer_1(value)) {
	      return _cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$2 || tag == argsTag$2 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? _copySymbolsIn(value, _baseAssignIn(result, value))
	          : _copySymbols(value, _baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = _initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new _Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet_1(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap_1(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? _getAllKeysIn : _getAllKeys)
	    : (isFlat ? keysIn_1 : keys_1$1);

	  var props = isArr ? undefined : keysFunc(value);
	  _arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	var _baseClone = baseClone;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
	}

	var cloneDeep_1 = cloneDeep;

	function ownKeys$g(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$g(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$g(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var FacetsConfig = /*#__PURE__*/function () {
	  function FacetsConfig(config) {
	    /**
	     * The title to display above the controls
	     * @type {string}
	     */
	    this.title = config.title || "Filters";
	    /**
	     * If true, display the number of results next to each facet
	     * @type {boolean}
	     */

	    this.showCount = config.showCount === undefined ? true : config.showCount;
	    /**
	     * If true, trigger a search on each change to a filter
	     * @type {boolean}
	     */

	    this.searchOnChange = config.searchOnChange || false;
	    /**
	     * If true, show a button to reset for each facet group
	     * @type {boolean}
	     */

	    this.resetFacet = config.resetFacet || false;
	    /**
	     * The label to show for the reset button
	     * @type {string}
	     */

	    this.resetFacetLabel = config.resetFacetLabel || "reset";
	    /**
	     * If true, show a "reset all" button to reset all facets
	     * @type {boolean}
	     */

	    this.resetFacets = config.resetFacets;
	    /**
	     * The label to show for the "reset all" button
	     * @type {string}
	     */

	    this.resetFacetsLabel = config.resetFacetsLabel || "reset all";
	    /**
	     * The max number of facets to show before displaying "show more"/"show less"
	     * @type {number}
	     */

	    this.showMoreLimit = config.showMoreLimit || 5;
	    /**
	     * The label to show for displaying more facets
	     * @type {string}
	     */

	    this.showMoreLabel = config.showMoreLabel || "show more";
	    /**
	     * The label to show for displaying less facets
	     * @type {string}
	     */

	    this.showLessLabel = config.showLessLabel || "show less";
	    /**
	     * If true, enable hiding excess facets in each group with a "show more"/"show less" button
	     * @type {boolean}
	     */

	    this.showMore = config.showMore === undefined ? true : config.showMore;
	    /**
	     * If true, allow expanding and collapsing each group of facets
	     * @type {boolean}
	     */

	    this.expand = config.expand === undefined ? true : config.expand;
	    /**
	     * If true, display the number of currently applied filters when collapsed
	     * @type {boolean}
	     */

	    this.showNumberApplied = config.showNumberApplied === undefined ? true : config.showNumberApplied;
	    /**
	     * Text to display on the apply button
	     * @type {string}
	     */

	    this.applyLabel = config.applyLabel || "apply";
	    /**
	     * The controls to use for each field. Each type of filter has a default
	     * $eq : multioption (checkbox)
	     *
	     * DEPRECATED: use transformFacets instead
	     *
	     * @type {Object}
	     */

	    this.fieldControls = config.fieldControls || {};
	    /**
	     * The placeholder text used for the filter option search input
	     * @type {string}
	     */

	    this.placeholderText = config.placeholderText || "Search here...";
	    /**
	     * If true, display the filter option search input
	     * @type {boolean}
	     */

	    this.searchable = config.searchable || false;
	    /**
	     * The form label text for the search input
	     * @type {boolean}
	     */

	    this.searchLabelText = config.searchLabelText || "Search for a filter option";
	    /**
	     * An object that maps field API names to their filter options overrides,
	     * which have the same keys as the config options in FilterOptions component.
	     *
	     * DEPRECATED: use transformFacets instead
	     *
	     * @type {Object}
	     */

	    this.fields = config.fields || {};
	    /**
	     * The selector of the apply button
	     * @type {string}
	     * @private
	     */

	    this.applyButtonSelector = config.applyButtonSelector || null;
	    /**
	     * A transformation function which operates on the core library DisplayableFacet model
	     * @type {Function}
	     */

	    this.transformFacets = config.transformFacets;
	    this.validate();
	  }

	  var _proto = FacetsConfig.prototype;

	  _proto.validate = function validate() {};

	  return FacetsConfig;
	}();
	/**
	 * Displays a set of dynamic filters returned from the backend
	 * @extends Component
	 */


	var FacetsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(FacetsComponent, _Component);

	  function FacetsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    _this.config = new FacetsConfig(config);
	    /**
	     * The vertical key for the search
	     * @type {string}
	     * @private
	     */

	    _this._verticalKey = config.verticalKey;
	    /**
	     * The selector of the apply button
	     * @type {string}
	     * @private
	     */

	    _this._applyButtonSelector = config.applyButtonSelector || null;
	    /**
	     * An internal reference for the data storage to listen for updates from the server
	     * @type {string}
	     */

	    _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
	    /**
	     * The filter box that displays the dynamic filters
	     * @type {FilterBoxComponent}
	     * @private
	     */

	    _this._filterbox = null;
	    /**
	     * A transformation function which operates on the core library DisplayableFacet model
	     * @type {Function}
	     */

	    _this._transformFacets = config.transformFacets;
	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  FacetsComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'filters/facets';
	  };

	  var _proto2 = FacetsComponent.prototype;

	  _proto2.setState = function setState(data) {
	    var facets = data.filters || [];

	    if (this._transformFacets) {
	      var facetsCopy = cloneDeep_1(facets);
	      facets = this._transformFacets(facetsCopy, this.config);
	    }

	    facets = map$2(facets).call(facets, this._applyDefaultFormatting);
	    return _Component.prototype.setState.call(this, _objectSpread$f(_objectSpread$f({}, data), {}, {
	      filters: Facet.fromCore(facets),
	      filterOptionsConfigs: this._getFilterOptionsConfigs(facets),
	      isNoResults: data.resultsContext === ResultsContext.NO_RESULTS
	    }));
	  }
	  /**
	   * Extracts the filter options from transformedFacets and puts them in an object
	   * keyed by fieldId
	   *
	   * @param {DisplayableFacet | FilterOptionsConfig} transformedFacets a union of the
	   * DisplayableFacet model from ansers-core, and the config options of the FilterOptionsConfig
	   * @returns {Object} config options of the FilterOptionsConfig keyed by fieldId
	   */
	  ;

	  _proto2._getFilterOptionsConfigs = function _getFilterOptionsConfigs(transformedFacets) {
	    return reduce$2(transformedFacets).call(transformedFacets, function (acc, currentFacet) {
	      var filterOptions = _extends({}, currentFacet); // Delete the options from filterOptions because a DisplayableFacetOption array cannot be
	      // passed to FilterOptionsConfig. Even after deletion here, the filter options will still
	      // exist in the 'filters' field of the facets component state, and therefore any
	      // modifications which occur to options inside transformFacets will still take effect.


	      filterOptions.options && delete filterOptions.options;
	      acc[currentFacet.fieldId] = filterOptions;
	      return acc;
	    }, {});
	  }
	  /**
	   * Applies default formatting to a facet
	   *
	   * @param {DisplayableFacet} facet from answers-core
	   * @returns {DisplayableFacet} from answers-core
	   */
	  ;

	  _proto2._applyDefaultFormatting = function _applyDefaultFormatting(facet) {
	    var isBooleanFacet = function isBooleanFacet(facet) {
	      var firstOption = facet.options && facet.options[0] || {};
	      return firstOption.value === true || firstOption.value === false;
	    };

	    if (isBooleanFacet(facet)) {
	      return FacetsComponent._transformBooleanFacet(facet);
	    }

	    return facet;
	  }
	  /**
	   * Applies default formatting to a boolean facet
	   *
	   * @param {DisplayableFacet} facet from answers-core
	   * @returns {DisplayableFacet} from answers-core
	   */
	  ;

	  FacetsComponent._transformBooleanFacet = function _transformBooleanFacet(facet) {
	    var _context;

	    var options = map$2(_context = facet.options).call(_context, function (option) {
	      var displayName = option.displayName;

	      if (option.value === true && displayName === 'true') {
	        displayName = "True";
	      }

	      if (option.value === false && displayName === 'false') {
	        displayName = "False";
	      }

	      return _extends({}, option, {
	        displayName: displayName
	      });
	    });

	    return _extends({}, facet, {
	      options: options
	    });
	  };

	  _proto2.remove = function remove() {
	    if (this._filterbox) {
	      this._filterbox.remove();
	    }

	    _Component.prototype.remove.call(this);
	  };

	  _proto2.onMount = function onMount() {
	    var _this2 = this;

	    this.core.enableDynamicFilters();

	    if (this._filterbox) {
	      this._filterbox.remove();

	      this._filterbox = null;
	    }

	    var _this$_state$get = this._state.get(),
	        filters = _this$_state$get.filters,
	        isNoResults = _this$_state$get.isNoResults,
	        filterOptionsConfigs = _this$_state$get.filterOptionsConfigs;

	    if (filters.length === 0 || isNoResults) {
	      return;
	    }

	    filters = map$2(filters).call(filters, function (f) {
	      var fieldOverrides = _this2.config.transformFacets ? filterOptionsConfigs[f.fieldId] || {} : _this2.config.fields[f.fieldId] || {};
	      return _extends({}, f, _objectSpread$f({
	        type: 'FilterOptions',
	        control: _this2.config.fieldControls[f.fieldId] || 'multioption',
	        searchable: _this2.config.searchable,
	        searchLabelText: _this2.config.searchLabelText,
	        placeholderText: _this2.config.placeholderText,
	        showExpand: fieldOverrides.expand === undefined ? _this2.config.expand : fieldOverrides.expand
	      }, fieldOverrides));
	    }); // TODO: pass an apply() method to FilterBox, that will override its default behavior,
	    // and remove the isDynamic config option.

	    this._filterbox = this.componentManager.create('FilterBox', _extends({}, this.config, {
	      parentContainer: this._container,
	      name: this.name + ".filterbox",
	      container: '.js-yxt-Facets',
	      verticalKey: this._verticalKey,
	      resetFilter: this.config.resetFacet,
	      resetFilters: this.config.resetFacets,
	      resetFilterLabel: this.config.resetFacetLabel,
	      resetFiltersLabel: this.config.resetFacetsLabel,
	      isDynamic: true,
	      filters: filters
	    }));

	    this._filterbox.mount();

	    this.core.storage.set(StorageKeys.FACETS_LOADED, true);
	  };

	  _createClass(FacetsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.FACETS;
	    }
	  }]);

	  return FacetsComponent;
	}(Component);

	function ownKeys$h(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$h(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$h(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var METERS_PER_MILE = 1609.344;
	var DEFAULT_CONFIG$3 = {
	  /**
	   * The radius, in miles, around the user's location to find results.
	   * If location accuracy is low, a larger radius may be used automatically
	   * @type {number}
	   */
	  radius: 50,

	  /**
	   * The vertical key to use
	   * @type {string}
	   */
	  verticalKey: null,

	  /**
	   * If true, submits a search when the value is changed
	   * @type {boolean}
	   */
	  searchOnChange: false,

	  /**
	   * The title to display
	   * @type {string}
	   */
	  title: "Location",

	  /**
	   * The label to display
	   * @type {string}
	   */
	  label: "Location",

	  /**
	   * The icon url to show in the geo button
	   * @type {string}
	   */
	  geoButtonIcon: '',

	  /**
	   * The alt text to include with the geo button icon
	   * @type {string}
	   */
	  geoButtonIconAltText: "Use My Location",

	  /**
	   * The text to show in the geo button
	   * @type {string}
	   */
	  geoButtonText: "Use My Location",

	  /**
	   * The text to show when geolocation is enabled
	   * @type {string}
	   */
	  enabledText: "Current Location",

	  /**
	   * The text to show when loading the user's location
	   * @type {string}
	   */
	  loadingText: "Finding Your Location...",

	  /**
	   * The text to show if the user's location cannot be found
	   * @type {string}
	   */
	  errorText: "Could Not Find Your Location",

	  /**
	   * The CSS selector of the toggle button
	   * @type {string}
	   */
	  buttonSelector: '.js-yxt-GeoLocationFilter-button',

	  /**
	   * The CSS selector of the query input
	   * @type {string}
	   */
	  inputSelector: '.js-yxt-GeoLocationFilter-input'
	};
	/**
	 * Renders a button that when clicked adds a static filter representing the user's location
	 * @extends Component
	 */

	var GeoLocationComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(GeoLocationComponent, _Component);

	  function GeoLocationComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$g(_objectSpread$g({}, DEFAULT_CONFIG$3), config), systemConfig) || this;
	    /**
	     * The query string to use for the input box, provided to template for rendering.
	     * @type {string}
	     */

	    _this.query = _this.core.storage.get(StorageKeys.QUERY + "." + _this.name) || '';

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.QUERY + "." + _this.name,
	      callback: function callback(q) {
	        _this.query = q;

	        _this.setState();
	      }
	    });

	    _this.searchParameters = buildSearchParameters(config.searchParameters);
	    /**
	     * Options to pass to the geolocation api.
	     * @type {Object}
	     */

	    _this._geolocationOptions = _objectSpread$g({
	      enableHighAccuracy: false,
	      timeout: 6000,
	      maximumAge: 300000
	    }, config.geolocationOptions);
	    /**
	     * Options for the geolocation timeout alert.
	     * @type {Object}
	     */

	    _this._geolocationTimeoutAlert = _objectSpread$g({
	      enabled: false,
	      message: "We are unable to determine your location"
	    }, config.geolocationTimeoutAlert);
	    return _this;
	  }

	  GeoLocationComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'controls/geolocation';
	  };

	  var _proto = GeoLocationComponent.prototype;

	  _proto.setState = function setState(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    var placeholder = '';

	    if (this._enabled) {
	      placeholder = this._config.enabledText;
	    }

	    if (data.geoLoading) {
	      placeholder = this._config.loadingText;
	    }

	    if (data.geoError) {
	      placeholder = this._config.errorText;
	    }

	    _Component.prototype.setState.call(this, _objectSpread$g(_objectSpread$g({}, data), {}, {
	      title: this._config.title,
	      geoEnabled: this._enabled,
	      query: this.query,
	      labelText: this._config.label,
	      enabledText: this._config.enabledText,
	      loadingText: this._config.loadingText,
	      errorText: this._config.errorText,
	      geoButtonIcon: this._config.geoButtonIcon,
	      geoValue: this._enabled || data.geoLoading || data.geoError ? '' : this.query,
	      geoPlaceholder: placeholder,
	      geoButtonText: this._config.geoButtonText
	    }));
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    if (this._autocomplete) {
	      this._autocomplete.remove();
	    }

	    this._initAutoComplete(this._config.inputSelector);

	    DOM.on(DOM.query(this._container, this._config.buttonSelector), 'click', function () {
	      return _this2._toggleGeoFilter();
	    });
	  }
	  /**
	   * A helper method to wire up our auto complete on an input selector
	   * @param {string} inputSelector CSS selector to bind our auto complete component to
	   * @private
	   */
	  ;

	  _proto._initAutoComplete = function _initAutoComplete(inputSelector) {
	    var _this3 = this;

	    if (this._autocomplete) {
	      this._autocomplete.remove();
	    }

	    this._autocomplete = this.componentManager.create('AutoComplete', {
	      parentContainer: this._container,
	      name: this.name + ".autocomplete",
	      isFilterSearch: true,
	      container: '.js-yxt-GeoLocationFilter-autocomplete',
	      originalQuery: this.query,
	      inputEl: inputSelector,
	      verticalKey: this._config.verticalKey,
	      searchParameters: this.searchParameters,
	      onSubmit: function onSubmit(query, filter) {
	        return _this3._handleSubmit(query, filter);
	      }
	    });
	  };

	  _proto._handleSubmit = function _handleSubmit(query, filter) {
	    this.query = query;

	    this._saveDataToStorage(query, Filter.fromResponse(filter), "" + query);

	    this._enabled = false;
	  }
	  /**
	   * Toggles the static filter representing the user's location
	   * @private
	   */
	  ;

	  _proto._toggleGeoFilter = function _toggleGeoFilter() {
	    var _this4 = this;

	    if (!navigator.geolocation) {
	      this.setState({
	        geoError: true
	      });
	      return;
	    }

	    if (!this._enabled) {
	      this.setState({
	        geoLoading: true
	      });
	      navigator.geolocation.getCurrentPosition(function (position) {
	        var filter = _this4._buildFilter(position);

	        _this4._saveDataToStorage('', filter, 'Current Location', position);

	        _this4._enabled = true;

	        _this4.setState({});

	        _this4.core.storage["delete"](StorageKeys.QUERY + "." + _this4.name);

	        _this4.core.storage["delete"](StorageKeys.FILTER + "." + _this4.name);
	      }, function () {
	        return _this4._handleGeolocationError();
	      }, this._geolocationOptions);
	    }
	  };

	  _proto._handleGeolocationError = function _handleGeolocationError() {
	    this.setState({
	      geoError: true
	    });
	    var _this$_geolocationTim = this._geolocationTimeoutAlert,
	        enabled = _this$_geolocationTim.enabled,
	        message = _this$_geolocationTim.message;

	    if (enabled) {
	      window.alert(message);
	    }
	  };

	  _proto._removeFilterNode = function _removeFilterNode() {
	    this.core.storage["delete"](StorageKeys.QUERY + "." + this.name);
	    this.core.storage["delete"](StorageKeys.FILTER + "." + this.name);
	    this._enabled = false;
	    this.query = '';
	    this.core.clearStaticFilterNode(this.name);
	    this.setState();
	  };

	  _proto._buildFilterNode = function _buildFilterNode(filter, displayValue) {
	    var _this5 = this;

	    return FilterNodeFactory.from({
	      filter: filter,
	      metadata: {
	        displayValue: displayValue,
	        fieldName: this._config.title || this._config.label || "Location"
	      },
	      remove: function remove() {
	        return _this5._removeFilterNode();
	      }
	    });
	  }
	  /**
	   * Saves the provided filter under this component's name
	   * @param {string} query The query to save
	   * @param {Filter} filter The filter to save
	   * @param {string} displayValue The display value for the filter
	   * @param {Object} position The position to save
	   * @private
	   */
	  ;

	  _proto._saveDataToStorage = function _saveDataToStorage(query, filter, displayValue, position) {
	    this.core.storage.setWithPersist(StorageKeys.QUERY + "." + this.name, query);
	    this.core.storage.setWithPersist(StorageKeys.FILTER + "." + this.name, filter);

	    var filterNode = this._buildFilterNode(filter, displayValue);

	    this.core.setStaticFilterNodes(this.name, filterNode);

	    if (position) {
	      this.core.storage.set(StorageKeys.GEOLOCATION, {
	        lat: position.coords.latitude,
	        lng: position.coords.longitude,
	        radius: position.coords.accuracy
	      });
	    }

	    if (this._config.searchOnChange) {
	      this.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	    }
	  }
	  /**
	   * Given a position, construct a Filter object
	   * @param {Postition} position The position
	   * @returns {Filter}
	   * @private
	   */
	  ;

	  _proto._buildFilter = function _buildFilter(position) {
	    var _position$coords = position.coords,
	        latitude = _position$coords.latitude,
	        longitude = _position$coords.longitude,
	        accuracy = _position$coords.accuracy;
	    var radius = Math.max(accuracy, this._config.radius * METERS_PER_MILE);
	    return Filter.position(latitude, longitude, radius);
	  };

	  _createClass(GeoLocationComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.GEOLOCATION_FILTER;
	    }
	  }]);

	  return GeoLocationComponent;
	}(Component);

	/**
	 * Renders configuration options for sorting Vertical Results.
	 * TODO: how to deal with multiple instances of this component (and filters in general),
	 * ideally "identical" filters/sorts would be synced up.
	 */

	var SortOptionsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(SortOptionsComponent, _Component);

	  function SortOptionsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, assignDefaults(config), systemConfig) || this;
	    _this.options = _this._config.options;
	    _this.selectedOptionIndex = _this.getPersistedSelectedOptionIndex();
	    _this.options[_this.selectedOptionIndex].isSelected = true;
	    _this.hideExcessOptions = _this._config.showMore && _this.selectedOptionIndex < _this._config.showMoreLimit;
	    _this.searchOnChangeIsEnabled = _this._config.searchOnChange;
	    _this.showResetIsEnabled = _this._config.showReset;
	    _this.showReset = _this.showResetIsEnabled && _this.selectedOptionIndex !== 0;
	    _this.isNoResults = false;
	    /**
	     * This component should only render if there are search results, so it should listen
	     * to updates to vertical results and handle them accordingly.
	     */

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: function callback(verticalResults) {
	        var isSearchComplete = verticalResults.searchState === SearchStates.SEARCH_COMPLETE;

	        if (isSearchComplete) {
	          var isNoResults = verticalResults.resultsContext === ResultsContext.NO_RESULTS;

	          _this.handleVerticalResultsUpdate(isNoResults);
	        }
	      }
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.HISTORY_POP_STATE,
	      callback: function callback() {
	        var persistedOptionIndex = _this.getPersistedSelectedOptionIndex();

	        _this._updateSelectedOption(persistedOptionIndex);

	        _this.setState();
	      }
	    });

	    return _this;
	  }
	  /**
	   * Returns the option index matching the persisted sortBys, if one exists.
	   *
	   * @returns {number|undefined}
	   */


	  var _proto = SortOptionsComponent.prototype;

	  _proto.getPersistedSelectedOptionIndex = function getPersistedSelectedOptionIndex() {
	    var _context;

	    var persistedSortBys = this.core.storage.get(StorageKeys.SORT_BYS) || [];

	    var persistedIndex = findIndex$2(_context = this._config.options).call(_context, function (option) {
	      return find$3(persistedSortBys).call(persistedSortBys, function (persistedOption) {
	        return persistedOption.direction === option.direction && persistedOption.type === option.type && persistedOption.field === option.field;
	      });
	    });

	    return persistedIndex === -1 ? 0 : persistedIndex;
	  }
	  /**
	   * Handle updates to vertical results and trigger a re-render if necessary
	   *
	   * @param {boolean} isNoResults
	   */
	  ;

	  _proto.handleVerticalResultsUpdate = function handleVerticalResultsUpdate(isNoResults) {
	    var wasNoResults = this.isNoResults;
	    this.isNoResults = isNoResults; // Call setState (and therefore trigger a re-render) if the presence of search
	    // results has changed. By not always re-rendering, we maintain focus on the selected
	    // selected sort option

	    if (isNoResults !== wasNoResults) {
	      this.setState();
	    }
	  };

	  _proto.setState = function setState(data) {
	    if (data === void 0) {
	      data = {};
	    }

	    var options = this.options;

	    if (this.hideExcessOptions) {
	      var _context2;

	      options = slice$4(_context2 = this.options).call(_context2, 0, this._config.showMoreLimit);
	    }

	    _Component.prototype.setState.call(this, _extends({}, data, {
	      options: options,
	      hideExcessOptions: this.hideExcessOptions,
	      name: this.name,
	      showReset: this.showReset,
	      isNoResults: this.isNoResults
	    }));
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    // Handle radio button selections
	    var containerEl = DOM.query(this._container, '.yxt-SortOptions-fieldSet');
	    containerEl && DOM.on(containerEl, 'change', function (evt) {
	      return _this2.handleOptionSelection(_parseInt$2(evt.target.value));
	    }); // Register more/less button

	    if (this._config.showMore) {
	      var toggleEl = DOM.query(this._container, '.yxt-SortOptions-showToggle');
	      toggleEl && DOM.on(toggleEl, 'click', function () {
	        _this2.hideExcessOptions = !_this2.hideExcessOptions;

	        _this2.setState();
	      });
	    } // Register show reset button


	    if (this.showResetIsEnabled) {
	      var resetEl = DOM.query(this._container, '.yxt-SortOptions-reset');
	      resetEl && DOM.on(resetEl, 'click', function () {
	        _this2.handleOptionSelection(0);

	        _this2.setState();
	      });
	    } // Register apply button


	    if (!this.searchOnChangeIsEnabled) {
	      var applyEl = DOM.query(this._container, '.yxt-SortOptions-apply');
	      applyEl && DOM.on(applyEl, 'click', function () {
	        return _this2._sortResults();
	      });
	    }
	  };

	  _proto.handleOptionSelection = function handleOptionSelection(selectedOptionIndex) {
	    this._updateSelectedOption(selectedOptionIndex);

	    this._updateCheckedAttributes();

	    if (this.showResetIsEnabled) {
	      this.showReset = selectedOptionIndex !== 0;

	      this._showOrHideResetButton();
	    }

	    if (this.searchOnChangeIsEnabled) {
	      this._sortResults();
	    }
	  };

	  _proto._updateSelectedOption = function _updateSelectedOption(optionIndex) {
	    this.options[this.selectedOptionIndex].isSelected = false;
	    this.options[optionIndex].isSelected = true;
	    this.selectedOptionIndex = optionIndex;
	  }
	  /**
	   * Set the 'checked' attribute for the selected option and remove it for all others
	   */
	  ;

	  _proto._updateCheckedAttributes = function _updateCheckedAttributes() {
	    var _context3,
	        _this3 = this;

	    forEach$2(_context3 = this.options).call(_context3, function (option, optionIndex) {
	      var optionId = "#yxt-SortOptions-option_SortOptions_" + optionIndex;
	      var optionEl = DOM.query(_this3._container, optionId);

	      if (_this3.selectedOptionIndex === optionIndex) {
	        optionEl && optionEl.setAttribute('checked', '');
	      } else {
	        optionEl && optionEl.removeAttribute('checked', '');
	      }
	    });
	  }
	  /**
	   * Show or hide the reset button based on this.showReset
	   */
	  ;

	  _proto._showOrHideResetButton = function _showOrHideResetButton() {
	    var resetEl = DOM.query(this._container, '.yxt-SortOptions-reset');

	    if (this.showReset) {
	      resetEl.classList.remove('js-hidden');
	    } else if (!resetEl.classList.contains('js-hidden')) {
	      resetEl.classList.add('js-hidden');
	    }
	  };

	  _proto._sortResults = function _sortResults() {
	    var optionIndex = this.selectedOptionIndex;
	    var option = this.options[optionIndex]; // searchOnChange really means sort on change here, just that the sort is done through a search,
	    // This was done to have a consistent option name between filters.

	    if (this._config.storeOnChange && optionIndex === 0) {
	      this.core.clearSortBys();
	    } else if (this._config.storeOnChange) {
	      this.core.setSortBys(option);
	    }

	    this._search();

	    this._config.onChange(option);
	  }
	  /**
	   * Trigger a search with all filters in storage
	   */
	  ;

	  _proto._search = function _search() {
	    this.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	  };

	  SortOptionsComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'controls/sortoptions';
	  };

	  _createClass(SortOptionsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return ComponentTypes.SORT_OPTIONS;
	    }
	  }]);

	  return SortOptionsComponent;
	}(Component);

	function assignDefaults(config) {
	  var _context4;

	  var updatedConfig = _extends({}, config); // Optional, The label used for the “default” sort (aka the sort specified by the experience config").


	  updatedConfig.defaultSortLabel = config.defaultSortLabel || "Best Match"; // Array of search options, where an option has type, label, and if is type FIELD also a label and direction

	  if (!config.options) {
	    throw new AnswersBasicError('config.options are required', 'SortOptions');
	  }

	  var OPTION_TYPES = ['FIELD', 'RELEVANCE', 'ENTITY_DISTANCE'];

	  if (!isArray$3(config.options)) {
	    throw new AnswersBasicError('options must be an array of objects', 'SortOptions');
	  }

	  updatedConfig.options = map$2(_context4 = config.options).call(_context4, function (option) {
	    if (!option.label || !option.type) {
	      throw new AnswersBasicError("option.label and option.type are required option " + option, 'SortOptions');
	    }

	    var newOption = {
	      isSelected: false
	    };
	    newOption.label = option.label;
	    newOption.type = option.type;
	    var isField = indexOf$3(OPTION_TYPES).call(OPTION_TYPES, newOption.type) === 0;

	    if (isField && option.field && option.direction) {
	      newOption.field = option.field;
	      newOption.direction = option.direction;
	    } else if (isField) {
	      throw new AnswersBasicError("option.field and option.direction are required for option: " + option, 'SortOptions');
	    }

	    return newOption;
	  }); // Add default option to the front of the options array

	  updatedConfig.options.unshift({
	    label: updatedConfig.defaultSortLabel,
	    isSelected: false
	  }); // Optional, the selector used for options in the template

	  updatedConfig.optionSelector = config.optionSelector || 'yxt-SortOptions-optionSelector'; // Optional, if true, triggers a search on each change to a filter,
	  // if false the component also renders an apply button, defaults to false

	  updatedConfig.searchOnChange = config.searchOnChange === undefined ? true : config.searchOnChange; // Optional, show a reset button. Clicking it will always return the user to the default sorting option.

	  updatedConfig.showReset = config.showReset || false; // Optional, the label to use for the reset button

	  updatedConfig.resetLabel = config.resetLabel || "reset"; // Optional, the max number of filter options to show before collapsing extras

	  updatedConfig.showMoreLimit = config.showMoreLimit || 5; // Optional, allow collapsing excess sort options after a limit

	  updatedConfig.showMore = config.showMore === undefined ? true : config.showMore;
	  updatedConfig.showMore = updatedConfig.showMore && updatedConfig.options.length > updatedConfig.showMoreLimit; // Optional, the label to show for displaying more options

	  updatedConfig.showMoreLabel = config.showMoreLabel || "Show more"; // Optional, the label to show for displaying less options

	  updatedConfig.showLessLabel = config.showLessLabel || "Show less"; // Optional, the callback function to call when changed

	  updatedConfig.onChange = config.onChange || function () {}; // Optional, Top title for the sorting component


	  updatedConfig.label = config.label || "Sorting"; // Optional, when true component does not update storage
	  // possibly delegating that to a higher-order/composite component

	  updatedConfig.storeOnChange = config.storeOnChange === undefined ? true : config.storeOnChange;
	  updatedConfig.applyLabel = config.applyLabel || "Apply";
	  updatedConfig.verticalKey = config.verticalKey || ANSWERS.core.storage.get(StorageKeys.SEARCH_CONFIG).verticalKey;

	  if (!updatedConfig.verticalKey) {
	    throw new AnswersBasicError('vertical key is required', 'SortOptions');
	  } // note: showExpand and showNumberApplied explicitly not included, on the grounds that
	  // sorting should always be exposed to the user if added.


	  return updatedConfig;
	}

	function ownKeys$i(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; forEach$2(_context4 = ownKeys$i(Object(source), true)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context5; forEach$2(_context5 = ownKeys$i(Object(source))).call(_context5, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * EventTypes are explicit strings defined
	 * for what the server expects for analytics.
	 *
	 * @enum
	 */

	var EventTypes = {
	  THUMBS_UP: 'THUMBS_UP',
	  THUMBS_DOWN: 'THUMBS_DOWN'
	};
	var DEFAULT_CONFIG$4 = {
	  positiveFeedbackSrText: "This answered my question",
	  negativeFeedbackSrText: "This did not answer my question",
	  footerTextOnSubmission: "Thank you for your feedback!"
	};

	var DirectAnswerComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(DirectAnswerComponent, _Component);

	  function DirectAnswerComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$h(_objectSpread$h({}, DEFAULT_CONFIG$4), config), systemConfig) || this;
	    /**
	     * The user given config, without any defaults applied.
	     * @type {Object}
	     */

	    _this._userConfig = _objectSpread$h({}, config);
	    /**
	     * Recieve updates from storage based on this index
	     * @type {StorageKey}
	     */

	    _this.moduleId = StorageKeys.DIRECT_ANSWER;
	    /**
	     * The form used for submitting the feedback
	     * @type {string}
	     */

	    _this._formEl = config.formEl || '.js-directAnswer-feedback-form';
	    /**
	     * The `thumbs up` css selector to bind ui interaction to for reporting
	     * @type {string}
	     */

	    _this._thumbsUpSelector = config.thumbsUpSelector || '.js-directAnswer-thumbUp';
	    /**
	     * The `thumbs down` css selector to bind ui interaction to for reporting
	     * @type {string}
	     */

	    _this._thumbsDownSelector = config.thumbsDownSelector || '.js-directAnswer-thumbDown';
	    /**
	     * The display text for the View Details click to action link
	     * @type {string}
	     */

	    _this._viewDetailsText = config.viewDetailsText || "View Details";
	    /**
	     * The default custom direct answer card to use, when there are no matching card overrides.
	     * @type {string}
	     */

	    _this._defaultCard = config.defaultCard;
	    /**
	     * Card overrides, which choose a custom direct answer card based on fieldName, fieldType, and entityType.
	     * @type {Array<Object>}
	     */

	    _this._cardOverrides = config.cardOverrides || [];
	    /**
	     * Type options, which allows a card type to be specified based on the direct answer type.
	     * May contain cardOverrides.
	     *
	     * @example
	     * {
	     *   'FEATURED_SNIPPET': {
	     *      cardType: 'documentsearch-standard',
	     *      cardOverrides: [
	     *        {
	     *           entityType: 'Person',
	     *           cardType: 'custom-card'
	     *        }
	     *     ]
	     *   }
	     * }
	     *
	     * @type {Object}
	     */

	    _this._types = config.types;

	    _this._validateTypes();

	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  DirectAnswerComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/directanswer';
	  }
	  /**
	   * beforeMount, only display the direct answer component if it has data
	   */
	  ;

	  var _proto = DirectAnswerComponent.prototype;

	  _proto.beforeMount = function beforeMount() {
	    if (!this.hasState('answer')) {
	      return false;
	    }

	    return true;
	  }
	  /**
	   * When the DOM is constructed,
	   * we want to wire up the behavior for interacting with the quality feedback reporting (thumbsup/down)
	   */
	  ;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    var customCard = this.getState('customCard');
	    var feedbackSubmitted = this.getState('feedbackSubmitted') === true; // Avoid bindings if the feedback has previously been submitted or is using a custom card.

	    if (customCard || feedbackSubmitted) {
	      return this;
	    } // For WCAG compliance, the feedback should be a submittable form


	    DOM.on(this._formEl, 'submit', function (e) {
	      var formEl = e.target;
	      var checkedValue = DOM.query(formEl, 'input:checked').value === 'true';

	      _this2.reportQuality(checkedValue);

	      _this2.updateState({
	        feedbackSubmitted: true
	      });
	    }); // Is this actually necessary? I guess it's only necessary if the
	    // submit button is hidden.

	    DOM.on(this._thumbsUpSelector, 'click', function () {
	      DOM.trigger(_this2._formEl, 'submit');
	    });
	    DOM.on(this._thumbsDownSelector, 'click', function () {
	      DOM.trigger(_this2._formEl, 'submit');
	    });
	    var rtfElement = DOM.query(this._container, '.js-yxt-rtfValue');
	    rtfElement && DOM.on(rtfElement, 'click', function (e) {
	      return _this2._handleRtfClickAnalytics(e);
	    });
	  }
	  /**
	   * A click handler for links in a Rich Text Direct Answer. When such a link
	   * is clicked, an {@link AnalyticsEvent} needs to be fired.
	   *
	   * @param {MouseEvent} event The click event.
	   */
	  ;

	  _proto._handleRtfClickAnalytics = function _handleRtfClickAnalytics(event) {
	    if (!event.target.dataset.ctaType) {
	      return;
	    }

	    var ctaType = event.target.dataset.ctaType;
	    var relatedItem = this.getState('relatedItem');
	    var analyticsOptions = {
	      verticalKey: relatedItem.verticalConfigId,
	      directAnswer: true,
	      fieldName: this.getState('answer').fieldApiName,
	      searcher: 'UNIVERSAL',
	      entityId: relatedItem.data.id,
	      url: event.target.href
	    };
	    var analyticsEvent = new AnalyticsEvent(ctaType);
	    analyticsEvent.addOptions(analyticsOptions);
	    this.analyticsReporter.report(analyticsEvent);
	  }
	  /**
	   * updateState enables for partial updates (the delta between the old and new)
	   * @type {object} The new state to apply to the old
	   */
	  ;

	  _proto.updateState = function updateState(state) {
	    if (state === void 0) {
	      state = {};
	    }

	    var newState = _extends({}, this.getState(), state);

	    this.setState(newState);
	  };

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _extends({}, data, {
	      eventOptions: this.eventOptions(data),
	      viewDetailsText: this._viewDetailsText,
	      directAnswer: data,
	      customCard: this._getCard(data)
	    }));
	  };

	  _proto.eventOptions = function eventOptions(data) {
	    if (!data || keys$3(data).length === 0) {
	      return data;
	    }

	    return stringify$2({
	      verticalConfigId: data.relatedItem.verticalConfigId,
	      searcher: 'UNIVERSAL',
	      entityId: data.relatedItem.data.id,
	      ctaLabel: this._viewDetailsText.toUpperCase().replace(' ', '_')
	    });
	  }
	  /**
	   * Determines the card that should be used for the given direct answer.
	   *
	   * @param {Object} directAnswer The direct answer state
	   * @returns {string}
	   */
	  ;

	  _proto._getCard = function _getCard(directAnswer) {
	    if (this._types) {
	      return this._getCardBasedOnTypes(directAnswer);
	    } else if (this._cardOverrides.length > 0) {
	      return this._getCardBasedOnOverrides({
	        directAnswer: directAnswer,
	        overrides: this._cardOverrides,
	        fallback: this._defaultCard
	      });
	    } else {
	      return this._defaultCard;
	    }
	  }
	  /**
	   * Determines the card that should be used based on the types option
	   *
	   * @param {Object} directAnswer The direct answer state
	   * @returns {string}
	   */
	  ;

	  _proto._getCardBasedOnTypes = function _getCardBasedOnTypes(directAnswer) {
	    if (!('type' in directAnswer) || !(directAnswer.type in this._types)) {
	      return this._defaultCard;
	    }

	    var typeOptions = this._types[directAnswer.type];
	    var cardFallback = typeOptions.cardType || this._defaultCard;

	    if (typeOptions.cardOverrides) {
	      return this._getCardBasedOnOverrides({
	        directAnswer: directAnswer,
	        overrides: typeOptions.cardOverrides,
	        fallback: cardFallback
	      });
	    }

	    return cardFallback;
	  }
	  /**
	   * Returns the custom card type that should be used for the given direct answer.
	   *
	   * @param {Object} directAnswer The direct answer state
	   * @param {Object[]} overrides The overrides to search through
	   * @param {string} fallback The card to return if no match is found
	   * @returns {string}
	   */
	  ;

	  _proto._getCardBasedOnOverrides = function _getCardBasedOnOverrides(_ref) {
	    var _this3 = this;

	    var directAnswer = _ref.directAnswer,
	        overrides = _ref.overrides,
	        fallback = _ref.fallback;

	    var cardOverride = find$3(overrides).call(overrides, function (override) {
	      return _this3._overrideMatchesAnswer(override, directAnswer);
	    });

	    return cardOverride ? cardOverride.cardType : fallback;
	  }
	  /**
	   * Check whether a given cardOverride matches a given directAnswer.
	   *
	   * @param {Object} override
	   * @param {Object} directAnswer
	   * @returns {boolean}
	   */
	  ;

	  _proto._overrideMatchesAnswer = function _overrideMatchesAnswer(override, directAnswer) {
	    if (!keys$3(directAnswer).length) {
	      return true;
	    }

	    var directAnswerPropeties = {
	      type: directAnswer.type,
	      entityType: directAnswer.relatedItem.data.type,
	      fieldName: directAnswer.answer.fieldName,
	      fieldType: directAnswer.answer.fieldType
	    };

	    for (var _i = 0, _Object$entries = entries$5(override); _i < _Object$entries.length; _i++) {
	      var _Object$entries$_i = _Object$entries[_i],
	          propertyToMatch = _Object$entries$_i[0],
	          propertyValue = _Object$entries$_i[1];

	      if (propertyToMatch === 'cardType') {
	        continue;
	      }

	      if (directAnswerPropeties[propertyToMatch] !== propertyValue) {
	        return false;
	      }
	    }

	    return true;
	  }
	  /**
	   * Throws an error if the types config option is not formatted properly.
	   * @throws if validation fails
	   */
	  ;

	  _proto._validateTypes = function _validateTypes() {
	    var _context2;

	    if (!this._types) {
	      return;
	    }

	    var validateSupportedKeysOfObject = function validateSupportedKeysOfObject(supportedKeys, object) {
	      var _context;

	      forEach$2(_context = keys$3(object)).call(_context, function (key) {
	        if (!includes$4(supportedKeys).call(supportedKeys, key)) {
	          var supportedKeysString = supportedKeys.join(' and ');
	          throw new Error("The key '" + key + "' is not a supported option. Supported options include " + supportedKeysString + ".");
	        }
	      });
	    };

	    forEach$2(_context2 = entries$5(this._types)).call(_context2, function (_ref2) {
	      var _context3;

	      var directAnswerType = _ref2[0],
	          typeOptions = _ref2[1];
	      var supportedTypeOptions = ['cardType', 'cardOverrides'];
	      validateSupportedKeysOfObject(supportedTypeOptions, typeOptions);

	      if (!typeOptions.cardOverrides) {
	        return;
	      }

	      var supportedCardOverrideOptions = ['fieldName', 'entityType', 'fieldType', 'cardType'];

	      forEach$2(_context3 = typeOptions.cardOverrides).call(_context3, function (overrideOptions) {
	        validateSupportedKeysOfObject(supportedCardOverrideOptions, overrideOptions);
	      });
	    });
	  }
	  /**
	   * reportQuality will send the quality feedback to analytics
	   * @param {boolean} isGood true if the answer is what you were looking for
	   */
	  ;

	  _proto.reportQuality = function reportQuality(isGood) {
	    var eventType = isGood === true ? EventTypes.THUMBS_UP : EventTypes.THUMBS_DOWN;
	    var event = new AnalyticsEvent(eventType).addOptions({
	      directAnswer: true
	    });
	    this.analyticsReporter.report(event);
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    if (type === this.getState('customCard')) {
	      return _Component.prototype.addChild.call(this, this.getState('directAnswer'), type, _objectSpread$h(_objectSpread$h({}, this._userConfig), opts));
	    }

	    return _Component.prototype.addChild.call(this, data, type, opts);
	  };

	  _createClass(DirectAnswerComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'DirectAnswer';
	    }
	  }]);

	  return DirectAnswerComponent;
	}(Component);

	/**
	 * The AlternativeVertical is a model that is used to power the search
	 * suggestions info box. It's initialized through the configuration provided
	 * to the component.
	 */

	var AlternativeVertical = function AlternativeVertical(config) {
	  /**
	   * The name of the vertical that is exposed for the link
	   * @type {string}
	   */
	  this.label = config.label;

	  if (typeof this.label !== 'string') {
	    throw new AnswersConfigError('label is a required configuration option for verticalPage.', 'AlternativeVertical');
	  }
	  /**
	   * The complete URL, including the params
	   * @type {string}
	   */


	  this.url = config.url;

	  if (typeof this.url !== 'string') {
	    throw new AnswersConfigError('url is a required configuration option for verticalPage.', 'AlternativeVertical');
	  }
	  /**
	   * name of an icon from the default icon set
	   * @type {string}
	   */


	  this.iconName = config.iconName;
	  /**
	   * URL of an icon
	   * @type {string}
	   */

	  this.iconUrl = config.iconUrl;
	  /**
	   * Whether the vertical has an icon
	   * @type {string}
	   */

	  this.hasIcon = this.iconName || this.iconUrl;
	  /**
	   * The number of results to display next to each alternative
	   * vertical
	   * @type {number}
	   */

	  this.resultsCount = config.resultsCount;
	};

	function _createForOfIteratorHelperLoose$7(o, allowArrayLike) { var _context2; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context2 = it.next).call(_context2, it); }

	function _unsupportedIterableToArray$7(o, minLen) { var _context; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

	function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	var AlternativeVerticalsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(AlternativeVerticalsComponent, _Component);

	  function AlternativeVerticalsComponent(opts, systemOpts) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    if (systemOpts === void 0) {
	      systemOpts = {};
	    }

	    _this = _Component.call(this, opts, systemOpts) || this;
	    _this.moduleId = StorageKeys.ALTERNATIVE_VERTICALS;
	    /**
	     * Alternative verticals that have results for the current query
	     * This gets updated based on the server results
	     * @type {AlternativeVerticals}
	     * @private
	     */

	    _this._alternativeVerticals = opts.data && opts.data.alternativeVerticals || [];
	    /**
	     * Vertical pages config from global verticals config
	     * @type {VerticalPagesConfig}
	     * @private
	     */

	    _this._verticalsConfig = opts.verticalsConfig || [];
	    /**
	     * The name of the vertical that is exposed for the link
	     * @type {string}
	     */

	    _this._currentVerticalLabel = _this.getCurrentVerticalLabel(opts.verticalsConfig) || '';
	    /**
	     * The alternative vertical search suggestions, parsed from alternative verticals and
	     * the global verticals config.
	     * This gets updated based on the server results
	     * @type {AlternativeVertical[]}
	     */

	    _this.verticalSuggestions = _this._buildVerticalSuggestions(_this._alternativeVerticals, _this._verticalsConfig, _this.core.storage.get(StorageKeys.API_CONTEXT), _this.core.storage.get(StorageKeys.REFERRER_PAGE_URL));
	    /**
	     * The url to the universal page to link back to without query params
	     * @type {string|null}
	     */

	    _this._baseUniversalUrl = opts.baseUniversalUrl || '';
	    /**
	     * The url to the universal page to link back to with current query params
	     * @type {string|null}
	     */

	    _this._universalUrl = _this._getUniversalURL(_this._baseUniversalUrl, new SearchParams(_this.core.storage.getCurrentStateUrlMerged()));
	    /**
	     * Whether or not results are displaying, used to control language in the info box
	     * @type {boolean}
	     */

	    _this._isShowingResults = opts.isShowingResults || false;

	    var reRender = function reRender() {
	      _this.verticalSuggestions = _this._buildVerticalSuggestions(_this._alternativeVerticals, _this._verticalsConfig, _this.core.storage.get(StorageKeys.API_CONTEXT), _this.core.storage.get(StorageKeys.REFERRER_PAGE_URL));
	      _this._universalUrl = _this._getUniversalURL(_this._baseUniversalUrl, new SearchParams(_this.core.storage.getCurrentStateUrlMerged()));

	      _this.setState(_this.core.storage.get(StorageKeys.ALTERNATIVE_VERTICALS));
	    };

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.API_CONTEXT,
	      callback: reRender
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.SESSIONS_OPT_IN,
	      callback: reRender
	    });

	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  AlternativeVerticalsComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/alternativeverticals';
	  };

	  AlternativeVerticalsComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  var _proto = AlternativeVerticalsComponent.prototype;

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _extends({
	      verticalSuggestions: []
	    }, data, {
	      universalUrl: this._universalUrl,
	      verticalSuggestions: this.verticalSuggestions,
	      currentVerticalLabel: this._currentVerticalLabel,
	      isShowingResults: this._isShowingResults,
	      query: this.core.storage.get(StorageKeys.QUERY)
	    }));
	  };

	  _proto.getCurrentVerticalLabel = function getCurrentVerticalLabel(verticalsConfig) {
	    var thisVertical = find$3(verticalsConfig).call(verticalsConfig, function (config) {
	      return config.isActive || false;
	    });

	    return thisVertical ? thisVertical.label : '';
	  }
	  /**
	   * _buildVerticalSuggestions will construct an array of {AlternativeVertical}
	   * from alternative verticals and verticalPages configuration
	   * @param {object} alternativeVerticals alternativeVerticals server response
	   * @param {object} verticalsConfig the configuration to use
	   */
	  ;

	  _proto._buildVerticalSuggestions = function _buildVerticalSuggestions(alternativeVerticals, verticalsConfig, context, referrerPageUrl) {
	    var _this2 = this;

	    var verticals = [];
	    var params = new SearchParams(this.core.storage.getCurrentStateUrlMerged());

	    if (context) {
	      params.set(StorageKeys.API_CONTEXT, context);
	    }

	    if (typeof referrerPageUrl === 'string') {
	      params.set(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	    }

	    var sessionsOptIn = this.core.storage.get(StorageKeys.SESSIONS_OPT_IN);

	    if (sessionsOptIn && sessionsOptIn.setDynamically) {
	      params[StorageKeys.SESSIONS_OPT_IN] = sessionsOptIn.value;
	    }

	    var filteredParams = filterParamsForExperienceLink(params, function (types) {
	      return _this2.componentManager.getComponentNamesForComponentTypes(types);
	    });

	    var _loop = function _loop() {
	      var alternativeVertical = _step.value;
	      var verticalKey = alternativeVertical.verticalConfigId;

	      var matchingVerticalConfig = find$3(verticalsConfig).call(verticalsConfig, function (config) {
	        return config.verticalKey === verticalKey;
	      });

	      if (!matchingVerticalConfig || alternativeVertical.resultsCount < 1) {
	        return "continue";
	      }

	      verticals.push(new AlternativeVertical({
	        label: matchingVerticalConfig.label,
	        url: replaceUrlParams(matchingVerticalConfig.url, filteredParams),
	        iconName: matchingVerticalConfig.icon,
	        iconUrl: matchingVerticalConfig.iconUrl,
	        resultsCount: alternativeVertical.resultsCount
	      }));
	    };

	    for (var _iterator = _createForOfIteratorHelperLoose$7(alternativeVerticals), _step; !(_step = _iterator()).done;) {
	      var _ret = _loop();

	      if (_ret === "continue") continue;
	    }

	    return verticals;
	  }
	  /**
	   * Adds parameters that are dynamically set. Removes parameters for facets,
	   * filters, and pagination, which should not persist across the experience.
	   * @param {string} baseUrl The url append the appropriate params to. Note:
	   *                         params already on the baseUrl will be stripped
	   * @param {SearchParams} params The parameters to include in the experience URL
	   * @return {string} The formatted experience URL with appropriate query params
	   */
	  ;

	  _proto._getUniversalURL = function _getUniversalURL(baseUrl, params) {
	    var _this3 = this;

	    if (!baseUrl) {
	      return '';
	    }

	    params.set(StorageKeys.QUERY, this.core.storage.get(StorageKeys.QUERY));
	    var context = this.core.storage.get(StorageKeys.API_CONTEXT);

	    if (context) {
	      params.set(StorageKeys.API_CONTEXT, context);
	    }

	    var referrerPageUrl = this.core.storage.get(StorageKeys.REFERRER_PAGE_URL);

	    if (referrerPageUrl !== undefined) {
	      params.set(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	    }

	    var filteredParams = filterParamsForExperienceLink(params, function (types) {
	      return _this3.componentManager.getComponentNamesForComponentTypes(types);
	    });
	    return replaceUrlParams(baseUrl, filteredParams);
	  };

	  _createClass(AlternativeVerticalsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'AlternativeVerticals';
	    }
	  }]);

	  return AlternativeVerticalsComponent;
	}(Component);

	/**
	 * A MapProvider is an interface that represents that should be implemented
	 * in order to integrate with a Third Party Map provider for
	 * interactive maps. MapProviders are used by the MapComponent.
	 *
	 * Implementations should extend this interface.
	 */

	var MapProvider = /*#__PURE__*/function () {
	  function MapProvider(config) {
	    if (config === void 0) {
	      config = {};
	    }

	    /**
	     * The API Key used for interacting with the map provider
	     * @type {string}
	     */
	    this._apiKey = config.apiKey;
	    /**
	     * The zoom level of the map, defaults to 14
	     * @type {number}
	     */

	    this._zoom = config.zoom || 14;
	    /**
	     * The default coordinates to display if there are no results returned
	     * Only used if showEmptyMap is set to true
	     * @type {Object}
	     */

	    this._defaultPosition = config.defaultPosition || {
	      lat: 37.0902,
	      lng: -95.7129
	    };
	    /**
	     * Configuration for the behavior when there are no vertical results.
	     * @type {Object}
	     */

	    this._noResults = config.noResults || {};
	    /**
	     * Determines if an empty map should be shown when there are no results
	     * @type {boolean}
	     */

	    this._showEmptyMap = config.showEmptyMap || false;
	    /**
	     * A reference to the underlying map instance, created by the external lib.
	     * @type {number}
	     */

	    this._map = null;
	    /**
	     * Temporary boolean tracking whether or not the external JS library is loaded (see TODO below)
	     * @type {boolean}
	     */

	    this._isLoaded = false;
	    /**
	     * Callback to invoke when a pin is clicked. The clicked item(s) are passed to the callback
	     * @type {function}
	     */

	    this._onPinClick = config.onPinClick || null;
	    /**
	     * Callback to invoke when a pin is hovered. The hovered item is passed to the callback
	     * @type {function}
	     */

	    this._onPinMouseOver = config.onPinMouseOver || null;
	    /**
	     * Callback to invoke when a pin is no longer hovered after being hovered.
	     * The hovered item is passed to the callback
	     * @type {function}
	     */

	    this._onPinMouseOut = config.onPinMouseOut || null;
	    /**
	     * Callback to invoke once the Javascript is loaded
	     * @type {function}
	     */

	    this._onLoaded = config.onLoaded || function () {};
	    /**
	     * The custom configuration override to use for the map markers
	     * @type {Object|Function}
	     */


	    this._pinConfig = typeof config.pin === 'function' ? config.pin : _extends(MapProvider.DEFAULT_PIN_CONFIG, config.pin);
	    /**
	     * Determines whether or not to collapse pins at the same lat/lng
	     * @type {boolean}
	     */

	    this._collapsePins = config.collapsePins || false;
	    /**
	     * Locale of the map. MapComponent supplies the locale specifed by
	     * ANSWERS.init() by default
	     * @type {string}
	     */

	    this._locale = this._getValidatedLocale(config.locale);
	  }
	  /**
	   * Returns the locale if it passes validation, otherwise returns 'en'
	   * @param {string} locale
	   */


	  var _proto = MapProvider.prototype;

	  _proto._getValidatedLocale = function _getValidatedLocale(locale) {
	    if (locale.length < 2) {
	      console.error("Locale '" + locale + "' must include at least two characters. Falling back to 'en'");
	      return 'en';
	    }

	    return locale;
	  }
	  /**
	   * The default configuration to use for the map markers
	   * @type {Object}
	   * TODO(billy) Create a configuration model
	   */
	  ;

	  MapProvider.shouldHideMap = function shouldHideMap(mapData, resultsContext, showEmptyMap, visibleForNoResults) {
	    if (resultsContext === ResultsContext.NO_RESULTS && visibleForNoResults !== undefined) {
	      return !visibleForNoResults;
	    }

	    var hasEmptyMap = !mapData || mapData.mapMarkers.length <= 0;
	    return hasEmptyMap && !showEmptyMap;
	  };

	  _proto.onLoaded = function onLoaded(cb) {
	    if (typeof cb !== 'function') {
	      return;
	    }

	    this._onLoaded = cb;

	    if (this.isLoaded()) {
	      this._onLoaded();
	    }
	  };

	  _proto.isLoaded = function isLoaded() {
	    return this._isLoaded;
	  };

	  _proto.loadJS = function loadJS() {
	    throw new Error('Unimplemented Method: loadJS');
	  };

	  _proto.init = function init(mapData) {
	    // TODO(billy) This should be based off a promise that gets created from loadJS
	    throw new Error('Unimplemented Method: init');
	  }
	  /**
	   * Given a list of markers, combine markers with the same lat/lng into a single marker
	   * @param {object[]} markers The markers to collapse
	   */
	  ;

	  _proto._collapseMarkers = function _collapseMarkers(markers) {
	    var locationToItem = {};

	    forEach$2(markers).call(markers, function (m) {
	      locationToItem["" + m.latitude + m.longitude] ? locationToItem["" + m.latitude + m.longitude].push(m) : locationToItem["" + m.latitude + m.longitude] = [m];
	    });

	    var collapsedMarkers = [];

	    for (var _i = 0, _Object$entries = entries$5(locationToItem); _i < _Object$entries.length; _i++) {
	      var _Object$entries$_i = _Object$entries[_i],
	          _markers = _Object$entries$_i[1];

	      if (_markers.length > 1) {
	        var collapsedMarker = {
	          item: map$2(_markers).call(_markers, function (m) {
	            return m.item;
	          }),
	          label: _markers.length,
	          latitude: _markers[0].latitude,
	          longitude: _markers[0].longitude
	        };
	        collapsedMarkers.push(collapsedMarker);
	      } else {
	        collapsedMarkers.push(_markers[0]);
	      }
	    }

	    return collapsedMarkers;
	  };

	  _createClass(MapProvider, null, [{
	    key: "DEFAULT_PIN_CONFIG",
	    get: function get() {
	      return {
	        icon: {
	          anchor: null,
	          // e.g. { x: 1, y: 1 }
	          svg: null,
	          url: null,
	          scaledSize: null // e.g. { w: 20, h: 20 }

	        },
	        labelType: 'numeric'
	      };
	    }
	  }]);

	  return MapProvider;
	}();

	/* global google */

	/**
	 * GoogleMapProvider is an implementation of a MapProvider
	 * that handles the integration with the third party API to expose maps.
	 * @extends MapProvider
	 */

	var GoogleMapProvider = /*#__PURE__*/function (_MapProvider) {
	  _inheritsLoose(GoogleMapProvider, _MapProvider);

	  function GoogleMapProvider(opts) {
	    var _this;

	    _this = _MapProvider.call(this, opts) || this; // normalize because google's zoom is effectively 1 unit of difference away from mapbox zoom

	    _this._zoomOffset = 1;
	    _this._zoom += _this._zoomOffset;
	    _this._clientId = opts.clientId;
	    _this._signature = opts.signature;

	    if (!_this.hasValidClientCredentials() && !_this._apiKey) {
	      throw new Error('GoogleMapsProvider: Missing `apiKey` or {`clientId`, `signature`}');
	    }
	    /**
	     * Language of the map.
	     * @type {string}
	     */


	    _this._language = _this.getLanguage(_this._locale);
	    return _this;
	  }
	  /**
	   * Google Maps supports some language codes that are longer than two characters. If the
	   * locale matches one of these edge cases, use it. Otherwise, fallback on the first two
	   * characters of the locale.
	   * @param {string} localeStr Unicode locale
	   */


	  var _proto = GoogleMapProvider.prototype;

	  _proto.getLanguage = function getLanguage(localeStr) {
	    var googleMapsCustomLanguages = ['zh-CN', 'zn-HK', 'zh-TW', 'en-AU', 'en-GB', 'fr-CA', 'pt-BR', 'pt-PT', 'es-419'];
	    var locale = localeStr.replace('_', '-');

	    if (includes$4(googleMapsCustomLanguages).call(googleMapsCustomLanguages, locale)) {
	      return locale;
	    }

	    var language = locale.substring(0, 2);
	    return language;
	  };

	  _proto.loadJS = function loadJS() {
	    var self = this;

	    var onLoad = function onLoad() {
	      if (typeof self._onLoaded === 'function') {
	        self._onLoaded();
	      }
	    };

	    if (typeof google !== 'undefined') {
	      self._isLoaded = true;
	      onLoad();
	      return;
	    }

	    var script = DOM.query('#yext-map-js');

	    if (script) {
	      var onLoadFunc = script.onload;

	      script.onload = function () {
	        onLoadFunc();
	        onLoad();
	      };

	      return;
	    }

	    script = DOM.createEl('script', {
	      id: 'yext-map-js',
	      onload: function onload() {
	        self._isLoaded = true;
	        onLoad();
	      },
	      async: true,
	      src: "https://maps.googleapis.com/maps/api/js?" + self.generateCredentials() + "&language=" + self._language
	    });
	    DOM.append('body', script);
	  };

	  _proto.generateCredentials = function generateCredentials() {
	    if (this.hasValidClientCredentials()) {
	      return "client=" + this._clientId;
	    } else {
	      return "key=" + this._apiKey;
	    }
	  };

	  _proto.hasValidClientCredentials = function hasValidClientCredentials() {
	    return this._clientId;
	  };

	  _proto.init = function init(el, mapData, resultsContext) {
	    var _this2 = this;

	    if (MapProvider.shouldHideMap(mapData, resultsContext, this._showEmptyMap, this._noResults.visible)) {
	      this._map = null;
	      return this;
	    } // NOTE(billy) This timeout is a hack for dealing with async nature.
	    // Only here for demo purposes, so we'll fix later.


	    setTimeout$2(function () {
	      var container = DOM.query(el);
	      _this2.map = new google.maps.Map(container, {
	        zoom: _this2._zoom,
	        center: _this2.getCenterMarker(mapData)
	      }); // Apply our search data to our GoogleMap

	      if (mapData && mapData.mapMarkers.length) {
	        (function () {
	          var collapsedMarkers = _this2._collapsePins ? _this2._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
	          var googleMapMarkerConfigs = GoogleMapMarkerConfig.from(collapsedMarkers, _this2._pinConfig, map$2(_this2));
	          var bounds = new google.maps.LatLngBounds();

	          var _loop = function _loop(i) {
	            var marker = new google.maps.Marker(googleMapMarkerConfigs[i]);

	            if (_this2._onPinClick) {
	              marker.addListener('click', function () {
	                return _this2._onPinClick(collapsedMarkers[i].item);
	              });
	            }

	            if (_this2._onPinMouseOver) {
	              marker.addListener('mouseover', function () {
	                return _this2._onPinMouseOver(collapsedMarkers[i].item);
	              });
	            }

	            if (_this2._onPinMouseOut) {
	              marker.addListener('mouseout', function () {
	                return _this2._onPinMouseOut(collapsedMarkers[i].item);
	              });
	            }

	            bounds.extend(marker.position);
	          };

	          for (var i = 0; i < googleMapMarkerConfigs.length; i++) {
	            _loop(i);
	          }

	          if (googleMapMarkerConfigs.length >= 2) {
	            map$2(_this2).fitBounds(bounds);
	          }
	        })();
	      }
	    }, 100);
	  };

	  _proto.getCenterMarker = function getCenterMarker(mapData) {
	    return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? {
	      lng: mapData.mapCenter.longitude,
	      lat: mapData.mapCenter.latitude
	    } : {
	      lng: this._defaultPosition.lng,
	      lat: this._defaultPosition.lat
	    };
	  };

	  return GoogleMapProvider;
	}(MapProvider); // TODO(billy) Move to own class
	var GoogleMapMarkerConfig = /*#__PURE__*/function () {
	  function GoogleMapMarkerConfig(opts) {
	    /**
	     * A reference to the google map, that the marker is appended to
	     * @type {GoogleMap}
	     */
	    this.map = map$2(opts) || undefined;
	    /**
	     * The coordinates of the marker (lat/lng)
	     * @type {Object}
	     */

	    this.position = opts.position || {
	      lat: undefined,
	      lng: undefined
	    };
	    /**
	     * The properties/settings of the icon used for the marker
	     * e.g. {
	     *        anchor: { x: 0, y: 0 }
	     *        url: 'path/to/url.jpg'
	     *        scaledSize: { w: 0, h: 0 }
	     *       }
	     *
	     * @type {object}
	     */

	    this.icon = opts.icon || undefined;
	    /**
	     * The label of the marker to use
	     * @type {string}
	     */

	    this.label = opts.label || undefined;
	  }
	  /**
	   * Serializes an array of marker configs
	   * @param {GoogleMapMarkerConfig[]} googleMapMarkerConfigs
	   * @returns {string[]}
	   */


	  GoogleMapMarkerConfig.serialize = function serialize(googleMapMarkerConfigs) {
	    var serializedMarkers = [];

	    forEach$2(googleMapMarkerConfigs).call(googleMapMarkerConfigs, function (marker) {
	      serializedMarkers.push("markers=label:" + marker.label + "|" + marker.position.lat + "," + marker.position.lng);
	    });

	    return serializedMarkers.join('&');
	  }
	  /**
	   * Converts the storage data model of markers into GoogleAPIMarker
	   * @param {object[]} markers The data of the marker
	   * @param {(Object|function)} pinConfig The configuration to apply to the marker
	   * @param {GoogleMap} map reference to the google map to apply the marker to
	   * @returns {GoogleMapMarkerConfig[]}
	   */
	  ;

	  GoogleMapMarkerConfig.from = function from(markers, pinConfig, map) {
	    var googleMapMarkerConfigs = [];

	    if (!isArray$3(markers)) {
	      markers = [markers];
	    }

	    forEach$2(markers).call(markers, function (marker) {
	      // Support configuration as a function
	      var pinConfigObj = pinConfig;

	      if (typeof pinConfig === 'function') {
	        pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
	      } // Transform our Configuration Object into the expected
	      // Google API format.


	      var icon = {};

	      if (pinConfigObj.anchor) {
	        icon.anchor = google.maps.Point(pinConfigObj.anchor.x, pinConfigObj.anchor.y);
	      }

	      if (pinConfigObj.scaledSize) {
	        icon.scaledSize = new google.maps.Size(pinConfigObj.scaledSize.w, pinConfigObj.scaledSize.h);
	      }

	      if (pinConfigObj.url) {
	        icon.url = pinConfigObj.url;
	      }

	      if (pinConfigObj.svg) {
	        icon.url = "data:image/svg+xml;charset=utf-8, " + encodeURIComponent(pinConfigObj.svg);
	      }

	      var label;

	      if (pinConfigObj.label) {
	        label = pinConfigObj.label;
	      } else {
	        label = marker.label.toString();
	      } // NOTE(billy) Google maps doesn't handle empty icon objects nicely
	      // Make google maps happy if no settings for icon are provided;


	      if (keys$3(icon).length === 0) {
	        icon = undefined;
	      }

	      googleMapMarkerConfigs.push(new GoogleMapMarkerConfig({
	        map: map,
	        position: {
	          lat: marker.latitude,
	          lng: marker.longitude
	        },
	        icon: icon,
	        label: label
	      }));
	    });

	    return googleMapMarkerConfigs;
	  };

	  return GoogleMapMarkerConfig;
	}();

	var mapboxGlLanguage = createCommonjsModule(function (module) {
	/**
	 * Create a new [Mapbox GL JS plugin](https://www.mapbox.com/blog/build-mapbox-gl-js-plugins/) that
	 * modifies the layers of the map style to use the 'text-field' that matches the browser language.
	 * @constructor
	 * @param {object} options - Options to configure the plugin.
	 * @param {string[]} [options.supportedLanguages] - List of supported languages
	 * @param {Function} [options.languageTransform] - Custom style transformation to apply
	 * @param {RegExp} [options.languageField=/^\{name/] - RegExp to match if a text-field is a language field
	 * @param {Function} [options.getLanguageField] - Given a language choose the field in the vector tiles
	 * @param {string} [options.languageSource] - Name of the source that contains the different languages.
	 * @param {string} [options.defaultLanguage] - Name of the default language to initialize style after loading.
	 * @param {string[]} [options.excludedLayerIds] - Name of the layers that should be excluded from translation.
	 */
	function MapboxLanguage(options) {
	  options = Object.assign({}, options);
	  if (!(this instanceof MapboxLanguage)) {
	    throw new Error('MapboxLanguage needs to be called with the new keyword');
	  }

	  this.setLanguage = this.setLanguage.bind(this);
	  this._initialStyleUpdate = this._initialStyleUpdate.bind(this);

	  this._defaultLanguage = options.defaultLanguage;
	  this._isLanguageField = options.languageField || /^\{name/;
	  this._getLanguageField = options.getLanguageField || function nameField(language) {
	    return language === 'mul' ? '{name}' : '{name_' + language + '}';
	  };
	  this._languageSource = options.languageSource || null;
	  this._languageTransform = options.languageTransform || function (style, language) {
	    if (language === 'ar') {
	      return noSpacing(style);
	    } else {
	      return standardSpacing(style);
	    }
	  };
	  this._excludedLayerIds = options.excludedLayerIds || [];
	  this.supportedLanguages = options.supportedLanguages || ['ar', 'en', 'es', 'fr', 'de', 'ja', 'ko', 'mul', 'pt', 'ru', 'zh'];
	}

	function standardSpacing(style) {
	  var changedLayers = style.layers.map(function (layer) {
	    if (!(layer.layout || {})['text-field']) return layer;
	    var spacing = 0;
	    if (layer['source-layer'] === 'state_label') {
	      spacing = 0.15;
	    }
	    if (layer['source-layer'] === 'marine_label') {
	      if (/-lg/.test(layer.id)) {
	        spacing = 0.25;
	      }
	      if (/-md/.test(layer.id)) {
	        spacing = 0.15;
	      }
	      if (/-sm/.test(layer.id)) {
	        spacing = 0.1;
	      }
	    }
	    if (layer['source-layer'] === 'place_label') {
	      if (/-suburb/.test(layer.id)) {
	        spacing = 0.15;
	      }
	      if (/-neighbour/.test(layer.id)) {
	        spacing = 0.1;
	      }
	      if (/-islet/.test(layer.id)) {
	        spacing = 0.01;
	      }
	    }
	    if (layer['source-layer'] === 'airport_label') {
	      spacing = 0.01;
	    }
	    if (layer['source-layer'] === 'rail_station_label') {
	      spacing = 0.01;
	    }
	    if (layer['source-layer'] === 'poi_label') {
	      if (/-scalerank/.test(layer.id)) {
	        spacing = 0.01;
	      }
	    }
	    if (layer['source-layer'] === 'road_label') {
	      if (/-label-/.test(layer.id)) {
	        spacing = 0.01;
	      }
	      if (/-shields/.test(layer.id)) {
	        spacing = 0.05;
	      }
	    }
	    return Object.assign({}, layer, {
	      layout: Object.assign({}, layer.layout, {
	        'text-letter-spacing': spacing
	      })
	    });
	  });

	  return Object.assign({}, style, {
	    layers: changedLayers
	  });
	}

	function noSpacing(style) {
	  var changedLayers = style.layers.map(function (layer) {
	    if (!(layer.layout || {})['text-field']) return layer;
	    var spacing = 0;
	    return Object.assign({}, layer, {
	      layout: Object.assign({}, layer.layout, {
	        'text-letter-spacing': spacing
	      })
	    });
	  });

	  return Object.assign({}, style, {
	    layers: changedLayers
	  });
	}

	function isNameStringField(isLangField, property) {
	  return typeof property === 'string' && isLangField.test(property);
	}

	function isNameFunctionField(isLangField, property) {
	  return property.stops && property.stops.filter(function (stop) {
	    return isLangField.test(stop[1]);
	  }).length > 0;
	}

	function adaptPropertyLanguage(isLangField, property, languageFieldName) {
	  if (isNameStringField(isLangField, property)) return languageFieldName;
	  if (isNameFunctionField(isLangField, property)) {
	    var newStops = property.stops.map(function (stop) {
	      if (isLangField.test(stop[1])) {
	        return [stop[0], languageFieldName];
	      }
	      return stop;
	    });
	    return Object.assign({}, property, {
	      stops: newStops
	    });
	  }
	  return property;
	}

	function changeLayerTextProperty(isLangField, layer, languageFieldName, excludedLayerIds) {
	  if (layer.layout && layer.layout['text-field'] && excludedLayerIds.indexOf(layer.id) === -1) {
	    return Object.assign({}, layer, {
	      layout: Object.assign({}, layer.layout, {
	        'text-field': adaptPropertyLanguage(isLangField, layer.layout['text-field'], languageFieldName)
	      })
	    });
	  }
	  return layer;
	}

	function findStreetsSource(style) {
	  var sources = Object.keys(style.sources).filter(function (sourceName) {
	    var source = style.sources[sourceName];
	    return /mapbox-streets-v\d/.test(source.url);
	  });
	  return sources[0];
	}

	/**
	 * Explicitly change the language for a style.
	 * @param {object} style - Mapbox GL style to modify
	 * @param {string} language - The language iso code
	 * @returns {object} the modified style
	 */
	MapboxLanguage.prototype.setLanguage = function (style, language) {
	  if (this.supportedLanguages.indexOf(language) < 0) throw new Error('Language ' + language + ' is not supported');
	  var streetsSource = this._languageSource || findStreetsSource(style);
	  if (!streetsSource) return style;

	  var field = this._getLanguageField(language);
	  var isLangField = this._isLanguageField;
	  var excludedLayerIds = this._excludedLayerIds;
	  var changedLayers = style.layers.map(function (layer) {
	    if (layer.source === streetsSource) return changeLayerTextProperty(isLangField, layer, field, excludedLayerIds);
	    return layer;
	  });

	  var languageStyle = Object.assign({}, style, {
	    layers: changedLayers
	  });

	  return this._languageTransform(languageStyle, language);
	};

	MapboxLanguage.prototype._initialStyleUpdate = function () {
	  var style = this._map.getStyle();
	  var language = this._defaultLanguage || browserLanguage(this.supportedLanguages);

	  // We only update the style once
	  this._map.off('styledata', this._initialStyleUpdate);
	  this._map.setStyle(this.setLanguage(style, language));
	};

	function browserLanguage(supportedLanguages) {
	  var language = navigator.languages ? navigator.languages[0] : (navigator.language || navigator.userLanguage);
	  var parts = language.split('-');
	  var languageCode = language;
	  if (parts.length > 1) {
	    languageCode = parts[0];
	  }
	  if (supportedLanguages.indexOf(languageCode) > -1) {
	    return languageCode;
	  }
	  return null;
	}

	MapboxLanguage.prototype.onAdd = function (map) {
	  this._map = map;
	  this._map.on('styledata', this._initialStyleUpdate);
	  this._container = document.createElement('div');
	  return this._container;
	};

	MapboxLanguage.prototype.onRemove = function () {
	  this._map.off('styledata', this._initialStyleUpdate);
	  this._map = undefined;
	};

	{
	  module.exports = MapboxLanguage;
	}
	});

	/* global mapboxgl */

	/**
	 * MapBoxMapProvider is an implementation of a MapProvider
	 * that handles the integration with the third party API to expose maps.
	 * @extends MapProvider
	 */

	var MapBoxMapProvider = /*#__PURE__*/function (_MapProvider) {
	  _inheritsLoose(MapBoxMapProvider, _MapProvider);

	  function MapBoxMapProvider(opts, systemOpts) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    if (systemOpts === void 0) {
	      systemOpts = {};
	    }

	    _this = _MapProvider.call(this, opts, systemOpts) || this;
	    /**
	     * Language of the map.
	     * @type {string}
	     */

	    _this._language = _this._locale.substring(0, 2);
	    return _this;
	  }
	  /**
	   * Load the external JS Library
	   * @param {function} onLoad An optional callback to invoke once the JS is loaded.
	   */


	  var _proto = MapBoxMapProvider.prototype;

	  _proto.loadJS = function loadJS(onLoad) {
	    var _this2 = this;

	    var script = DOM.createEl('script', {
	      id: 'yext-map-js',
	      onload: function onload() {
	        _this2._isLoaded = true;
	        mapboxgl.accessToken = _this2._apiKey;

	        if (typeof onLoad === 'function') {
	          onLoad();
	        }

	        if (typeof _this2._onLoaded === 'function') {
	          _this2._onLoaded();
	        }
	      },
	      async: true,
	      src: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.js'
	    });
	    var css = DOM.createEl('link', {
	      id: 'yext-map-css',
	      rel: 'stylesheet',
	      href: 'https://api.mapbox.com/mapbox-gl-js/v0.44.1/mapbox-gl.css'
	    });
	    DOM.append('body', css);
	    DOM.append('body', script);
	  };

	  _proto.init = function init(el, mapData, resultsContext) {
	    var _this3 = this;

	    if (MapProvider.shouldHideMap(mapData, resultsContext, this._showEmptyMap, this._noResults.visible)) {
	      this._map = null;
	      return this;
	    }

	    var container = DOM.query(el);
	    this._map = new mapboxgl.Map({
	      container: container,
	      zoom: this._zoom,
	      style: 'mapbox://styles/mapbox/streets-v9',
	      center: this.getCenterMarker(mapData)
	    });

	    this._map.addControl(new mapboxGlLanguage({
	      defaultLanguage: this._language
	    }));

	    if (mapData && mapData.mapMarkers.length) {
	      (function () {
	        var collapsedMarkers = _this3._collapsePins ? _this3._collapseMarkers(mapData.mapMarkers) : mapData.mapMarkers;
	        var mapboxMapMarkerConfigs = MapBoxMarkerConfig.from(collapsedMarkers, _this3._pinConfig, _this3._map);
	        var bounds = new mapboxgl.LngLatBounds();

	        var _loop = function _loop(i) {
	          var wrapper = mapboxMapMarkerConfigs[i].wrapper;
	          var coords = new mapboxgl.LngLat(mapboxMapMarkerConfigs[i].position.longitude, mapboxMapMarkerConfigs[i].position.latitude);
	          var marker = new mapboxgl.Marker(wrapper).setLngLat(coords);
	          bounds.extend(marker.getLngLat());
	          marker.addTo(_this3._map);

	          if (_this3._onPinClick) {
	            marker.getElement().addEventListener('click', function () {
	              return _this3._onPinClick(collapsedMarkers[i].item);
	            });
	          }

	          if (_this3._onPinMouseOver) {
	            marker.getElement().addEventListener('mouseover', function () {
	              return _this3._onPinMouseOver(collapsedMarkers[i].item);
	            });
	          }

	          if (_this3._onPinMouseOut) {
	            marker.getElement().addEventListener('mouseout', function () {
	              return _this3._onPinMouseOut(collapsedMarkers[i].item);
	            });
	          }
	        };

	        for (var i = 0; i < mapboxMapMarkerConfigs.length; i++) {
	          _loop(i);
	        }

	        if (mapboxMapMarkerConfigs.length >= 2) {
	          _this3._map.fitBounds(bounds, {
	            padding: 50
	          });
	        }
	      })();
	    }
	  };

	  _proto.getCenterMarker = function getCenterMarker(mapData) {
	    return mapData && mapData.mapCenter && mapData.mapCenter.longitude && mapData.mapCenter.latitude ? [mapData.mapCenter.longitude, mapData.mapCenter.latitude] : {
	      lng: this._defaultPosition.lng,
	      lat: this._defaultPosition.lat
	    };
	  };

	  return MapBoxMapProvider;
	}(MapProvider);
	var MapBoxMarkerConfig = /*#__PURE__*/function () {
	  function MapBoxMarkerConfig(opts) {
	    /**
	     * A reference to the mapbox map, that the marker is appended to
	     * @type {MapBox}
	     */
	    this.map = map$2(opts) || undefined;
	    /**
	     * The coordinates of the marker (lat/lng)
	     * @type {Object}
	     */

	    this.position = opts.position || {
	      latitude: undefined,
	      longitude: undefined
	    };
	    /**
	     * The html element to be used as the map marker
	     * @type {object}
	     */

	    this.wrapper = opts.wrapper || undefined;
	    /**
	     * The label of the marker to use
	     * @type {string}
	     */

	    this.label = opts.label || undefined;
	    /**
	     * The url of the pin for the static map
	     * @type {string}
	     */

	    this.staticMapPin = opts.staticMapPin || undefined;
	  }
	  /**
	   * Serializes an array of marker configs
	   * @param {MapBoxMarkerConfig[]} mapboxMapMarkerConfigs
	   * @returns {string[]}
	   */


	  MapBoxMarkerConfig.serialize = function serialize(mapboxMapMarkerConfigs) {
	    var serializedMarkers = [];

	    forEach$2(mapboxMapMarkerConfigs).call(mapboxMapMarkerConfigs, function (marker) {
	      if (marker.staticMapPin) {
	        serializedMarkers.push("url-" + marker.staticMapPin + "(" + marker.position.longitude + "," + marker.position.latitude + ")");
	      } else {
	        serializedMarkers.push("pin-s-" + marker.label + "(" + marker.position.longitude + "," + marker.position.latitude + ")");
	      }
	    });

	    return serializedMarkers.join(',');
	  }
	  /**
	   * Converts the storage data model of markers into MapBoxMarkerConfig
	   * @param {MapBox} A reference to the mapbox map to apply the marker to
	   * @param {object[]} markers The data of the marker
	   * @param {Object} pinConfig The configuration to apply to the marker
	   * @returns {MapBoxMarkerConfig[]}
	   */
	  ;

	  MapBoxMarkerConfig.from = function from(markers, pinConfig, map) {
	    var mapboxMapMarkerConfigs = [];

	    if (!isArray$3(markers)) {
	      markers = [markers];
	    }

	    forEach$2(markers).call(markers, function (marker) {
	      // Support configuration as a function
	      var pinConfigObj = pinConfig;

	      if (typeof pinConfig === 'function') {
	        pinConfigObj = pinConfig(marker.item, MapProvider.DEFAULT_PIN_CONFIG, marker);
	      }

	      var wrapper = pinConfigObj.wrapper ? pinConfigObj.wrapper : null;
	      var staticMapPin = pinConfigObj.staticMapPin ? pinConfigObj.staticMapPin : null;
	      mapboxMapMarkerConfigs.push(new MapBoxMarkerConfig({
	        map: map,
	        position: {
	          latitude: marker.latitude,
	          longitude: marker.longitude
	        },
	        wrapper: wrapper,
	        label: marker.label,
	        staticMapPin: staticMapPin
	      }));
	    });

	    return mapboxMapMarkerConfigs;
	  };

	  return MapBoxMarkerConfig;
	}();

	function ownKeys$j(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$j(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$j(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var ProviderTypes = {
	  google: GoogleMapProvider,
	  mapbox: MapBoxMapProvider
	};

	var MapComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(MapComponent, _Component);

	  function MapComponent(opts, systemOpts) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    if (systemOpts === void 0) {
	      systemOpts = {};
	    }

	    _this = _Component.call(this, opts, systemOpts) || this;
	    /**
	     * Bind this component to listen to the storage based on this key
	     */

	    _this.moduleId = StorageKeys.VERTICAL_RESULTS;
	    /**
	     * Configuration for the behavior when there are no vertical results.
	     */

	    _this._noResults = _objectSpread$i({
	      displayAllResults: false,
	      visible: undefined,
	      template: ''
	    }, opts.noResults || _this.core.storage.get(StorageKeys.NO_RESULTS_CONFIG));
	    /**
	     * An aliased used to determine the type of map provider to use
	     * @type {string}
	     */

	    _this._mapProvider = opts.mapProvider;

	    if (!_this._mapProvider || !(_this._mapProvider.toLowerCase() in ProviderTypes)) {
	      throw new Error('MapComponent: Invalid Map Provider; must be `google` or `mapBox`');
	    }
	    /**
	     * A reference to an instance of the {MapProvider} that's constructed
	     * @type {MapProvider}
	     */


	    _this._map = null;
	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  MapComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/map';
	  } // TODO(billy) Make ProviderTypes a factory class
	  ;

	  var _proto = MapComponent.prototype;

	  _proto.getProviderInstance = function getProviderInstance(type) {
	    var _config = _objectSpread$i(_objectSpread$i({
	      locale: this.core.storage.get(StorageKeys.LOCALE)
	    }, this._config), {}, {
	      noResults: this._noResults
	    });

	    return new ProviderTypes[type.toLowerCase()](_config);
	  };

	  _proto.onCreate = function onCreate() {
	    this._map = this.getProviderInstance(this._mapProvider);

	    this._map.loadJS();
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    this._map.onLoaded(function () {
	      _this2._map.init(_this2._container, _this2.getState('map'), _this2.getState('resultsContext'));
	    });
	  };

	  _proto.setState = function setState(data, val) {
	    if (keys$3(data).length === 0) {
	      return this;
	    }

	    if (data.resultsContext === ResultsContext.NO_RESULTS && !this._noResults.displayAllResults) {
	      data = {
	        resultsContext: data.resultsContext
	      };
	    }

	    return _Component.prototype.setState.call(this, data, val);
	  };

	  _createClass(MapComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'Map';
	    }
	  }]);

	  return MapComponent;
	}(Component);

	var cardTemplates = {
	  Standard: 'cards/standard',
	  Accordion: 'cards/accordion',
	  Legacy: 'cards/legacy'
	};
	var cardTypes = {
	  Standard: 'StandardCard',
	  Accordion: 'AccordionCard',
	  Legacy: 'LegacyCard'
	};

	function ownKeys$k(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$k(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$k(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var CardConfig = function CardConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);
	  /**
	   * The card type to use
	   * @type {string}
	   */


	  this.cardType = config.cardType || 'Standard';
	  /**
	   * Data mappings is a function specified in the config
	   * that returns config based on the data passed into card
	   * @type {Function}
	   */

	  this.dataMappings = config.dataMappings || function () {};
	  /**
	   * Either a function that spits out an array of CTA config objects or an array of CTA config objects
	   * or api fieldnames
	   * @type {Function|Array<Object|string>}
	   */


	  this.callsToAction = config.callsToAction || [];
	  /**
	   * The index of the card.
	   * @type {number}
	   */

	  this._index = config._index || 0;
	  /**
	   * Whether this card is part of a universal search
	   */

	  this.isUniversal = config.isUniversal || false;
	};

	var CardComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(CardComponent, _Component);

	  function CardComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, new CardConfig(config), systemConfig) || this;
	    /**
	     * config.data comes from the data-prop attribute passed in
	     * from the parent component.
	     * @type {Object}
	     */

	    var data = config.data || {};
	    /**
	     * The result data for this card.
	     * @type {Result}
	     */

	    _this.result = data.result || {};
	    /**
	     * Vertical key for the search.
	     * @type {string}
	     */

	    _this.verticalKey = data.verticalKey;
	    return _this;
	  }

	  var _proto = CardComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    var rtfElement = DOM.query(this._container, '.js-yxt-rtfValue');

	    if (rtfElement) {
	      var fieldName = rtfElement.dataset.fieldName;
	      DOM.on(rtfElement, 'click', function (e) {
	        return _this2._handleRtfClickAnalytics(e, fieldName);
	      });
	    }
	  }
	  /**
	   * A click handler for links in a Rich Text attriubte. When such a link is
	   * clicked, an {@link AnalyticsEvent} needs to be fired.
	   *
	   * @param {MouseEvent} event The click event.
	   * @param {string} fieldName The name of the Rich Text field used in the
	   *                           attriubte.
	   */
	  ;

	  _proto._handleRtfClickAnalytics = function _handleRtfClickAnalytics(event, fieldName) {
	    var ctaType = event.target.dataset.ctaType;

	    if (!ctaType) {
	      return;
	    }

	    var analyticsOptions = {
	      directAnswer: false,
	      verticalKey: this._config.data.verticalKey,
	      searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL',
	      entityId: this._config.data.result.id,
	      url: event.target.href
	    };

	    if (!fieldName) {
	      console.warn('Field name not provided for RTF click analytics');
	    } else {
	      analyticsOptions.fieldName = fieldName;
	    }

	    var analyticsEvent = new AnalyticsEvent(ctaType);
	    analyticsEvent.addOptions(analyticsOptions);
	    this.analyticsReporter.report(analyticsEvent);
	  };

	  _proto.setState = function setState(data) {
	    var cardType = this._config.cardType; // Use the cardType as component name if it is not a built-in type

	    var cardComponentName = cardTypes[cardType] || cardType;
	    return _Component.prototype.setState.call(this, _objectSpread$j(_objectSpread$j({}, data), {}, {
	      result: this.result,
	      cardType: cardComponentName
	    }));
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    var updatedData = {
	      verticalKey: this.verticalKey,
	      result: data
	    };

	    var newOpts = _objectSpread$j({
	      showOrdinal: this._config.showOrdinal,
	      dataMappings: this._config.dataMappings,
	      callsToAction: this._config.callsToAction,
	      verticalKey: this._config.verticalKey,
	      _index: this._config._index,
	      isUniversal: this._config.isUniversal,
	      modifier: this._config.modifier
	    }, opts);

	    return _Component.prototype.addChild.call(this, updatedData, type, newOpts);
	  }
	  /**
	   * Used by children card components like StandardCardComponent to
	   * apply given template mappings as config.
	   * @param {Result} result
	   * @param {Object|Function} dataMappings
	   */
	  ;

	  CardComponent.applyDataMappings = function applyDataMappings(result, dataMappings) {
	    var config = {};

	    if (typeof dataMappings === 'function') {
	      dataMappings = dataMappings(result);
	    }

	    if (typeof dataMappings === 'object') {
	      var _context;

	      forEach$2(_context = entries$5(dataMappings)).call(_context, function (_ref) {
	        var attribute = _ref[0],
	            value = _ref[1];

	        if (typeof value === 'function') {
	          config[attribute] = value(result);
	        } else {
	          config[attribute] = value;
	        }
	      });
	    }

	    return config;
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  CardComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'cards/card';
	  };

	  CardComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  _createClass(CardComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'Card';
	    }
	  }]);

	  return CardComponent;
	}(Component);

	/**
	 * Converts an array of {@link AppliedQueryFilter}s into equivalent {@link SimpleFilterNode}s.
	 * @param {Array<AppliedQueryFilter>} nlpFilters
	 * @returns {Array<SimpleFilterNode>}
	 */

	function convertNlpFiltersToFilterNodes(nlpFilters) {
	  return map$2(nlpFilters).call(nlpFilters, function (nlpFilter) {
	    return FilterNodeFactory.from({
	      filter: Filter.from(filter$2(nlpFilter)),
	      metadata: new FilterMetadata({
	        fieldName: nlpFilter.key,
	        displayValue: nlpFilter.value
	      })
	    });
	  });
	}
	/**
	 * Flattens an array of {@link FilterNode}s into an array
	 * of their constituent leaf {@link SimpleFilterNode}s.
	 * @param {Array<FilterNode>} filterNodes
	 * @returns {Array<SimpleFilterNode>}
	 */

	function flattenFilterNodes(filterNodes) {
	  return flatMap$2(filterNodes).call(filterNodes, function (fn) {
	    return fn.getSimpleDescendants();
	  });
	}
	/**
	 * Returns the given array of {@link FilterNode}s,
	 * removing FilterNodes that are empty or have a field id listed as a hidden.
	 * @param {Array<FilterNode>} filterNodes
	 * @param {Array<string>} hiddenFields
	 * @returns {Array<FilterNode>}
	 */

	function pruneFilterNodes(filterNodes, hiddenFields) {
	  return filter$2(filterNodes).call(filterNodes, function (fn) {
	    var _fn$getMetadata = fn.getMetadata(),
	        fieldName = _fn$getMetadata.fieldName,
	        displayValue = _fn$getMetadata.displayValue;

	    if (!fieldName || !displayValue) {
	      return false;
	    }

	    var fieldId = fn.getFilter().getFilterKey();
	    return !includes$4(hiddenFields).call(hiddenFields, fieldId);
	  });
	}

	function ownKeys$l(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; forEach$2(_context4 = ownKeys$l(Object(source), true)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context5; forEach$2(_context5 = ownKeys$l(Object(source))).call(_context5, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var DEFAULT_CONFIG$5 = {
	  showResultCount: true,
	  showAppliedFilters: true,
	  showFieldNames: false,
	  resultsCountSeparator: '|',
	  verticalURL: undefined,
	  showChangeFilters: false,
	  removable: false,
	  delimiter: '|',
	  isUniversal: false,
	  labelText: "Filters applied to this search:",
	  removableLabelText: "Remove this filter",
	  resultsCountTemplate: '',
	  hiddenFields: []
	};

	var ResultsHeaderComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(ResultsHeaderComponent, _Component);

	  function ResultsHeaderComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$k(_objectSpread$k({}, DEFAULT_CONFIG$5), config), systemConfig) || this;
	    var data = config.data || {};
	    /**
	     * Total number of results.
	     * @type {number}
	     */

	    _this.resultsCount = data.resultsCount || 0;
	    /**
	     * Number of results displayed on the page.
	     * @type {number}
	     */

	    _this.resultsLength = data.resultsLength || 0;
	    /**
	     * The compiled custom results count template, if the user specifies one.
	     * @type {Function}
	     */

	    _this._compiledResultsCountTemplate = _this._renderer.compile(_this._config.resultsCountTemplate);
	    /**
	     * Array of nlp filters in the search response.
	     * @type {Array<AppliedQueryFilter>}
	     */

	    _this.nlpFilterNodes = convertNlpFiltersToFilterNodes(data.nlpFilters || []);
	    _this.moduleId = StorageKeys.DYNAMIC_FILTERS;
	    return _this;
	  }

	  ResultsHeaderComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  var _proto = ResultsHeaderComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    var removableFilterTags = DOM.queryAll(this._container, '.js-yxt-ResultsHeader-removableFilterTag');

	    forEach$2(removableFilterTags).call(removableFilterTags, function (tag) {
	      DOM.on(tag, 'click', function () {
	        return _this2._removeFilterTag(tag);
	      });
	    });
	  }
	  /**
	   * Call remove callback for the {@link FilterNode} corresponding to a specific
	   * removable filter tag.
	   * @param {HTMLElement} tag
	   */
	  ;

	  _proto._removeFilterTag = function _removeFilterTag(tag) {
	    var filterId = tag.dataset.filterId;
	    var filterNode = this.appliedFilterNodes[filterId];
	    filterNode.remove();
	    this.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	  }
	  /**
	   * Returns the currently applied nlp filter nodes, with nlp filter nodes that
	   * are duplicates of other filter nodes removed or filter on hiddenFields removed.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto._getPrunedNlpFilterNodes = function _getPrunedNlpFilterNodes() {
	    var _context,
	        _this3 = this;

	    var duplicatesRemoved = filter$2(_context = this.nlpFilterNodes).call(_context, function (nlpNode) {
	      var _context2;

	      var isDuplicate = find$3(_context2 = _this3.appliedFilterNodes).call(_context2, function (appliedNode) {
	        return appliedNode.hasSameFilterAs(nlpNode);
	      });

	      return !isDuplicate;
	    });

	    return pruneFilterNodes(duplicatesRemoved, this._config.hiddenFields);
	  }
	  /**
	   * Combine all of the applied filters into a format the handlebars
	   * template can work with.
	   * Keys are the fieldName of the filter. Values are an array of objects with a
	   * displayValue and dataFilterId.
	   * TODO (SPR-2350): give every node a unique id, and use that instead of index for
	   * dataFilterId.
	   * @returns {Array<Object>}
	   */
	  ;

	  _proto._groupAppliedFilters = function _groupAppliedFilters() {
	    var _this4 = this;

	    var getFieldName = function getFieldName(filterNode) {
	      return filterNode.getMetadata().fieldName;
	    };

	    var parseNlpFilterDisplay = function parseNlpFilterDisplay(filterNode) {
	      return {
	        displayValue: filterNode.getMetadata().displayValue
	      };
	    };

	    var parseRemovableFilterDisplay = function parseRemovableFilterDisplay(filterNode, index) {
	      return {
	        displayValue: filterNode.getMetadata().displayValue,
	        dataFilterId: index,
	        removable: _this4._config.removable
	      };
	    };

	    var removableNodes = groupArray(this.appliedFilterNodes, getFieldName, parseRemovableFilterDisplay);

	    var prunedNlpFilterNodes = this._getPrunedNlpFilterNodes();

	    return groupArray(prunedNlpFilterNodes, getFieldName, parseNlpFilterDisplay, removableNodes);
	  }
	  /**
	   * Returns an array of object the handlebars can understand and render
	   * the applied filters bar from. Our handlebars can only loop through arrays,
	   * not objects, so we need to reformat the grouped applied filters.
	   * @returns {Array<Object>}
	   */
	  ;

	  _proto._createAppliedFiltersArray = function _createAppliedFiltersArray() {
	    var _context3;

	    var groupedFilters = this._groupAppliedFilters();

	    return map$2(_context3 = keys$3(groupedFilters)).call(_context3, function (label) {
	      return {
	        label: label,
	        filterDataArray: groupedFilters[label]
	      };
	    });
	  }
	  /**
	   * Pulls applied filter nodes from {@link FilterRegistry}, then retrives an array of
	   * the leaf nodes, and then removes hidden or empty {@link FilterNode}s. Then appends
	   * the currently applied nlp filters.
	   */
	  ;

	  _proto._calculateAppliedFilterNodes = function _calculateAppliedFilterNodes() {
	    var filterNodes = this.core.filterRegistry.getAllFilterNodes();
	    var simpleFilterNodes = flattenFilterNodes(filterNodes);
	    return pruneFilterNodes(simpleFilterNodes, this._config.hiddenFields);
	  };

	  _proto.setState = function setState(data) {
	    var offset = this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;
	    this.appliedFilterNodes = this._calculateAppliedFilterNodes();

	    var appliedFiltersArray = this._createAppliedFiltersArray();

	    var shouldShowFilters = appliedFiltersArray.length > 0 && this._config.showAppliedFilters;
	    var resultsCountData = {
	      resultsCount: this.resultsCount,
	      resultsCountStart: offset + 1,
	      resultsCountEnd: offset + this.resultsLength
	    };
	    return _Component.prototype.setState.call(this, _objectSpread$k(_objectSpread$k(_objectSpread$k({}, data), resultsCountData), {}, {
	      showResultSeparator: this._config.resultsCountSeparator && this._config.showResultCount && shouldShowFilters,
	      shouldShowFilters: shouldShowFilters,
	      appliedFiltersArray: appliedFiltersArray,
	      customResultsCount: this._compiledResultsCountTemplate(resultsCountData)
	    }));
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  ResultsHeaderComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/resultsheader';
	  };

	  _createClass(ResultsHeaderComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'ResultsHeader';
	    }
	  }]);

	  return ResultsHeaderComponent;
	}(Component);

	function _createForOfIteratorHelperLoose$8(o, allowArrayLike) { var _context2; var it; if (typeof symbol$2 === "undefined" || getIteratorMethod$1(o) == null) { if (isArray$3(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } it = getIterator$1(o); return bind$2(_context2 = it.next).call(_context2, it); }

	function _unsupportedIterableToArray$8(o, minLen) { var _context; if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = slice$4(_context = Object.prototype.toString.call(o)).call(_context, 8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return from_1$2(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

	function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

	/**
	 * Used to parse config options, defaulting to different synonyms and
	 * finally a default value. Option names with periods will be parsed
	 * as multiple child object accessors, i.e. trying to access 'first.second.option'
	 * will first look for config['first']['second']['option'].
	 *
	 * This is mostly needed for boolean config values, since boolean operators,
	 * which we commonly use for defaulting config options, do not work properly
	 * in those cases.
	 * @param {Object} config
	 * @param {Array<string>}
	 * @param {any} defaultValue
	 */
	function defaultConfigOption(config, synonyms, defaultValue) {
	  for (var _iterator = _createForOfIteratorHelperLoose$8(synonyms), _step; !(_step = _iterator()).done;) {
	    var name = _step.value;
	    var accessors = name.split('.');
	    var parentConfig = config;
	    var skip = false;

	    for (var _iterator2 = _createForOfIteratorHelperLoose$8(slice$4(accessors).call(accessors, 0, -1)), _step2; !(_step2 = _iterator2()).done;) {
	      var childConfigAccessor = _step2.value;

	      if (!(childConfigAccessor in parentConfig)) {
	        skip = true;
	        break;
	      }

	      parentConfig = parentConfig[childConfigAccessor];
	    }

	    var configName = accessors[accessors.length - 1];

	    if (!skip && configName in parentConfig) {
	      return parentConfig[configName];
	    }
	  }

	  return defaultValue;
	}

	/**
	 * Returns a CSS class for the input searchState
	 * @param {SearchState} searchState
	 * @returns {string}
	 */

	function getContainerClass(searchState) {
	  switch (searchState) {
	    case SearchStates.PRE_SEARCH:
	      return 'yxt-Results--preSearch';

	    case SearchStates.SEARCH_LOADING:
	      return 'yxt-Results--searchLoading';

	    case SearchStates.SEARCH_COMPLETE:
	      return 'yxt-Results--searchComplete';

	    default:
	      console.trace("encountered an unknown search state: " + searchState);
	      return '';
	  }
	}

	function ownKeys$m(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; forEach$2(_context4 = ownKeys$m(Object(source), true)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context5; forEach$2(_context5 = ownKeys$m(Object(source))).call(_context5, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var VerticalResultsConfig = function VerticalResultsConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);
	  /**
	   * isUniversal is set to true if this component is added by the UniversalResultsComponent
	   * @type {boolean}
	   * @private
	   */


	  this.isUniversal = config.isUniversal || false;
	  var parentOpts = config._parentOpts || {};
	  /**
	   * Custom render function
	   * @type {function}
	   */

	  this.renderItem = config.renderItem || parentOpts.renderItem;
	  /**
	   * Custom item template
	   * @type {string}
	   */

	  this.itemTemplate = config.itemTemplate || parentOpts.itemTemplate;
	  /**
	   * The maximum number of columns to display, supports 1, 2, 3, or 4.
	   * @type {number}
	   */

	  this.maxNumberOfColumns = config.maxNumberOfColumns || 1;
	  /**
	   * The config to pass to the card
	   * @type {Object}
	   */

	  this.card = config.card || {};
	  /**
	   * Vertical URL for view more link
	   * @type {string}
	   */

	  this.verticalURL = config.verticalURL;
	  /**
	   * Whether to display the number of results.
	   * @type {boolean}
	   */

	  this.showResultCount = config.showResultCount === undefined ? true : config.showResultCount;
	  /**
	   * A custom results count template.
	   * @type {string}
	   */

	  this.resultsCountTemplate = config.resultsCountTemplate || '';
	  /**
	   * Whether to display the results header (assuming there is something like the results count
	   * or applied filters to display).
	   * @type {boolean}
	   */

	  this.hideResultsHeader = config.hideResultsHeader;
	  /**
	   * Config for the applied filters in the results header.
	   * @type {Object}
	   */

	  this.appliedFilters = {
	    /**
	     * If present, show the filters that were ultimately applied to this query
	     * @type {boolean}
	     */
	    show: defaultConfigOption(config, ['appliedFilters.show', 'showAppliedFilters'], true),

	    /**
	     * If showResultCount and showAppliedFilters are true,
	     * display this separator between the result count and the applied query filters
	     * @type {string}
	     */
	    resultsCountSeparator: defaultConfigOption(config, ['appliedFilters.resultsCountSeparator', 'resultsCountSeparator'], '|'),

	    /**
	     * If showAppliedFilters is true, show the field name in the string followed by a colon.
	     * @type {boolean}
	     */
	    showFieldNames: defaultConfigOption(config, ['appliedFilters.showFieldNames', 'showFieldNames'], false),

	    /**
	     * Any fieldIds in hiddenFields will be hidden from the list of appied filters.
	     * @type {Array<string>}
	     */
	    hiddenFields: defaultConfigOption(config, ['appliedFilters.hiddenFields', 'hiddenFields'], ['builtin.entityType']),

	    /**
	     * The character that should separate each field (and its associated filters) within the applied filter bar
	     * @type {string}
	     */
	    delimiter: defaultConfigOption(config, ['appliedFilters.delimiter'], '|'),

	    /**
	     * If the filters are shown, whether or not they should be removable from within the applied filter bar.
	     * @type {boolean}
	     */
	    removable: defaultConfigOption(config, ['appliedFilters.removable'], false),

	    /**
	     * Whether to show the change filters link on universal results.
	     * @type {boolean}
	     **/
	    showChangeFilters: defaultConfigOption(config, ['appliedFilters.showChangeFilters', 'showChangeFilters'], false),

	    /**
	     * The text for the change filters link.
	     * @type {string}
	     */
	    changeFiltersText: defaultConfigOption(config, ['appliedFilters.changeFiltersText', 'changeFiltersText']),

	    /**
	     * The aria-label given to the applied filters bar. Defaults to 'Filters applied to this search:'.
	     * @type {string}
	     **/
	    labelText: defaultConfigOption(config, ['appliedFilters.labelText'], "Filters applied to this search:"),

	    /**
	     * The aria-label given to the removable filter buttons.
	     * @type {string}
	     */
	    removableLabelText: defaultConfigOption(config, ['appliedFilters.removableLabelText'], "Remove this filter")
	  };
	  /**
	   * Text for the view more button.
	   * @type {string}
	   */

	  this.viewMoreLabel = defaultConfigOption(config, ['viewMoreLabel', 'viewAllText'], "View More");
	};

	var VerticalResultsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(VerticalResultsComponent, _Component);

	  function VerticalResultsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, new VerticalResultsConfig(APPLY_SYNONYMS(config)), systemConfig) || this;

	    var noResultsConfig = _this._config.noResults || _this.core.storage.get(StorageKeys.NO_RESULTS_CONFIG);
	    /**
	     * A parsed version of the noResults config provided to the component.
	     * Applies sensible defaults if certain values are not set.
	     * @type {Object}
	     * @private
	     */


	    _this._noResultsConfig = _extends({
	      displayAllResults: false,
	      template: ''
	    }, noResultsConfig);
	    /**
	     * Boolean indicating if legacy no results display should be used.
	     * @type {boolean}
	     * @private
	     */

	    _this._useLegacyNoResults = _this._config.isUniversal || !noResultsConfig;
	    /**
	     * _displayAllResults controls if all results for the vertical will display
	     * when there are no results for a query.
	     * @type {boolean}
	     * @private
	     */

	    _this._displayAllResults = _this._noResultsConfig.displayAllResults;
	    /**
	     * Specifies a custom no results template.
	     *
	     * @type {string}
	     * @private
	     */

	    _this._noResultsTemplate = _this._noResultsConfig.template;

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: function callback(results) {
	        _this.updateContainerClass(results.searchState);

	        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
	          _this.setState(results);
	        }
	      }
	    });
	    /**
	     * Vertical config from config, if not present, fall back to global verticalPagesConfig
	     * @type {Array.<object>}
	     * @private
	     */


	    _this._verticalsConfig = config.verticalPages || _this.core.storage.get(StorageKeys.VERTICAL_PAGES_CONFIG).get() || [];
	    /**
	     * @type {Array<Result>}
	     */

	    _this.results = [];
	    _this.numColumns = _this._config.maxNumberOfColumns;
	    /**
	     * Config options used in the {@link ResultsHeaderComponent}
	     */

	    _this.resultsHeaderOpts = {
	      showFieldNames: _this._config.appliedFilters.showFieldNames,
	      resultsCountSeparator: _this._config.appliedFilters.resultsCountSeparator,
	      showAppliedFilters: _this._config.appliedFilters.show,
	      showChangeFilters: _this._config.appliedFilters.showChangeFilters,
	      changeFiltersText: _this._config.appliedFilters.changeFiltersText,
	      showResultCount: _this._config.showResultCount,
	      removable: _this._config.appliedFilters.removable,
	      delimiter: _this._config.appliedFilters.delimiter,
	      labelText: _this._config.appliedFilters.labelText,
	      removableLabelText: _this._config.appliedFilters.removableLabelText,
	      hiddenFields: _this._config.appliedFilters.hiddenFields,
	      resultsCountTemplate: _this._config.resultsCountTemplate
	    };
	    return _this;
	  }

	  var _proto = VerticalResultsComponent.prototype;

	  _proto.onCreate = function onCreate() {
	    this.updateContainerClass(SearchStates.PRE_SEARCH);
	  };

	  _proto.mount = function mount() {
	    if (keys$3(this.getState()).length > 0) {
	      _Component.prototype.mount.call(this);
	    }

	    return this;
	  };

	  VerticalResultsComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  _proto.getBaseUniversalUrl = function getBaseUniversalUrl() {
	    var _context;

	    var universalConfig = find$3(_context = this._verticalsConfig).call(_context, function (config) {
	      return !config.verticalKey;
	    }) || {};
	    return universalConfig.url;
	  };

	  _proto.getUniversalUrl = function getUniversalUrl() {
	    var baseUniversalUrl = this.getBaseUniversalUrl();

	    if (!baseUniversalUrl) {
	      return undefined;
	    }

	    return this._getExperienceURL(baseUniversalUrl, new SearchParams(this.core.storage.getCurrentStateUrlMerged()));
	  };

	  _proto.getVerticalURL = function getVerticalURL(data) {
	    var _context2,
	        _this2 = this;

	    if (data === void 0) {
	      data = {};
	    }

	    var verticalConfig = find$3(_context2 = this._verticalsConfig).call(_context2, function (config) {
	      return config.verticalKey === _this2.verticalKey;
	    }) || {};
	    var verticalURL = this._config.verticalURL || verticalConfig.url || data.verticalURL || this.verticalKey + '.html';
	    var navigationData = this.core.storage.get(StorageKeys.NAVIGATION);
	    var dataTabOrder = navigationData ? navigationData.tabOrder : [];
	    var tabOrder = getTabOrder(this._verticalsConfig, dataTabOrder, this.core.storage.getCurrentStateUrlMerged());
	    var params = new SearchParams(this.core.storage.getCurrentStateUrlMerged());
	    params.set('tabOrder', tabOrder);
	    return this._getExperienceURL(verticalURL, params);
	  }
	  /**
	   * Adds parameters that are dynamically set. Removes parameters for facets,
	   * filters, and pagination, which should not persist across the experience.
	   * @param {string} baseUrl The url append the appropriate params to. Note:
	   *    params already on the baseUrl will be stripped
	   * @param {SearchParams} params The parameters to include in the experience URL
	   * @return {string} The formatted experience URL with appropriate query params
	   */
	  ;

	  _proto._getExperienceURL = function _getExperienceURL(baseUrl, params) {
	    var _this3 = this;

	    params.set(StorageKeys.QUERY, this.query);
	    var context = this.core.storage.get(StorageKeys.API_CONTEXT);

	    if (context) {
	      params.set(StorageKeys.API_CONTEXT, context);
	    }

	    var referrerPageUrl = this.core.storage.get(StorageKeys.REFERRER_PAGE_URL);

	    if (referrerPageUrl !== undefined) {
	      params.set(StorageKeys.REFERRER_PAGE_URL, referrerPageUrl);
	    }

	    var sessionsOptIn = this.core.storage.get(StorageKeys.SESSIONS_OPT_IN);

	    if (sessionsOptIn && sessionsOptIn.setDynamically) {
	      params.set(StorageKeys.SESSIONS_OPT_IN, sessionsOptIn.value);
	    }

	    var filteredParams = filterParamsForExperienceLink(params, function (types) {
	      return _this3.componentManager.getComponentNamesForComponentTypes(types);
	    });
	    return replaceUrlParams(baseUrl, filteredParams);
	  }
	  /**
	   * Updates the search state css class on this component's container.
	   */
	  ;

	  _proto.updateContainerClass = function updateContainerClass(searchState) {
	    var _context3,
	        _this4 = this;

	    forEach$2(_context3 = values$2(SearchStates)).call(_context3, function (searchState) {
	      _this4.removeContainerClass(getContainerClass(searchState));
	    });

	    this.addContainerClass(getContainerClass(searchState));
	  };

	  _proto.setState = function setState(data, val) {
	    if (data === void 0) {
	      data = {};
	    }

	    if (val === void 0) {
	      val = undefined;
	    }

	    /**
	     * @type {Array<Result>}
	     */
	    this.results = data.results || [];
	    this.resultsCount = data.resultsCount;
	    this.verticalKey = data.verticalConfigId;
	    this.resultsContext = data.resultsContext;
	    var searchState = data.searchState || SearchStates.PRE_SEARCH;
	    var displayResultsIfExist = this._config.isUniversal || this._displayAllResults || data.resultsContext === ResultsContext.NORMAL;
	    this.query = this.core.storage.get(StorageKeys.QUERY);
	    return _Component.prototype.setState.call(this, _extends({
	      results: []
	    }, data, {
	      searchState: searchState,
	      isPreSearch: searchState === SearchStates.PRE_SEARCH,
	      isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
	      isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
	      eventOptions: this.eventOptions(),
	      universalUrl: this.getUniversalUrl(),
	      verticalURL: this.getVerticalURL(data),
	      query: this.query,
	      currentVerticalLabel: this._currentVerticalLabel,
	      resultsPresent: displayResultsIfExist && this.results.length !== 0,
	      showNoResults: this.resultsContext === ResultsContext.NO_RESULTS,
	      placeholders: new Array(this._config.maxNumberOfColumns - 1),
	      numColumns: Math.min(this._config.maxNumberOfColumns, this.results.length),
	      useLegacyNoResults: this._useLegacyNoResults,
	      iconIsBuiltIn: Icons[this._config.icon],
	      nlpFilters: data.appliedQueryFilters || []
	    }), val);
	  }
	  /**
	   * helper to construct the eventOptions object for the view all link
	   * @returns {string}
	   */
	  ;

	  _proto.eventOptions = function eventOptions() {
	    return stringify$2({
	      verticalConfigId: this.verticalKey
	    });
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  VerticalResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/verticalresults';
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    if (type === MapComponent.type) {
	      var _opts = _objectSpread$l(_objectSpread$l({
	        noResults: this._noResultsConfig
	      }, this._config.mapConfig), opts);

	      var _data = {
	        resultsContext: this.getState('resultsContext'),
	        map: data
	      };
	      return _Component.prototype.addChild.call(this, _data, type, _opts);
	    } else if (type === CardComponent.type) {
	      var updatedData = {
	        result: this.results[opts._index],
	        verticalKey: this.verticalKey
	      };

	      var newOpts = _objectSpread$l(_objectSpread$l({
	        target: this._config.target
	      }, this._config.card), {}, {
	        isUniversal: this._config.isUniversal,
	        template: this._config.itemTemplate,
	        render: this._config.renderItem,
	        modifier: this._config.modifier
	      }, opts);

	      return _Component.prototype.addChild.call(this, updatedData, type, newOpts);
	    } else if (type === AlternativeVerticalsComponent.type) {
	      var hasResults = this.results && this.results.length > 0;
	      data = this.core.storage.get(StorageKeys.ALTERNATIVE_VERTICALS);

	      var _newOpts = _objectSpread$l({
	        template: this._noResultsTemplate,
	        baseUniversalUrl: this.getBaseUniversalUrl(),
	        verticalsConfig: this._verticalsConfig,
	        isShowingResults: this._displayAllResults && hasResults
	      }, opts);

	      return _Component.prototype.addChild.call(this, data, type, _newOpts);
	    } else if (type === ResultsHeaderComponent.type) {
	      var resultsHeaderData = _objectSpread$l({
	        resultsLength: this.results.length,
	        resultsCount: this.resultsCount,
	        nlpFilters: this.getState('nlpFilters')
	      }, data);

	      var _opts2 = _objectSpread$l({}, opts);

	      if (this.resultsContext === ResultsContext.NO_RESULTS) {
	        _opts2.showAppliedFilters = false;
	      }

	      return _Component.prototype.addChild.call(this, resultsHeaderData, type, _objectSpread$l(_objectSpread$l({
	        isUniversal: this._config.isUniversal,
	        verticalURL: this.getVerticalURL(),
	        verticalKey: this.verticalKey
	      }, this.resultsHeaderOpts), _opts2));
	    }

	    return _Component.prototype.addChild.call(this, data, type, opts);
	  };

	  _createClass(VerticalResultsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'VerticalResults';
	    }
	  }]);

	  return VerticalResultsComponent;
	}(Component);

	var APPLY_SYNONYMS = function APPLY_SYNONYMS(config) {
	  return _objectSpread$l({
	    icon: config.sectionTitleIconName || config.sectionTitleIconUrl,
	    title: config.sectionTitle
	  }, config);
	};

	var AccordionResultsComponent = /*#__PURE__*/function (_VerticalResultsCompo) {
	  _inheritsLoose(AccordionResultsComponent, _VerticalResultsCompo);

	  function AccordionResultsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _VerticalResultsCompo.call(this, config, systemConfig) || this;
	    /**
	     * base selector to use when finding DOM targets
	     * @type {string}
	     */

	    _this._selectorBase = config.selectorBase || '.js-yxt-AccordionResult';
	    /**
	     * collapsed state class
	     * @type {string}
	     */

	    _this.collapsedClass = config.collapsedClass || 'is-collapsed';
	    /**
	     * vertical config id is required for analytics
	     * @type {string|null}
	     */

	    _this.verticalConfigId = config.verticalConfigId || config._parentOpts.verticalConfigId || null;
	    return _this;
	  }
	  /**
	   * the component type
	   * @returns {string}
	   * @override
	   */


	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  AccordionResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/resultsaccordion';
	  }
	  /**
	   * overrides onMount to add bindings to change the height on click
	   * @returns {AccordionResultsComponent}
	   * @override
	   */
	  ;

	  var _proto = AccordionResultsComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    _VerticalResultsCompo.prototype.onMount.call(this); // NOTE(amullings): This is a hack, since currently components with siblings
	    // have no way of referring to their own element. We have to grab the first
	    // element since sections get added in reverse.


	    var selfEl = this._container.firstElementChild;
	    var accordionEls = DOM.queryAll(selfEl, this._selectorBase);

	    forEach$2(accordionEls).call(accordionEls, function (accordionEl) {
	      var toggleEl = DOM.query(accordionEl, _this2.toggleSelector());
	      var contentEl = DOM.query(accordionEl, _this2.bodySelector());

	      _this2.changeHeight(contentEl, accordionEl);

	      toggleEl.addEventListener('click', function () {
	        _this2.handleClick(accordionEl, toggleEl, contentEl);
	      });
	    });

	    return this;
	  };

	  _proto.setState = function setState(data) {
	    return _VerticalResultsCompo.prototype.setState.call(this, _extends({}, data, {
	      modifier: this.verticalConfigId
	    }));
	  }
	  /**
	   * click handler for the accordion toggle button
	   * @param wrapperEl {HTMLElement} the toggle container
	   * @param toggleEl {HTMLElement} the button
	   * @param contentEl {HTMLElement} the toggle target
	   */
	  ;

	  _proto.handleClick = function handleClick(wrapperEl, toggleEl, contentEl) {
	    var event = new AnalyticsEvent(this.isCollapsed(wrapperEl) ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
	      verticalConfigId: this.verticalConfigId,
	      entityId: toggleEl.dataset.entityId
	    });
	    wrapperEl.classList.toggle(this.collapsedClass);
	    this.changeHeight(contentEl, wrapperEl);
	    toggleEl.setAttribute('aria-expanded', this.isCollapsed(wrapperEl) ? 'false' : 'true');
	    this.analyticsReporter.report(event);
	  }
	  /**
	   * returns true if the element is currently collapsed
	   * @param wrapperEl {HTMLElement} the toggle container
	   * @returns {boolean}
	   */
	  ;

	  _proto.isCollapsed = function isCollapsed(wrapperEl) {
	    if (!wrapperEl) {
	      return false;
	    }

	    return wrapperEl.classList.contains(this.collapsedClass);
	  }
	  /**
	   * toggles the height between 0 and the content height for smooth animation
	   * @param targetEl {HTMLElement}
	   * @param wrapperEl {HTMLElement}
	   */
	  ;

	  _proto.changeHeight = function changeHeight(targetEl, wrapperEl) {
	    targetEl.style.height = (this.isCollapsed(wrapperEl) ? 0 : targetEl.scrollHeight) + "px";
	  }
	  /**
	   * helper for composing child element selectors
	   * @param child {string}
	   * @returns {string}
	   */
	  ;

	  _proto.buildSelector = function buildSelector(child) {
	    return "" + this._selectorBase + child;
	  }
	  /**
	   * helper for the toggle button selector
	   * @returns {string}
	   */
	  ;

	  _proto.toggleSelector = function toggleSelector() {
	    return this.buildSelector('-toggle');
	  }
	  /**
	   * helper for the content element selector
	   * @returns {string}
	   */
	  ;

	  _proto.bodySelector = function bodySelector() {
	    return this.buildSelector('-body');
	  };

	  _createClass(AccordionResultsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'AccordionResults';
	    }
	  }]);

	  return AccordionResultsComponent;
	}(VerticalResultsComponent);

	function ownKeys$n(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$n(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$n(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var UniversalResultsComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(UniversalResultsComponent, _Component);

	  function UniversalResultsComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    _this.moduleId = StorageKeys.UNIVERSAL_RESULTS;
	    _this._appliedFilters = _objectSpread$m({
	      show: true,
	      showFieldNames: false,
	      hiddenFields: ['builtin.entityType'],
	      resultsCountSeparator: '|',
	      showChangeFilters: false,
	      delimiter: '|',
	      labelText: "Filters applied to this search:"
	    }, config.appliedFilters);

	    var reRender = function reRender() {
	      return _this.setState(_this.core.storage.get(StorageKeys.UNIVERSAL_RESULTS) || {});
	    };

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.API_CONTEXT,
	      callback: reRender
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.SESSIONS_OPT_IN,
	      callback: reRender
	    });

	    return _this;
	  }

	  UniversalResultsComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/universalresults';
	  };

	  UniversalResultsComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  }
	  /**
	   * Updates the search state css class on this component's container.
	   */
	  ;

	  var _proto = UniversalResultsComponent.prototype;

	  _proto.updateContainerClass = function updateContainerClass(searchState) {
	    var _context,
	        _this2 = this;

	    forEach$2(_context = values$2(SearchStates)).call(_context, function (searchState) {
	      _this2.removeContainerClass(getContainerClass(searchState));
	    });

	    this.addContainerClass(getContainerClass(searchState));
	  };

	  _proto.setState = function setState(data, val) {
	    var sections = data.sections || [];
	    var query = this.core.storage.get(StorageKeys.QUERY);
	    var searchState = data.searchState || SearchStates.PRE_SEARCH;
	    this.updateContainerClass(searchState);
	    return _Component.prototype.setState.call(this, _extends(data, {
	      isPreSearch: searchState === SearchStates.PRE_SEARCH,
	      isSearchLoading: searchState === SearchStates.SEARCH_LOADING,
	      isSearchComplete: searchState === SearchStates.SEARCH_COMPLETE,
	      showNoResults: sections.length === 0 && (query || query === ''),
	      query: query,
	      sections: sections
	    }, val));
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    if (data === void 0) {
	      data = {};
	    }

	    if (type === void 0) {
	      type = undefined;
	    }

	    if (opts === void 0) {
	      opts = undefined;
	    }

	    var verticals = this._config.verticals || this._config.config || {};
	    var verticalKey = data.verticalConfigId;

	    var childOpts = _objectSpread$m(_objectSpread$m({}, opts), UniversalResultsComponent.getChildConfig(verticalKey, verticals[verticalKey] || {}, this._appliedFilters));

	    var childType = childOpts.useAccordion ? AccordionResultsComponent.type : type;
	    return _Component.prototype.addChild.call(this, data, childType, childOpts);
	  }
	  /**
	   * Applies synonyms and default config for a vertical in universal results.
	   * @param {string} verticalKey
	   * @param {Object} config
	   * @param {Object} topLevelAppliedFilters
	   * @returns {Object}
	   */
	  ;

	  UniversalResultsComponent.getChildConfig = function getChildConfig(verticalKey, config, topLevelAppliedFilters) {
	    return _objectSpread$m(_objectSpread$m({
	      // Tells vertical results it is in a universal results page.
	      isUniversal: true,
	      // Label for the vertical in the titlebar.
	      title: config.sectionTitle || verticalKey,
	      // Icon in the titlebar
	      icon: config.sectionTitleIconName || config.sectionTitleIconUrl,
	      // Url that links to the vertical search for this vertical.
	      verticalURL: config.url,
	      // Show a view more link by default, which also links to verticalURL.
	      viewMore: true,
	      // By default, the view more link has a label of 'View More'.
	      viewMoreLabel: defaultConfigOption(config, ['viewMoreLabel', 'viewAllText'], "View More"),
	      // Whether to show a result count.
	      showResultCount: false,
	      // Whether to use AccordionResults (DEPRECATED)
	      useAccordion: false
	    }, config), {}, {
	      // Config for the applied filters bar. Must be placed after ...config to not override defaults.
	      appliedFilters: {
	        // Whether to display applied filters.
	        show: defaultConfigOption(config, ['appliedFilters.show', 'showAppliedFilters'], topLevelAppliedFilters.show),
	        // Whether to show field names, e.g. Location in Location: Virginia.
	        showFieldNames: defaultConfigOption(config, ['appliedFilters.showFieldNames', 'showFieldNames'], topLevelAppliedFilters.showFieldNames),
	        // Hide filters with these field ids.
	        hiddenFields: defaultConfigOption(config, ['appliedFilters.hiddenFields', 'hiddenFields'], topLevelAppliedFilters.hiddenFields),
	        // Symbol placed between the result count and the applied filters.
	        resultsCountSeparator: defaultConfigOption(config, ['appliedFilters.resultsCountSeparator', 'resultsCountSeparator'], topLevelAppliedFilters.resultsCountSeparator),
	        // Whether to show a 'change filters' link, linking back to verticalURL.
	        showChangeFilters: defaultConfigOption(config, ['appliedFilters.showChangeFilters', 'showChangeFilters'], topLevelAppliedFilters.showChangeFilters),
	        // The text for the change filters link.
	        changeFiltersText: defaultConfigOption(config, ['appliedFilters.changeFiltersText', 'changeFiltersText'], topLevelAppliedFilters.changeFiltersText),
	        // The symbol placed between different filters with the same fieldName. e.g. Location: Virginia | New York | Miami.
	        delimiter: defaultConfigOption(config, ['appliedFilters.delimiter'], topLevelAppliedFilters.delimiter),
	        // The aria-label given to the applied filters bar.
	        labelText: defaultConfigOption(config, ['appliedFilters.labelText'], topLevelAppliedFilters.labelText)
	      }
	    });
	  };

	  _createClass(UniversalResultsComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'UniversalResults';
	    }
	  }]);

	  return UniversalResultsComponent;
	}(Component);

	var ceil$2 = Math.ceil;
	var floor$3 = Math.floor;

	// `Math.trunc` method
	// https://tc39.es/ecma262/#sec-math.trunc
	_export({ target: 'Math', stat: true }, {
	  trunc: function trunc(it) {
	    return (it > 0 ? floor$3 : ceil$2)(it);
	  }
	});

	var trunc = path.Math.trunc;

	var trunc$1 = trunc;

	var trunc$2 = trunc$1;

	function ownKeys$o(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$o(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$o(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var PaginationComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(PaginationComponent, _Component);

	  function PaginationComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    /**
	     * The vertical key to use for searches
	     * @type {string}
	     * @private
	     */

	    _this._verticalKey = config.verticalKey || _this.core.storage.get(StorageKeys.SEARCH_CONFIG).verticalKey;

	    if (typeof _this._verticalKey !== 'string') {
	      throw new AnswersComponentError('verticalKey not provided, but necessary for pagination', 'PaginationComponent');
	    }
	    /**
	     * The number of pages visible before/after the current page on desktop.
	     * @type {number}
	     * @private
	     */


	    _this._maxVisiblePagesDesktop = config.maxVisiblePagesDesktop === undefined ? 1 : config.maxVisiblePagesDesktop;
	    /**
	     * The number of pages visible before/after the current page on mobile.
	     * @type {number}
	     * @private
	     */

	    _this._maxVisiblePagesMobile = config.maxVisiblePagesMobile === undefined ? 1 : config.maxVisiblePagesMobile;
	    /**
	     * If true, displays the first and last page buttons
	     * @type {boolean}
	     * @private
	     */

	    _this._showFirstAndLastPageButtons = config.showFirstAndLastButton === undefined ? true : config.showFirstAndLastButton;
	    /**
	     * DEPRECATED
	     * @type {boolean}
	     * @private
	     */

	    _this._firstPageButtonEnabled = config.showFirst === undefined ? _this._showFirstAndLastPageButtons : config.showFirst;
	    /**
	     * DEPRECATED
	     * @type {boolean}
	     * @private
	     */

	    _this._lastPageButtonEnabled = config.showLast === undefined ? _this._showFirstAndLastPageButtons : config.showLast;
	    /**
	     * If true, always displays the page numbers for first and last page.
	     * @type {boolean}
	     * @private
	     */

	    _this._pinFirstAndLastPage = config.pinFirstAndLastPage === undefined ? false : config.pinFirstAndLastPage;
	    /**
	     * Icons object for first, previous, next, and last page icons.
	     * @type {{
	     *  nextButtonIcon: (string | undefined),
	     *  previousButtonIcon: (string | undefined),
	     *  firstButtonIcon: (string | undefined),
	     *  lastButtonIcon: (string | undefined),
	     * }}
	     * @private
	     */

	    _this._icons = config.icons;
	    /**
	     * Options to include with all analytic events sent by this component
	     * @type {object}
	     * @private
	     */

	    _this._analyticsOptions = {
	      verticalKey: _this._verticalKey
	    };
	    /**
	     * Label for a page of results.
	     * @type {string}
	     * @private
	     */

	    _this._pageLabel = config.pageLabel !== undefined ? config.pageLabel : "Page";
	    /**
	     * Function that is invoked on pagination
	     * @type {function(): {}}
	     * @private
	     */

	    _this._onPaginate = config.onPaginate || _this.scrollToTop;
	    /**
	     * The maximum number of results per page
	     * @type {number}
	     * @private
	     */

	    _this._limit = _this.core.storage.get(StorageKeys.SEARCH_CONFIG).limit;
	    var offset = _this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;

	    _this.core.storage.set(StorageKeys.SEARCH_OFFSET, Number(offset));

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.SEARCH_OFFSET,
	      callback: function callback(offset) {
	        if (typeof offset === 'number') {
	          return;
	        }

	        _this.core.storage.set(StorageKeys.SEARCH_OFFSET, Number(offset));
	      }
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: function callback(results) {
	        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
	          _this.setState();
	        }
	      }
	    });
	    /**
	     * Configuration for the behavior when there are no vertical results.
	     */


	    _this._noResults = config.noResults || _this.core.storage.get(StorageKeys.NO_RESULTS_CONFIG) || {};
	    return _this;
	  }

	  PaginationComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'results/pagination';
	  };

	  var _proto = PaginationComponent.prototype;

	  _proto.shouldShowControls = function shouldShowControls(results, limit) {
	    var hasResults = results.searchState === 'search-complete' && results.resultsCount > limit;
	    var isNormalResults = results.resultsContext === ResultsContext.NORMAL;
	    var isVisibleForNoResults = 'visible' in this._noResults ? this._noResults.visible : this._noResults.displayAllResults;
	    return hasResults && (isNormalResults || isVisibleForNoResults);
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this,
	        _context;

	    var results = this.core.storage.get(StorageKeys.VERTICAL_RESULTS) || {};
	    var limit = this.core.storage.get(StorageKeys.SEARCH_CONFIG).limit;
	    var showControls = this.shouldShowControls(results, limit);
	    var offset = this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;

	    if (!showControls) {
	      return;
	    }

	    var previousPageButton = DOM.query(this._container, '.js-yxt-Pagination-previous');
	    var nextPageButton = DOM.query(this._container, '.js-yxt-Pagination-next');

	    var maxPage = trunc$2((results.resultsCount - 1) / limit);

	    DOM.on(previousPageButton, 'click', function () {
	      return _this2.updatePage(offset - limit);
	    });
	    DOM.on(nextPageButton, 'click', function () {
	      return _this2.updatePage(offset + limit);
	    });

	    if (this._firstPageButtonEnabled) {
	      var firstPageButton = DOM.query(this._container, '.js-yxt-Pagination-first');
	      DOM.on(firstPageButton, 'click', function () {
	        return _this2.updatePage(0);
	      });
	    }

	    if (this._lastPageButtonEnabled) {
	      var lastPageButton = DOM.query(this._container, '.js-yxt-Pagination-last');
	      DOM.on(lastPageButton, 'click', function () {
	        return _this2.updatePage(maxPage * limit);
	      });
	    }

	    forEach$2(_context = DOM.queryAll('.js-yxt-Pagination-link')).call(_context, function (node) {
	      DOM.on(node, 'click', function () {
	        return _this2.updatePage((_parseInt$2(node.dataset.number) - 1) * limit);
	      });
	    });
	  };

	  _proto.updatePage = function updatePage(offset) {
	    var results = this.core.storage.get(StorageKeys.VERTICAL_RESULTS) || {};
	    var currentOffset = this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;
	    var currentPageNumber = currentOffset / this._limit + 1;
	    var newPageNumber = offset / this._limit + 1;

	    var maxPageCount = this._computeMaxPage(results.resultsCount);

	    this._onPaginate(newPageNumber, currentPageNumber, maxPageCount);

	    this.core.storage.setWithPersist(StorageKeys.SEARCH_OFFSET, offset);
	    this.core.verticalPage();
	  };

	  _proto.scrollToTop = function scrollToTop() {
	    document.documentElement.scrollTop = 0; // Safari

	    document.body.scrollTop = 0;
	  }
	  /**
	   * Computes the highest page number for a given amount of results
	   * @param {number} resultsCount
	   */
	  ;

	  _proto._computeMaxPage = function _computeMaxPage(resultsCount) {
	    return trunc$2((resultsCount - 1) / this._limit) + 1;
	  }
	  /**
	   * Pagination should evenly add page numbers in the "forward" and "backward" directions, unless
	   * one side has reached the max/min value, in which case the remaining side should be the only
	   * one to get more pages.
	   * @param {number} pageNumber the current page's number
	   * @param {number} maxPage the highest page number, acts as the upper bound
	   * @param {number} limit the maximum total number of pages that are allocated
	   * @returns {Array<number>} the backLimit and frontLimit, respectively
	   */
	  ;

	  _proto._allocate = function _allocate(pageNumber, maxPage, limit) {
	    var backLimit = pageNumber;
	    var frontLimit = pageNumber;

	    for (var i = 0; i < limit; i++) {
	      if (i % 2 === 0) {
	        if (backLimit > 0) {
	          backLimit--;
	        } else if (frontLimit < maxPage) {
	          frontLimit++;
	        }
	      } else {
	        if (frontLimit < maxPage) {
	          frontLimit++;
	        } else if (backLimit > 0) {
	          backLimit--;
	        }
	      }
	    }

	    return [backLimit, frontLimit];
	  }
	  /**
	   * Creates an object representing the view state of the page numbers and ellipses
	   * @param {number} pageNumber refers to the page number, not the page index
	   * @param {number} maxPage the highest page number, which also represents the total page count
	   * @returns {Object} the view-model for the page numbers displayed in the component, including whether to display ellipses
	   */
	  ;

	  _proto._createPageNumberViews = function _createPageNumberViews(pageNumber, maxPage) {
	    var _this$_allocate = this._allocate(pageNumber, maxPage, this._maxVisiblePagesMobile),
	        mobileBackLimit = _this$_allocate[0],
	        mobileFrontLimit = _this$_allocate[1];

	    var _this$_allocate2 = this._allocate(pageNumber, maxPage, this._maxVisiblePagesDesktop),
	        desktopBackLimit = _this$_allocate2[0],
	        desktopFrontLimit = _this$_allocate2[1];

	    var pageNumberViews = [];

	    for (var i = 1; i <= maxPage; i++) {
	      var num = {
	        number: i
	      };

	      if (i === pageNumber) {
	        num.active = true;

	        if (this._maxVisiblePagesDesktop > 1) {
	          num.activeDesktop = true;
	        }

	        if (this._maxVisiblePagesMobile > 1) {
	          num.activeMobile = true;
	        }
	      } else {
	        if (i <= mobileBackLimit || i > mobileFrontLimit) {
	          num.mobileHidden = true;
	        }

	        if (i <= desktopBackLimit || i > desktopFrontLimit) {
	          num.desktopHidden = true;
	        }
	      }

	      pageNumberViews.push(num);
	    }

	    return {
	      pinnedNumbers: {
	        mobileBack: this._pinFirstAndLastPage && mobileBackLimit > 0,
	        mobileFront: this._pinFirstAndLastPage && mobileFrontLimit < maxPage,
	        desktopBack: this._pinFirstAndLastPage && desktopBackLimit > 0,
	        desktopFront: this._pinFirstAndLastPage && desktopFrontLimit < maxPage
	      },
	      ellipses: {
	        mobileBack: this._pinFirstAndLastPage && mobileBackLimit > 1,
	        mobileFront: this._pinFirstAndLastPage && mobileFrontLimit < maxPage - 1,
	        desktopBack: this._pinFirstAndLastPage && desktopBackLimit > 1,
	        desktopFront: this._pinFirstAndLastPage && desktopFrontLimit < maxPage - 1
	      },
	      pageNumberViews: pageNumberViews
	    };
	  };

	  _proto.setState = function setState(data) {
	    var results = this.core.storage.get(StorageKeys.VERTICAL_RESULTS) || {};
	    var offset = this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;
	    var pageNumber = offset / this._limit + 1;
	    var isMoreResults = results.resultsCount > offset + this._limit;

	    var maxPage = this._computeMaxPage(results.resultsCount);

	    var _this$_createPageNumb = this._createPageNumberViews(pageNumber, maxPage),
	        pinnedNumbers = _this$_createPageNumb.pinnedNumbers,
	        ellipses = _this$_createPageNumb.ellipses,
	        pageNumberViews = _this$_createPageNumb.pageNumberViews;

	    return _Component.prototype.setState.call(this, _objectSpread$n({
	      showControls: this.shouldShowControls(results, this._limit),
	      firstPageButtonEnabled: this._firstPageButtonEnabled,
	      lastPageButtonEnabled: this._lastPageButtonEnabled,
	      pageNumber: pageNumber,
	      pageLabel: this._pageLabel,
	      showFirstPageButton: pageNumber > 2,
	      showPreviousPageButton: pageNumber > 1,
	      showNextPageButton: isMoreResults,
	      showLastPageButton: pageNumber < maxPage - 1,
	      icons: this._icons,
	      pageNumbers: pageNumberViews,
	      pinnedNumbers: pinnedNumbers,
	      ellipses: ellipses,
	      pinPages: this._pinFirstAndLastPage,
	      nextPage: pageNumber + 1,
	      maxPage: maxPage
	    }, data));
	  };

	  _createClass(PaginationComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'Pagination';
	    }
	  }]);

	  return PaginationComponent;
	}(Component);

	function ownKeys$p(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context6; forEach$2(_context6 = ownKeys$p(Object(source), true)).call(_context6, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context7; forEach$2(_context7 = ownKeys$p(Object(source))).call(_context7, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var CTACollectionComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(CTACollectionComponent, _Component);

	  function CTACollectionComponent(config, systemConfig) {
	    var _context, _context2;

	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;
	    var data = _this._config.data || {};
	    /**
	     * Result data
	     * @type {Result}
	     */

	    _this.result = data.result || {};
	    /**
	     * Whether the DOM should include legacy class names
	     * @type {boolean}
	     */

	    _this.includeLegacyClasses = _this._config.includeLegacyClasses || false;
	    /**
	     * Vertical key for the search.
	     * @type {string}
	     */

	    _this.verticalKey = data.verticalKey;
	    /**
	     * Whether this cta is part of a universal search.
	     * @type {boolean}
	     */

	    _this.isUniversal = _this._config.isUniversal || false;
	    /**
	     * Either a function that spits out an array of CTA config objects or an array of CTA config objects
	     * or api fieldnames
	     * @type {Function|Array<Object|string>}
	     */

	    var callsToAction = _this._config.callsToAction || [];
	    /**
	     * The config for each calls to action component to render.
	     * @type {Array<Object>}
	     */

	    _this.callsToAction = CTACollectionComponent.resolveCTAMapping.apply(CTACollectionComponent, concat$2(_context = [_this.result._raw]).call(_context, callsToAction)); // Assign any extra cta config that does not come from the cta mappings.

	    var _ctaModifiers = _this._config._ctaModifiers || [];

	    if (_this.callsToAction.length === 1) {
	      _ctaModifiers.push('solo');
	    }

	    _this.callsToAction = map$2(_context2 = _this.callsToAction).call(_context2, function (cta) {
	      return _objectSpread$o({
	        eventOptions: _this.defaultEventOptions(_this.result),
	        _ctaModifiers: _ctaModifiers,
	        includeLegacyClasses: _this.includeLegacyClasses
	      }, cta);
	    });
	    return _this;
	  }
	  /**
	   * Handles resolving ctas from a cta mapping which are either
	   * 1. a function that returns a cta's config
	   * 2. an object that has a per-attribute mapping of either a
	   *    a) static value
	   *    b) function that takes in resut data and returns the given attributes value
	   * Note: Intentionally does not allow nesting functions.
	   * @param {Object} result
	   * @param {Function|...(Object|string)} ctas
	   * @returns {Array<Object>}
	   */


	  CTACollectionComponent.resolveCTAMapping = function resolveCTAMapping(result) {
	    var parsedCTAs = [];

	    for (var _len = arguments.length, ctas = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	      ctas[_key - 1] = arguments[_key];
	    }

	    forEach$2(ctas).call(ctas, function (ctaMapping) {
	      if (typeof ctaMapping === 'function') {
	        parsedCTAs = concat$2(parsedCTAs).call(parsedCTAs, ctaMapping(result));
	      } else if (typeof ctaMapping === 'object') {
	        var ctaObject = _objectSpread$o({}, ctaMapping);

	        for (var _i = 0, _Object$entries = entries$5(ctaMapping); _i < _Object$entries.length; _i++) {
	          var _Object$entries$_i = _Object$entries[_i],
	              ctaAttribute = _Object$entries$_i[0],
	              attributeMapping = _Object$entries$_i[1];

	          if (typeof attributeMapping === 'function') {
	            ctaObject[ctaAttribute] = attributeMapping(result);
	          }
	        }

	        parsedCTAs.push(ctaObject);
	      }
	    });

	    parsedCTAs = filter$2(parsedCTAs).call(parsedCTAs, function (cta) {
	      return cta;
	    });

	    forEach$2(parsedCTAs).call(parsedCTAs, function (cta) {
	      if (!cta.label && !cta.url) {
	        console.warn('Call to Action:', cta, 'is missing both a label and url attribute and is being automatically hidden');
	      } else if (!cta.label) {
	        console.warn('Call to Action:', cta, 'is missing a label attribute and is being automatically hidden');
	      } else if (!cta.url) {
	        console.warn('Call to Action:', cta, 'is missing a url attribute and is being automatically hidden');
	      }
	    });

	    return filter$2(parsedCTAs).call(parsedCTAs, function (cta) {
	      var _context3, _context4;

	      return cta.url && trim$3(_context3 = cta.url).call(_context3) && cta.label && trim$3(_context4 = cta.label).call(_context4);
	    });
	  };

	  CTACollectionComponent.hasCTAs = function hasCTAs(result, ctas) {
	    var _context5;

	    return CTACollectionComponent.resolveCTAMapping.apply(CTACollectionComponent, concat$2(_context5 = [result]).call(_context5, ctas)).length > 0;
	  };

	  var _proto = CTACollectionComponent.prototype;

	  _proto.defaultEventOptions = function defaultEventOptions(result) {
	    var eventOptions = {
	      verticalKey: this.verticalKey,
	      searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
	    };

	    if (result._raw.id) {
	      eventOptions.entityId = result._raw.id;
	    }

	    return eventOptions;
	  };

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _objectSpread$o(_objectSpread$o({}, data), {}, {
	      includeLegacyClasses: this.includeLegacyClasses,
	      callsToAction: this.callsToAction
	    }));
	  };

	  CTACollectionComponent.defaultTemplateName = function defaultTemplateName() {
	    return 'ctas/ctacollection';
	  };

	  _createClass(CTACollectionComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'CTACollection';
	    }
	  }]);

	  return CTACollectionComponent;
	}(Component);

	function ownKeys$q(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$q(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$q(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var StandardCardConfig = function StandardCardConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);

	  var data = config.data || {};
	  /**
	   * The result data
	   * @type {Result}
	   */

	  var result = data.result || {};
	  /**
	   * The raw profile data
	   * @type {Object}
	   */

	  var rawResult = result._raw || {};
	  /**
	   * The dataMappings attribute of the config
	   * is either a function that returns additional config for
	   * a card or an object that is the additional config.
	   */

	  _extends(this, CardComponent.applyDataMappings(rawResult, config.dataMappings || {}));
	  /**
	   * The result data
	   * @type {Result}
	   */


	  this.result = config.data || {};
	  /**
	   * Title for the card
	   * @type {string}
	   */

	  this.title = this.title || result.title || rawResult.name || '';
	  /**
	   * Details for the card
	   * @type {string}
	   */

	  this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
	  /**
	   * Url when you click the title
	   * @type {string}
	   */

	  this.url = this.url === null ? '' : this.url || result.link || rawResult.website;
	  /**
	   * If showMoreLimit is set, the text that displays beneath it
	   * @type {string}
	   */

	  this.showMoreText = this.showMoreText || "Show More";
	  /**
	   * If showMoreLimit is set, the text that displays beneath it when all text is shown
	   * @type {string}
	   */

	  this.showLessText = this.showLessText || "Show Less";
	  /**
	   * Add a show more link if this number of characters is shown,
	   * and truncate the last 3 characters with an ellipses.
	   * Clicking show more should expand the results (but no “show less” link).
	   * @type {number}
	   */

	  this.showMoreLimit = this.showMoreLimit;
	  /**
	   * The target attribute for the title link.
	   * @type {string}
	   */

	  this.target = this.target;
	  /**
	   * Image url to display
	   * @type {string}
	   */

	  this.image = this.image;
	  /**
	   * Subtitle
	   * @type {string}
	   */

	  this.subtitle = this.subtitle;
	  /**
	   * Whether a 'show more' toggle button needs to be rendered at all
	   */

	  var detailsOverLimit = this.details.length > this.showMoreLimit;
	  this.showToggle = this.showMoreLimit && detailsOverLimit;
	  /**
	   * Either a function that spits out an array of CTA config objects or an array of CTA config objects
	   * or api fieldnames
	   * @type {Function|Array<Object|string>}
	   */

	  this.callsToAction = this.callsToAction || [];
	  /**
	   * Whether to show the ordinal of the card in the results.
	   * @type {boolean}
	   */

	  this.showOrdinal = this.showOrdinal || false;
	  /**
	   * Whether this card is part of a universal search.
	   * @type {boolean}
	   */

	  this.isUniversal = this.isUniversal || false;
	  /**
	   * The index of the card.
	   * @type {number}
	   */

	  this._index = config._index || 0;
	};
	/**
	 * Card components expect to receive a data config option, containing data regarding entity result
	 * each card is assigned to, including all field data in data._raw.
	 */


	var StandardCardComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(StandardCardComponent, _Component);

	  function StandardCardComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, new StandardCardConfig(config), systemConfig) || this;
	    _this.hideExcessDetails = _this._config.showToggle;
	    /**
	     * @type {Object}
	     */

	    var data = config.data || {};
	    /**
	     * Vertical key for the search.
	     * @type {string}
	     */

	    _this.verticalKey = data.verticalKey;
	    /**
	     * The result data
	     * @type {Result}
	     */

	    _this.result = data.result || {};
	    return _this;
	  }

	  var _proto = StandardCardComponent.prototype;

	  _proto.setState = function setState(data) {
	    var details = this._config.details;

	    if (this._config.showMoreLimit) {
	      details = this.hideExcessDetails ? this._config.details.substring(0, this._config.showMoreLimit) + "..." : this._config.details;
	    }

	    return _Component.prototype.setState.call(this, _objectSpread$p(_objectSpread$p({}, data), {}, {
	      hideExcessDetails: this.hideExcessDetails,
	      result: this.result,
	      hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction),
	      entityId: this.result._raw.id,
	      verticalKey: this.verticalKey,
	      details: details
	    }));
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    if (this._config.showToggle) {
	      var el = DOM.query(this._container, '.js-yxt-StandardCard-toggle');
	      DOM.on(el, 'click', function () {
	        _this2.hideExcessDetails = !_this2.hideExcessDetails;

	        _this2.setState();
	      });
	    }
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    if (type === CTACollectionComponent.type) {
	      var updatedData = {
	        verticalKey: this.verticalKey,
	        result: data
	      };
	      return _Component.prototype.addChild.call(this, updatedData, type, _objectSpread$p({
	        callsToAction: this._config.callsToAction,
	        isUniversal: this._config.isUniversal,
	        _ctaModifiers: ['StandardCard']
	      }, opts));
	    }

	    return _Component.prototype.addChild.call(this, data, type, opts);
	  };

	  StandardCardComponent.defaultTemplateName = function defaultTemplateName() {
	    return cardTemplates.Standard;
	  };

	  StandardCardComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  _createClass(StandardCardComponent, null, [{
	    key: "type",
	    get: function get() {
	      return cardTypes.Standard;
	    }
	  }]);

	  return StandardCardComponent;
	}(Component);

	function ownKeys$r(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$r(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$r(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var AccordionCardConfig = function AccordionCardConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);

	  var data = config.data || {};
	  /**
	   * The result data
	   * @type {Result}
	   */

	  var result = data.result || {};
	  /**
	   * The raw profile data
	   * @type {Object}
	   */

	  var rawResult = result._raw || {};
	  /**
	   * The dataMappings attribute of the config
	   * is either a function that returns additional config for
	   * a card or an object that is the additional config.
	   */

	  var dataMappings = config.dataMappings || {};

	  _extends(this, CardComponent.applyDataMappings(rawResult, dataMappings));
	  /**
	   * Vertical key for the card, added to analytics events sent by this component.
	   * @type {string}
	   */


	  this.verticalKey = config.verticalKey;
	  /**
	   * @type {string}
	   */

	  this.title = this.title || result.title || rawResult.name || '';
	  /**
	   * @type {string}
	   */

	  this.subtitle = this.subtitle;
	  /**
	   * @type {string}
	   */

	  this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
	  /**
	   * If expanded is true the first accordion in vertical/universal results renders on page load expanded.
	   * @type {boolean}
	   */

	  this.expanded = this.expanded || false;
	  /**
	   * Either a function that spits out an array of CTA config objects or an array of CTA config objects
	   * or api fieldnames
	   * @type {Function|Array<Object|string>}
	   */

	  this.callsToAction = this.callsToAction || [];
	  /**
	   * Whether this card is part of a universal search. Used in analytics.
	   * @type {boolean}
	   */

	  this.isUniversal = config.isUniversal || false;
	};

	var AccordionCardComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(AccordionCardComponent, _Component);

	  function AccordionCardComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, new AccordionCardConfig(config), systemConfig) || this;
	    /**
	     * Whether the accordion is collapsed or not.
	     * Defaults to true only if the expanded option is true
	     * and this is the first card in the results.
	     * @type {boolean}
	     */

	    _this.isExpanded = _this._config.expanded && config._index === 0;
	    /**
	     * @type {Object}
	     */

	    var data = config.data || {};
	    /**
	     * Vertical key for the card, added to analytics events sent by this component.
	     * @type {string}
	     */

	    _this.verticalKey = data.verticalKey;
	    /**
	     * The result data, sent to children CTA Components that need this.
	     * @type {Result}
	     */

	    _this.result = data.result || {};
	    return _this;
	  }

	  var _proto = AccordionCardComponent.prototype;

	  _proto.setState = function setState(data) {
	    var id = this.result.id || this.result.ordinal;
	    return _Component.prototype.setState.call(this, _objectSpread$q(_objectSpread$q({}, data), {}, {
	      result: this.result,
	      isExpanded: this.isExpanded,
	      id: this.name + "-" + id + "-" + this.verticalKey,
	      hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction)
	    }));
	  }
	  /**
	   * Click handler for the accordion toggle button
	   * This is used over set state because it's a lot smoother, since
	   * it doesn't rip the whole component off of the page and remount it.
	   * Also reports an analytics event.
	   * @param {HTMLElement} toggleEl the toggle element
	   * @param {HTMLElement} accordionBodyEl the .js-yxt-AccordionCard-body element
	   * @param {HTMLElement} accordionEl the root accordion element
	   */
	  ;

	  _proto.handleClick = function handleClick(toggleEl, accordionBodyEl, accordionEl) {
	    this.isExpanded = !this.isExpanded;
	    accordionEl.classList.toggle('yxt-AccordionCard--expanded');
	    accordionBodyEl.style.height = (this.isExpanded ? accordionBodyEl.scrollHeight : 0) + "px";
	    toggleEl.setAttribute('aria-expanded', this.isExpanded ? 'true' : 'false');
	    accordionBodyEl.setAttribute('aria-hidden', this.isExpanded ? 'false' : 'true');
	    var event = new AnalyticsEvent(this.isExpanded ? 'ROW_EXPAND' : 'ROW_COLLAPSE').addOptions({
	      verticalKey: this.verticalKey,
	      entityId: this.result._raw.id,
	      searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
	    });
	    this.analyticsReporter.report(event);
	  };

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    if (this._config.details) {
	      var toggleEl = DOM.query(this._container, '.js-yxt-AccordionCard-toggle');
	      var accordionBodyEl = DOM.query(this._container, '.js-yxt-AccordionCard-body');
	      var accordionEl = DOM.query(this._container, '.js-yxt-AccordionCard');
	      accordionBodyEl.style.height = (this.isExpanded ? accordionBodyEl.scrollHeight : 0) + "px";
	      DOM.on(toggleEl, 'click', function () {
	        return _this2.handleClick(toggleEl, accordionBodyEl, accordionEl);
	      });
	    }
	  }
	  /**
	   * For passing functions to the config of children {@link CTACollectionComponent}
	   */
	  ;

	  _proto.addChild = function addChild(data, type, opts) {
	    if (type === CTACollectionComponent.type) {
	      var updatedData = {
	        verticalKey: this.verticalKey,
	        result: data
	      };
	      return _Component.prototype.addChild.call(this, updatedData, type, _objectSpread$q({
	        callsToAction: this._config.callsToAction,
	        _ctaModifiers: ['AccordionCard'],
	        isUniversal: this._config.isUniversal
	      }, opts));
	    }

	    return _Component.prototype.addChild.call(this, data, type, opts);
	  };

	  AccordionCardComponent.defaultTemplateName = function defaultTemplateName() {
	    return cardTemplates.Accordion;
	  };

	  AccordionCardComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  _createClass(AccordionCardComponent, null, [{
	    key: "type",
	    get: function get() {
	      return cardTypes.Accordion;
	    }
	  }]);

	  return AccordionCardComponent;
	}(Component);

	function ownKeys$s(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$s(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$s(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var LegacyCardConfig = function LegacyCardConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);

	  var data = config.data || {};
	  /**
	   * The result data
	   * @type {Result}
	   */

	  var result = data.result || {};
	  /**
	   * The raw profile data
	   * @type {Object}
	   */

	  var rawResult = result._raw || {};
	  /**
	   * The dataMappings attribute of the config
	   * is either a function that returns additional config for
	   * a card or an object that is the additional config.
	   */

	  _extends(this, CardComponent.applyDataMappings(rawResult, config.dataMappings || {}));
	  /**
	   * The result data
	   * @type {Result}
	   */


	  this.result = config.data || {};
	  /**
	   * Title for the card
	   * @type {string}
	   */

	  this.title = this.title || result.title || rawResult.name || '';
	  /**
	   * Details for the card
	   * @type {string}
	   */

	  this.details = this.details === null ? null : this.details || result.details || rawResult.description || '';
	  /**
	   * Url when you click the title
	   * @type {string}
	   */

	  this.url = this.url === null ? '' : this.url || result.link || rawResult.website;
	  /**
	   * The target attribute for the title link.
	   * @type {string}
	   */

	  this.target = this.target;
	  /**
	   * Image url to display
	   * @type {string}
	   */

	  this.image = this.image;
	  /**
	   * Subtitle
	   * @type {string}
	   */

	  this.subtitle = this.subtitle;
	  /**
	   * Either a function that spits out an array of CTA config objects or an array of CTA config objects
	   * or api fieldnames
	   * @type {Function|Array<Object|string>}
	   */

	  this.callsToAction = this.callsToAction || [];
	  /**
	   * Whether to show the ordinal of the card in the results.
	   * @type {boolean}
	   */

	  this.showOrdinal = this.showOrdinal || false;
	  /**
	   * Whether this card is part of a universal search.
	   * @type {boolean}
	   */

	  this.isUniversal = this.isUniversal || false;
	  /**
	   * The index of the card.
	   * @type {number}
	   */

	  this._index = config._index || 0;
	};
	/**
	 * Card components expect to receive a data config option, containing data regarding entity result
	 * each card is assigned to, including all field data in data._raw.
	 */


	var LegacyCardComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(LegacyCardComponent, _Component);

	  function LegacyCardComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, new LegacyCardConfig(config), systemConfig) || this;
	    /**
	     * @type {Object}
	     */

	    var data = config.data || {};
	    /**
	     * Vertical key for the search.
	     * @type {string}
	     */

	    _this.verticalKey = data.verticalKey;
	    /**
	     * The result data
	     * @type {Result}
	     */

	    _this.result = data.result || {};
	    return _this;
	  }

	  var _proto = LegacyCardComponent.prototype;

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _objectSpread$r(_objectSpread$r({}, data), {}, {
	      eventOptions: this._legacyEventOptions(this.result._raw.id, this.result.link),
	      result: this.result,
	      hasCTAs: CTACollectionComponent.hasCTAs(this.result._raw, this._config.callsToAction),
	      entityId: this.result._raw.id,
	      verticalKey: this.verticalKey
	    }));
	  };

	  _proto._legacyEventOptions = function _legacyEventOptions(entityId, url) {
	    var options = {
	      verticalConfigId: this.verticalKey,
	      searcher: this._config.isUniversal ? 'UNIVERSAL' : 'VERTICAL'
	    };

	    if (entityId) {
	      options.entityId = entityId;
	    } else {
	      options.url = url;
	    }

	    return stringify$2(options);
	  };

	  _proto.addChild = function addChild(data, type, opts) {
	    if (type === CTACollectionComponent.type) {
	      var updatedData = {
	        verticalKey: this.verticalKey,
	        result: data
	      };
	      return _Component.prototype.addChild.call(this, updatedData, type, _objectSpread$r({
	        callsToAction: this._config.callsToAction,
	        isUniversal: this._config.isUniversal,
	        _ctaModifiers: ['LegacyCard'],
	        includeLegacyClasses: true
	      }, opts));
	    }

	    return _Component.prototype.addChild.call(this, data, type, opts);
	  };

	  LegacyCardComponent.defaultTemplateName = function defaultTemplateName() {
	    return cardTemplates.Legacy;
	  };

	  LegacyCardComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  _createClass(LegacyCardComponent, null, [{
	    key: "type",
	    get: function get() {
	      return cardTypes.Legacy;
	    }
	  }]);

	  return LegacyCardComponent;
	}(Component);

	function ownKeys$t(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$t(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$t(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/**
	 * Configurable options for the component
	 * @type {Object}
	 */

	var DEFAULT_CONFIG$6 = {
	  /**
	   * The entity identifier that the question is associated with.
	   * This is typically an organization object
	   * @type {number}
	   */
	  entityId: null,

	  /**
	   * The main CSS selector used to reference the form for the component.
	   * @type {string} CSS selector
	   */
	  formSelector: 'form',

	  /**
	   * An optional label to use for the e-mail address input
	   * @type {string}
	   */
	  emailLabel: "Email",

	  /**
	   * An optional label to use for the name input
	   * @type {string}
	   */
	  nameLabel: "Name",

	  /**
	   * An optional label to use for the question
	   * @type {string}
	   */
	  questionLabel: "Question",

	  /**
	   * An optional label to use for the Privacy Policy
	   * @type {string}
	   */
	  privacyPolicyText: "By submitting my email address, I consent to being contacted via email at the address provided.",

	  /**
	   * The label to use for the Submit button
	   * @type {string}
	   */
	  buttonLabel: "Submit",

	  /**
	   * The title to display in the title bar
	   * @type {string}
	   */
	  sectionTitle: "Ask a Question",

	  /**
	   * The description to display in the title bar
	   * @type {string}
	   */
	  teaser: "Can’t find what you're looking for? Ask a question below.",

	  /**
	   * The name of the icon to use in the title bar
	   * @type {string}
	   */
	  sectionTitleIconName: 'support',

	  /**
	   * The text to display in the feedback form ahead of the Question input
	   * @type {string}
	   */
	  description: "Enter your question and contact information, and we'll get back to you with a response shortly.",

	  /**
	   * The placeholder text for required inputs
	   * @type {string}
	   */
	  requiredInputPlaceholder: "(required)",

	  /**
	   * The placeholder text for the question text area
	   * @type {string}
	   */
	  questionInputPlaceholder: "Enter your question here",

	  /**
	   * The confirmation text to display after successfully submitting feedback
	   * @type {string}
	   */
	  questionSubmissionConfirmationText: "Thank you for your question!",

	  /**
	   * The default privacy policy url label
	   * @type {string}
	  */
	  privacyPolicyUrlLabel: "Learn more here.",

	  /**
	   * The default privacy policy url
	   * @type {string}
	   */
	  privacyPolicyUrl: '',

	  /**
	   * The default privacy policy error text, shown when the user does not agree
	   * @type {string}
	   */
	  privacyPolicyErrorText: "* You must agree to the privacy policy to submit a question.",

	  /**
	   * The default email format error text, shown when the user submits an invalid email
	   * @type {string}
	   */
	  emailFormatErrorText: "* Please enter a valid email address.",

	  /**
	   * The default network error text, shown when there is an issue with the QA Submission
	   * request.
	   * @type {string}
	   */
	  networkErrorText: "We're sorry, an error occurred.",

	  /**
	   * Whether or not this component is expanded by default.
	   * @type {boolean}
	   */
	  expanded: true
	};
	/**
	 * QuestionSubmissionComponent is a component that creates a form
	 * thats displayed whenever a query is run. It enables the user
	 * to submit questions that they cant find the answer for.
	 */

	var QuestionSubmissionComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(QuestionSubmissionComponent, _Component);

	  function QuestionSubmissionComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _extends({}, DEFAULT_CONFIG$6, config), systemConfig) || this;
	    /**
	     * Reference to the storage model
	     * @type {string}
	     */

	    _this.moduleId = StorageKeys.QUESTION_SUBMISSION;
	    /**
	     * Reference to the locale as set in the global config
	     * @type {string}
	     */

	    _this.locale = _this.core.storage.get(StorageKeys.LOCALE);
	    /**
	     * NOTE(billy) if this is a pattern we want to follow for configuration
	     * we should bake it into the core class.
	     */

	    _this.validateConfig();
	    /**
	     * The QuestionSubmission component should be rendered only once a search has completed. If the
	     * search results are still loading, the component should not be displayed.
	     */


	    var onResultsUpdate = function onResultsUpdate(results) {
	      if (results.searchState !== SearchStates.SEARCH_LOADING) {
	        var questionText = _this.core.storage.get(StorageKeys.QUERY);

	        _this.setState(new QuestionSubmission({
	          questionText: questionText,
	          expanded: _this._config.expanded
	        }));
	      } else {
	        _this.unMount();
	      }
	    };

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: onResultsUpdate
	    });

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.UNIVERSAL_RESULTS,
	      callback: onResultsUpdate
	    });

	    return _this;
	  }
	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */


	  QuestionSubmissionComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'questions/questionsubmission';
	  }
	  /**
	   * The public interface alias for the component
	   * @returns {string}
	   * @override
	   */
	  ;

	  var _proto = QuestionSubmissionComponent.prototype;

	  /**
	   * validationConfig contains a bunch of rules
	   * that are used to validate aginst configuration provided by the user
	   */
	  _proto.validateConfig = function validateConfig() {
	    if (this._config.entityId === null || this._config.entityId === undefined) {
	      throw new AnswersComponentError('`entityId` is a required configuration option for Question Submission', 'QuestionSubmission');
	    }
	  };

	  _proto.beforeMount = function beforeMount() {
	    // Avoid mounting the component if theres no data
	    // Note, 1 because `config` is always part of the state.
	    return keys$3(this.getState()).length > 1;
	  };

	  _proto.onMount = function onMount() {
	    var triggerEl = DOM.query(this._container, '.js-content-visibility-toggle');

	    if (triggerEl !== null) {
	      this.bindFormToggle(triggerEl);
	    }

	    var formEl = DOM.query(this._container, this._config.formSelector);

	    if (formEl === null) {
	      return;
	    }

	    this.bindFormFocus(formEl);
	    this.bindFormSubmit(formEl);
	  }
	  /**
	   * bindFormFocus will wire up the DOM focus event to serverside reporting
	   * @param {HTMLElement} formEl
	   */
	  ;

	  _proto.bindFormFocus = function bindFormFocus(formEl) {
	    var _this2 = this;

	    if (this.analyticsReporter === null) {
	      return;
	    }

	    var questionText = DOM.query(formEl, '.js-question-text');
	    DOM.on(questionText, 'focus', function () {
	      _this2.analyticsReporter.report(_this2.getAnalyticsEvent('QUESTION_FOCUS'));
	    });
	  }
	  /**
	   * bindFormSubmit handles submitting the question to the server,
	   * and submits an event to serverside reporting
	   * @param {HTMLElement} formEl
	   */
	  ;

	  _proto.bindFormSubmit = function bindFormSubmit(formEl) {
	    var _this3 = this;

	    DOM.on(formEl, 'submit', function (e) {
	      e.preventDefault();

	      _this3.analyticsReporter.report(_this3.getAnalyticsEvent('QUESTION_SUBMIT')); // TODO(billy) we probably want to disable the form from being submitted twice


	      var errors = _this3.validate(formEl);

	      var formData = _this3.parse(formEl);

	      if (keys$3(errors).length) {
	        return _this3.setState(new QuestionSubmission(formData, errors));
	      }

	      _this3.core.submitQuestion({
	        entityId: _this3._config.entityId,
	        site: 'FIRSTPARTY',
	        name: formData.name,
	        email: formData.email,
	        questionText: formData.questionText,
	        questionDescription: formData.questionDescription
	      })["catch"](function (error) {
	        _this3.setState(new QuestionSubmission(formData, {
	          network: 'We\'re sorry, an error occurred.'
	        }));

	        throw error;
	      });
	    });
	  }
	  /**
	   * bindFormToggle handles expanding and mimimizing the component's form.
	   * @param {HTMLElement} triggerEl
	   */
	  ;

	  _proto.bindFormToggle = function bindFormToggle(triggerEl) {
	    var _this4 = this;

	    DOM.on(triggerEl, 'click', function (e) {
	      var formData = _this4.getState();

	      _this4.setState(new QuestionSubmission(_objectSpread$s(_objectSpread$s({}, formData), {}, {
	        expanded: !formData.questionExpanded,
	        submitted: formData.questionSubmitted
	      }), formData.errors));
	    });
	  }
	  /**
	   * Takes the form, and builds a object that represents the input names
	   * and text fields.
	   * @param {HTMLElement} formEl
	   * @returns {object}
	   */
	  ;

	  _proto.parse = function parse(formEl) {
	    var inputFields = DOM.queryAll(formEl, '.js-question-field');

	    if (!inputFields || inputFields.length === 0) {
	      return {};
	    }

	    var obj = {};

	    for (var i = 0; i < inputFields.length; i++) {
	      var val = inputFields[i].value;

	      if (inputFields[i].type === 'checkbox') {
	        val = inputFields[i].checked;
	      }

	      obj[inputFields[i].name] = val;
	    }

	    return obj;
	  }
	  /**
	   * Validates the fields for correct formatting
	   * @param {HTMLElement} formEl
	   * @returns {Object} errors object if any errors found
	   */
	  ;

	  _proto.validate = function validate(formEl) {
	    var errors = {};
	    var fields = DOM.queryAll(formEl, '.js-question-field');

	    for (var i = 0; i < fields.length; i++) {
	      if (!fields[i].checkValidity()) {
	        if (i === 0) {
	          // set focus state on first error
	          fields[i].focus();
	        }

	        switch (fields[i].name) {
	          case 'email':
	            errors.emailError = true;

	            if (!fields[i].validity.valueMissing) {
	              errors.emailErrorText = this._config.emailFormatErrorText;
	            }

	            break;

	          case 'name':
	            errors.nameError = true;
	            break;

	          case 'privacyPolicy':
	            errors.privacyPolicyErrorText = this._config.privacyPolicyErrorText;
	            errors.privacyPolicyError = true;
	            break;

	          case 'questionText':
	            errors.questionTextError = true;
	            break;
	        }
	      }
	    }

	    return errors;
	  }
	  /**
	   * Returns an options object describing the context of a reportable event
	   */
	  ;

	  _proto.getAnalyticsEvent = function getAnalyticsEvent(eventType) {
	    var analyticsEvent = new AnalyticsEvent(eventType);
	    analyticsEvent.addOptions({
	      verticalConfigId: this._verticalKey,
	      searcher: this._verticalKey ? 'VERTICAL' : 'UNIVERSAL'
	    });
	    return analyticsEvent;
	  };

	  _createClass(QuestionSubmissionComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'QASubmission';
	    }
	  }]);

	  return QuestionSubmissionComponent;
	}(Component);

	var IconComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(IconComponent, _Component);

	  /**
	   * IconComponent
	   * @param opts
	   * @param opts.iconName {string}
	   * @param opts.iconUrl {string}
	   */
	  function IconComponent(opts, systemOpts) {
	    var _this;

	    if (opts === void 0) {
	      opts = {};
	    }

	    if (systemOpts === void 0) {
	      systemOpts = {};
	    }

	    _this = _Component.call(this, opts, systemOpts) || this;
	    /**
	     * name of an icon from the default icon set
	     * @type {string}
	     */

	    _this.iconName = opts.iconName || 'default';
	    /**
	     * the url to a custom image icon
	     * @type {null}
	     */

	    _this.iconUrl = opts.iconUrl || null;
	    /**
	     * An additional string to append to the icon's css class. Multiple
	     * classes should be space delimited.
	     */

	    _this.classNames = opts.classNames || null;
	    /**
	     * A unique id to pass to the icon.
	     * @type {Object}
	     */

	    _this.complexContentsParams = opts.complexContentsParams || {};
	    return _this;
	  }

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  IconComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'icons/icon';
	  }
	  /**
	   * allowing duplicates
	   * @returns {boolean}
	   * @override
	   */
	  ;

	  IconComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  }
	  /**
	   * overrides default functionality to provide name and markup
	   * @param data
	   * @returns {IconComponent}
	   */
	  ;

	  var _proto = IconComponent.prototype;

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _extends(data, {
	      iconUrl: this.iconUrl,
	      iconName: this.iconName,
	      name: this.iconName ? this.iconName : 'custom',
	      classNames: this.classNames,
	      complexContentsParams: this.complexContentsParams
	    }));
	  };

	  _createClass(IconComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'IconComponent';
	    }
	  }]);

	  return IconComponent;
	}(Component);

	function ownKeys$u(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$u(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$u(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var CTAConfig = function CTAConfig(config) {
	  if (config === void 0) {
	    config = {};
	  }

	  _extends(this, config);
	  /**
	   * Label below the CTA icon
	   * @type {string}
	   */


	  this.label = config.label;
	  /**
	   * CTA icon, maps to a set of icons.
	   * @type {string}
	   */

	  this.icon = config.icon;
	  /**
	   * Url to custom icon, has priority over icon.
	   * @type {string}
	   */

	  this.iconUrl = config.iconUrl;
	  /**
	   * Whether the DOM should include legacy class names
	   * @type {boolean}
	   */

	  this.includeLegacyClasses = config.includeLegacyClasses || false;
	  /**
	   * Click through url for the icon and label
	   * @type {string}
	   */

	  this.url = config.url;
	  /**
	   * Analytics event that should fire:
	   * @type {string}
	   */

	  this.analyticsEventType = config.analytics || config.eventType || 'CTA_CLICK';
	  /**
	   * The target attribute for the CTA link.
	   * @type {boolean}
	   */

	  this.target = config.target || '_blank';
	  /**
	   * The eventOptions needed for the event to fire, passed as a string or Object
	   * from config.dataMappings || {}.
	   * @type {Object}
	   */

	  if (typeof config.eventOptions === 'string') {
	    this.eventOptions = JSON.parse(config.eventOptions);
	  }

	  this.eventOptions = this.eventOptions;
	  /**
	   * Additional css className modifiers for the cta
	   * @type {string}
	   */

	  this._ctaModifiers = config._ctaModifiers;
	  /**
	   * Whether the cta is the only one in its CTACollectionComponent
	   * @type {boolean}
	   */

	  this._isSolo = config._isSolo || false;
	};

	var CTAComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(CTAComponent, _Component);

	  function CTAComponent(config, systemConfig) {
	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    return _Component.call(this, new CTAConfig(config), systemConfig) || this;
	  }

	  var _proto = CTAComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this = this;

	    var el = DOM.query(this._container, '.js-yxt-CTA');

	    if (el && this._config.eventOptions) {
	      DOM.on(el, 'mousedown', function (e) {
	        if (e.button === 0 || e.button === 1) {
	          _this.reportAnalyticsEvent();
	        }
	      });
	    }
	  };

	  _proto.setState = function setState(data) {
	    return _Component.prototype.setState.call(this, _objectSpread$t(_objectSpread$t({}, data), {}, {
	      hasIcon: this._config.icon || this._config.iconUrl
	    }));
	  };

	  _proto.reportAnalyticsEvent = function reportAnalyticsEvent() {
	    var analyticsEvent = new AnalyticsEvent(this._config.analyticsEventType);
	    analyticsEvent.addOptions(this._config.eventOptions);
	    this.analyticsReporter.report(analyticsEvent);
	  };

	  CTAComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'ctas/cta';
	  };

	  _createClass(CTAComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'CTA';
	    }
	  }]);

	  return CTAComponent;
	}(Component);

	function ownKeys$v(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context; forEach$2(_context = ownKeys$v(Object(source), true)).call(_context, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context2; forEach$2(_context2 = ownKeys$v(Object(source))).call(_context2, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	var VerticalResultsCountComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(VerticalResultsCountComponent, _Component);

	  function VerticalResultsCountComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, config, systemConfig) || this;

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: function callback(results) {
	        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
	          _this.setState(results);
	        }
	      }
	    });
	    /**
	     * When the page is in a No Results state, whether to display the
	     * vertical results count.
	     * @type {boolean}
	     */


	    _this._visibleForNoResults = !!(config.noResults || {}).visible;
	    return _this;
	  }

	  VerticalResultsCountComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  var _proto = VerticalResultsCountComponent.prototype;

	  _proto.setState = function setState(data) {
	    var verticalResults = data || {};
	    /**
	     * Total number of results.
	     * @type {number}
	     */

	    var resultsCount = verticalResults.resultsCount || 0;
	    /**
	     * Number of results displayed on the page.
	     * @type {number}
	     */

	    var resultsLength = (verticalResults.results || []).length;
	    var offset = this.core.storage.get(StorageKeys.SEARCH_OFFSET) || 0;
	    var isNoResults = verticalResults.resultsContext === ResultsContext.NO_RESULTS;
	    var hasZeroResults = resultsCount === 0;
	    var isHidden = !this._visibleForNoResults && isNoResults || hasZeroResults;
	    return _Component.prototype.setState.call(this, _objectSpread$u(_objectSpread$u({}, data), {}, {
	      total: resultsCount,
	      pageStart: offset + 1,
	      pageEnd: offset + resultsLength,
	      isHidden: isHidden
	    }));
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  VerticalResultsCountComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/verticalresultscount';
	  };

	  _createClass(VerticalResultsCountComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'VerticalResultsCount';
	    }
	  }]);

	  return VerticalResultsCountComponent;
	}(Component);

	function ownKeys$w(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context4; forEach$2(_context4 = ownKeys$w(Object(source), true)).call(_context4, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context5; forEach$2(_context5 = ownKeys$w(Object(source))).call(_context5, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	var DEFAULT_CONFIG$7 = {
	  showFieldNames: false,
	  showChangeFilters: false,
	  removable: false,
	  delimiter: '|',
	  labelText: 'Filters applied to this search:',
	  removableLabelText: 'Remove this filter',
	  hiddenFields: ['builtin.entityType']
	};

	var AppliedFiltersComponent = /*#__PURE__*/function (_Component) {
	  _inheritsLoose(AppliedFiltersComponent, _Component);

	  function AppliedFiltersComponent(config, systemConfig) {
	    var _this;

	    if (config === void 0) {
	      config = {};
	    }

	    if (systemConfig === void 0) {
	      systemConfig = {};
	    }

	    _this = _Component.call(this, _objectSpread$v(_objectSpread$v({}, DEFAULT_CONFIG$7), config), systemConfig) || this;
	    _this._verticalKey = _this._config.verticalKey || _this.core.storage.get(StorageKeys.SEARCH_CONFIG).verticalKey;
	    _this.moduleId = StorageKeys.FACETS_LOADED;

	    _this.core.storage.registerListener({
	      eventType: 'update',
	      storageKey: StorageKeys.VERTICAL_RESULTS,
	      callback: function callback(results) {
	        if (results.searchState === SearchStates.SEARCH_COMPLETE) {
	          _this.setState();
	        }
	      }
	    });

	    return _this;
	  }

	  AppliedFiltersComponent.areDuplicateNamesAllowed = function areDuplicateNamesAllowed() {
	    return true;
	  };

	  var _proto = AppliedFiltersComponent.prototype;

	  _proto.onMount = function onMount() {
	    var _this2 = this;

	    var removableFilterTags = DOM.queryAll(this._container, '.js-yxt-AppliedFilters-removableFilterTag');

	    forEach$2(removableFilterTags).call(removableFilterTags, function (tag) {
	      DOM.on(tag, 'click', function () {
	        return _this2._removeFilterTag(tag);
	      });
	    });
	  }
	  /**
	   * Call remove callback for the {@link FilterNode} corresponding to a specific
	   * removable filter tag.
	   * @param {HTMLElement} tag
	   */
	  ;

	  _proto._removeFilterTag = function _removeFilterTag(tag) {
	    var filterId = tag.dataset.filterId;
	    var filterNode = this.appliedFilterNodes[filterId];
	    filterNode.remove();
	    this.core.triggerSearch(QueryTriggers.FILTER_COMPONENT);
	  }
	  /**
	   * Returns the currently applied nlp filter nodes, with nlp filter nodes that
	   * are duplicates of other filter nodes removed or filter on hiddenFields removed.
	   * @returns {Array<FilterNode>}
	   */
	  ;

	  _proto._getPrunedNlpFilterNodes = function _getPrunedNlpFilterNodes() {
	    var _context,
	        _this3 = this;

	    var duplicatesRemoved = filter$2(_context = this.nlpFilterNodes).call(_context, function (nlpNode) {
	      var _context2;

	      var isDuplicate = find$3(_context2 = _this3.appliedFilterNodes).call(_context2, function (appliedNode) {
	        return appliedNode.hasSameFilterAs(nlpNode);
	      });

	      return !isDuplicate;
	    });

	    return pruneFilterNodes(duplicatesRemoved, this._config.hiddenFields);
	  }
	  /**
	   * Combine all of the applied filters into a format the handlebars
	   * template can work with.
	   * Keys are the fieldName of the filter. Values are an array of objects with a
	   * displayValue and dataFilterId.
	   * @returns {Array<Object>}
	   */
	  ;

	  _proto._groupAppliedFilters = function _groupAppliedFilters() {
	    var _this4 = this;

	    var getFieldName = function getFieldName(filterNode) {
	      return filterNode.getMetadata().fieldName;
	    };

	    var parseNlpFilterDisplay = function parseNlpFilterDisplay(filterNode) {
	      return {
	        displayValue: filterNode.getMetadata().displayValue
	      };
	    };

	    var parseRemovableFilterDisplay = function parseRemovableFilterDisplay(filterNode, index) {
	      return {
	        displayValue: filterNode.getMetadata().displayValue,
	        dataFilterId: index,
	        removable: _this4._config.removable
	      };
	    };

	    var removableNodes = groupArray(this.appliedFilterNodes, getFieldName, parseRemovableFilterDisplay);

	    var prunedNlpFilterNodes = this._getPrunedNlpFilterNodes();

	    return groupArray(prunedNlpFilterNodes, getFieldName, parseNlpFilterDisplay, removableNodes);
	  }
	  /**
	   * Returns an array of object the handlebars can understand and render
	   * the applied filters bar from. Our handlebars can only loop through arrays,
	   * not objects, so we need to reformat the grouped applied filters.
	   * @returns {Array<Object>}
	   */
	  ;

	  _proto._createAppliedFiltersArray = function _createAppliedFiltersArray() {
	    var _context3;

	    var groupedFilters = this._groupAppliedFilters();

	    return map$2(_context3 = keys$3(groupedFilters)).call(_context3, function (label) {
	      return {
	        label: label,
	        filterDataArray: groupedFilters[label]
	      };
	    });
	  }
	  /**
	   * Pulls applied filter nodes from {@link FilterRegistry}, then retrives an array of
	   * the leaf nodes, and then removes hidden or empty {@link FilterNode}s. Then appends
	   * the currently applied nlp filters.
	   */
	  ;

	  _proto._calculateAppliedFilterNodes = function _calculateAppliedFilterNodes() {
	    var filterNodes = this.core.filterRegistry.getAllFilterNodes();
	    var simpleFilterNodes = flattenFilterNodes(filterNodes);
	    return pruneFilterNodes(simpleFilterNodes, this._config.hiddenFields);
	  };

	  _proto.setState = function setState(data) {
	    var verticalResults = this.core.storage.get(StorageKeys.VERTICAL_RESULTS) || {};
	    /**
	     * Array of nlp filters in the search response.
	     * @type {Array<AppliedQueryFilter>}
	     */

	    var nlpFilters = verticalResults.appliedQueryFilters || [];
	    this.nlpFilterNodes = convertNlpFiltersToFilterNodes(nlpFilters);
	    this.appliedFilterNodes = this._calculateAppliedFilterNodes();

	    var appliedFiltersArray = this._createAppliedFiltersArray();

	    return _Component.prototype.setState.call(this, _objectSpread$v(_objectSpread$v({}, data), {}, {
	      appliedFiltersArray: appliedFiltersArray
	    }));
	  };

	  /**
	   * The template to render
	   * @returns {string}
	   * @override
	   */
	  AppliedFiltersComponent.defaultTemplateName = function defaultTemplateName(config) {
	    return 'results/appliedfilters';
	  };

	  _createClass(AppliedFiltersComponent, null, [{
	    key: "type",
	    get: function get() {
	      return 'AppliedFilters';
	    }
	  }]);

	  return AppliedFiltersComponent;
	}(Component);

	var COMPONENT_CLASS_LIST = [// Core Component
	Component, // Navigation Components
	NavigationComponent, // Search Components
	SearchComponent, FilterSearchComponent, AutoCompleteComponent, SpellCheckComponent, LocationBiasComponent, // Filter Components
	FilterBoxComponent, FilterOptionsComponent, RangeFilterComponent, DateRangeFilterComponent, FacetsComponent, GeoLocationComponent, SortOptionsComponent, // Results Components
	DirectAnswerComponent, UniversalResultsComponent, VerticalResultsComponent, PaginationComponent, AccordionResultsComponent, MapComponent, AlternativeVerticalsComponent, ResultsHeaderComponent, // Card Components
	CardComponent, StandardCardComponent, AccordionCardComponent, LegacyCardComponent, // Questions Components
	QuestionSubmissionComponent, // Helper Components
	IconComponent, CTAComponent, CTACollectionComponent, VerticalResultsCountComponent, AppliedFiltersComponent];
	/**
	 * The component registry is a map that contains
	 * all available component classes used for creation or extension.
	 * Each component class has a unique type, which is used as the key for the registry
	 * @type {Object.<string, Component>}
	 */

	var COMPONENT_REGISTRY = reduce$2(COMPONENT_CLASS_LIST).call(COMPONENT_CLASS_LIST, function (registry, clazz) {
	  registry[clazz.type] = clazz;
	  return registry;
	}, {});

	function ownKeys$x(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context8; forEach$2(_context8 = ownKeys$x(Object(source), true)).call(_context8, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context9; forEach$2(_context9 = ownKeys$x(Object(source))).call(_context9, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }
	/** @typedef {import('../../core/core').default} Core */

	/**
	 * ComponentManager is a Singletone that contains both an internal registry of
	 * eligible components to be created, as well as keeps track of the current
	 * instantiated and active components.
	 *
	 * ALL components should be constructed using the {ComponentManager} via its `create` method.
	 */

	var ComponentManager = /*#__PURE__*/function () {
	  function ComponentManager() {
	    /**
	     * The active components is an internal container to keep track
	     * of all of the components that have been constructed
	     */
	    this._activeComponents = [];
	    /**
	     * A counter for the id the give to the next component that is created.
	     */

	    this._componentIdCounter = 0;
	    /**
	     * A local reference to the core library dependency
	     *
	     * The Core contains both the storage AND services that are needed for performing operations
	     * like search and auto complete.
	     *
	     * The storage is the source of truth for the state of ALL components.
	     * Whenever the storage is updated, the state gets pushed down to the necessary components.
	     * @type {Core}
	     */

	    this._core = null;
	    /**
	     * The primary renderer to use for all components
	     * @type {HandlebarsRenderer}
	     */

	    this._renderer = null;
	    /**
	     * A local reference to the analytics reporter dependency
	     */

	    this._analyticsReporter = null;
	    /**
	     * A mapping from component types to component names, as these may be configured by a user
	     */

	    this._componentTypeToComponentNames = {};
	    /**
	     * A mapping of Components to moduleId storage listeners, for removal purposes.
	     */

	    this._componentToModuleIdListener = new map$7();
	  }

	  ComponentManager.getInstance = function getInstance() {
	    if (!this.instance) {
	      this.instance = new ComponentManager();
	    }

	    return this.instance;
	  };

	  var _proto = ComponentManager.prototype;

	  _proto.setRenderer = function setRenderer(renderer) {
	    this._renderer = renderer;
	    return this;
	  };

	  _proto.setCore = function setCore(core) {
	    this._core = core;
	    return this;
	  };

	  _proto.setAnalyticsReporter = function setAnalyticsReporter(reporter) {
	    this._analyticsReporter = reporter;
	    return this;
	  }
	  /**
	   * registers a component to be eligible for creation and override.
	   * @param {Component} The Component Class to register
	   */
	  ;

	  _proto.register = function register(componentClazz) {
	    COMPONENT_REGISTRY[componentClazz.type] = componentClazz;
	    return this;
	  }
	  /**
	   * Returns components with names similar to the passed in component class.
	   * @param {string} componentType
	   */
	  ;

	  _proto.getSimilarComponents = function getSimilarComponents(componentType) {
	    var _context;

	    var similarComponents = filter$2(_context = keys$3(COMPONENT_REGISTRY)).call(_context, function (type) {
	      return startsWith$2(type).call(type, componentType.substring(0, 2));
	    });

	    if (similarComponents.length === 0) {
	      similarComponents = keys$3(COMPONENT_REGISTRY);
	    }

	    return similarComponents;
	  }
	  /**
	   * create is the entry point for constructing any and all components.
	   * It will instantiate a new instance of the component, and both apply
	   * initial state from the storage and bind it to the storage for updates.
	   * @param {string} componentType The component type to create
	   * @param {Object} opts The options to pipe to the construction of the component
	   */
	  ;

	  _proto.create = function create(componentType, opts) {
	    var _context2, _context3;

	    // Every component needs local access to the component manager
	    // because sometimes components have subcomponents that need to be
	    // constructed during creation
	    var systemOpts = {
	      core: this._core,
	      renderer: this._renderer,
	      analyticsReporter: this._analyticsReporter,
	      componentManager: this,
	      uniqueId: this._componentIdCounter
	    };
	    this._componentIdCounter++;
	    var componentClass = COMPONENT_REGISTRY[componentType];

	    if (!componentClass) {
	      throw new AnswersComponentError("Component type " + componentType + " is not recognized as a valid component." + (" You might have meant " + this.getSimilarComponents(componentType).join(', ') + "?"));
	    }

	    if (!componentClass.areDuplicateNamesAllowed() && some$2(_context2 = this._activeComponents).call(_context2, function (c) {
	      return c.name === opts.name;
	    })) {
	      throw new AnswersComponentError("Another component with name " + opts.name + " already exists", componentType);
	    }

	    var config = _objectSpread$w({
	      isTwin: some$2(_context3 = this._activeComponents).call(_context3, function (component) {
	        return component.constructor.type === componentType;
	      })
	    }, opts); // Instantiate our new component and keep track of it


	    var component = new COMPONENT_REGISTRY[componentType](config, systemOpts).init(config);

	    this._activeComponents.push(component);

	    if (!this._componentTypeToComponentNames[componentType]) {
	      this._componentTypeToComponentNames[componentType] = [];
	    }

	    this._componentTypeToComponentNames[componentType].push(component.name); // If there is a storage to power state, apply the state
	    // from the storage to the component, and then bind the component
	    // state to the storage via its updates


	    if (this._core && this._core.storage !== null) {
	      if (component.moduleId === undefined || component.moduleId === null) {
	        return component;
	      }

	      var listener = {
	        eventType: 'update',
	        storageKey: component.moduleId,
	        callback: function callback(data) {
	          return component.setState(data);
	        }
	      };

	      this._core.storage.registerListener(listener);

	      this._componentToModuleIdListener.set(component, listener);
	    }

	    return component;
	  }
	  /**
	   * Remove the provided component from the list of active components and remove
	   * the associated storage event listener
	   * @param {Component} component The component to remove
	   */
	  ;

	  _proto.remove = function remove(component) {
	    var _context4;

	    this._core.storage.removeListener(this._componentToModuleIdListener.get(component));

	    var index = findIndex$2(_context4 = this._activeComponents).call(_context4, function (c) {
	      return c.uniqueId === component.uniqueId;
	    });

	    if (index !== -1) {
	      var _context5;

	      splice$2(_context5 = this._activeComponents).call(_context5, index, 1);
	    }
	  }
	  /**
	   * Remove the component with the given name
	   * @param {string} name The name of the compnent to remove
	   */
	  ;

	  _proto.removeByName = function removeByName(name) {
	    var _context6;

	    var component = find$3(_context6 = this._activeComponents).call(_context6, function (c) {
	      return c.name === name;
	    });

	    component.remove();
	    DOM.empty(component._container);
	  };

	  _proto.getActiveComponent = function getActiveComponent(type) {
	    var _context7;

	    return find$3(_context7 = this._activeComponents).call(_context7, function (c) {
	      return c.constructor.type === type;
	    });
	  }
	  /**
	   * Returns a concatenated list of all names associated with the given component types
	   * @param {string[]} type The types of the component
	   * @returns {string[]} The component names for the component types
	   */
	  ;

	  _proto.getComponentNamesForComponentTypes = function getComponentNamesForComponentTypes(types) {
	    var _this = this;

	    return reduce$2(types).call(types, function (names, type) {
	      return concat$2(names).call(names, _this._componentTypeToComponentNames[type] || []);
	    }, []);
	  };

	  return ComponentManager;
	}();

	function ownKeys$y(object, enumerableOnly) { var keys = keys$3(object); if (getOwnPropertySymbols$2) { var symbols = getOwnPropertySymbols$2(object); if (enumerableOnly) symbols = filter$2(symbols).call(symbols, function (sym) { return getOwnPropertyDescriptor$4(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

	function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { var _context2; forEach$2(_context2 = ownKeys$y(Object(source), true)).call(_context2, function (key) { _defineProperty(target, key, source[key]); }); } else if (getOwnPropertyDescriptors$2) { defineProperties$1(target, getOwnPropertyDescriptors$2(source)); } else { var _context3; forEach$2(_context3 = ownKeys$y(Object(source))).call(_context3, function (key) { defineProperty$3(target, key, getOwnPropertyDescriptor$4(source, key)); }); } } return target; }

	/** @module VerticalPagesConfig */
	var VerticalPageConfig = /*#__PURE__*/function () {
	  function VerticalPageConfig(config) {
	    if (config === void 0) {
	      config = {};
	    }

	    /**
	     * The name of the tab that is exposed for the link
	     * @type {string}
	     */
	    this.label = config.label || null;
	    /**
	     * The complete URL, including the params
	     * @type {string}
	     */

	    this.url = config.url || null;
	    /**
	     * The serverside vertical config id that this is referenced to.
	     * By providing this, enables dynamic sorting based on results.
	     * @type {string}
	     */

	    this.verticalKey = config.verticalKey || null;
	    /**
	     * Determines whether to show this tab in the navigation component
	     * @type {boolean}
	     */

	    this.hideInNavigation = config.hideInNavigation || false;
	    /**
	     * Determines whether to show this tab first in the order
	     * @type {boolean}
	     */

	    this.isFirst = config.isFirst || false;
	    /**
	     * Determines whether or not to apply a special class to the
	     * markup to determine if it's an active tab
	     * @type {boolean}
	     */

	    this.isActive = config.isActive || false;
	    /**
	     * URL of an icon
	     * @type {string}
	     */

	    this.iconUrl = config.iconUrl;
	    /**
	     * name of an icon from the default icon set
	     * @type {string}
	     */

	    this.icon = config.icon;

	    freeze$2(this);
	  }

	  var _proto = VerticalPageConfig.prototype;

	  _proto.validate = function validate() {};

	  return VerticalPageConfig;
	}();

	var VerticalPagesConfig = /*#__PURE__*/function () {
	  function VerticalPagesConfig(pages) {
	    if (pages === void 0) {
	      pages = [];
	    }

	    this.verticalPagesConfig = VerticalPagesConfig.from(pages);
	  }
	  /**
	   * Using a getter that copies the data instead of providing a reference prevents it from being mutated.
	   * This is important for global configuration.
	   * @returns {Array<VerticalPageConfig>}
	   */


	  var _proto2 = VerticalPagesConfig.prototype;

	  _proto2.get = function get() {
	    var _context;

	    return map$2(_context = this.verticalPagesConfig).call(_context, function (page) {
	      return _objectSpread$x({}, page);
	    });
	  };

	  VerticalPagesConfig.from = function from(pages) {
	    return map$2(pages).call(pages, function (page) {
	      return new VerticalPageConfig(page);
	    });
	  };

	  return VerticalPagesConfig;
	}();

	var markdownItForInline = function for_inline_plugin(md, ruleName, tokenType, iteartor) {

	  function scan(state) {
	    var i, blkIdx, inlineTokens;

	    for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
	      if (state.tokens[blkIdx].type !== 'inline') {
	        continue;
	      }

	      inlineTokens = state.tokens[blkIdx].children;

	      for (i = inlineTokens.length - 1; i >= 0; i--) {
	        if (inlineTokens[i].type !== tokenType) {
	          continue;
	        }

	        iteartor(inlineTokens, i);
	      }
	    }
	  }

	  md.core.ruler.push(ruleName, scan);
	};

	var rtfConverter_min = createCommonjsModule(function (module, exports) {
	!function(e,r){module.exports=r();}(commonjsGlobal,function(){var e,r,t=(function(e,r){e.exports=function(){var e={Aacute:"Á",aacute:"á",Abreve:"Ă",abreve:"ă",ac:"∾",acd:"∿",acE:"∾̳",Acirc:"Â",acirc:"â",acute:"´",Acy:"А",acy:"а",AElig:"Æ",aelig:"æ",af:"⁡",Afr:"𝔄",afr:"𝔞",Agrave:"À",agrave:"à",alefsym:"ℵ",aleph:"ℵ",Alpha:"Α",alpha:"α",Amacr:"Ā",amacr:"ā",amalg:"⨿",amp:"&",AMP:"&",andand:"⩕",And:"⩓",and:"∧",andd:"⩜",andslope:"⩘",andv:"⩚",ang:"∠",ange:"⦤",angle:"∠",angmsdaa:"⦨",angmsdab:"⦩",angmsdac:"⦪",angmsdad:"⦫",angmsdae:"⦬",angmsdaf:"⦭",angmsdag:"⦮",angmsdah:"⦯",angmsd:"∡",angrt:"∟",angrtvb:"⊾",angrtvbd:"⦝",angsph:"∢",angst:"Å",angzarr:"⍼",Aogon:"Ą",aogon:"ą",Aopf:"𝔸",aopf:"𝕒",apacir:"⩯",ap:"≈",apE:"⩰",ape:"≊",apid:"≋",apos:"'",ApplyFunction:"⁡",approx:"≈",approxeq:"≊",Aring:"Å",aring:"å",Ascr:"𝒜",ascr:"𝒶",Assign:"≔",ast:"*",asymp:"≈",asympeq:"≍",Atilde:"Ã",atilde:"ã",Auml:"Ä",auml:"ä",awconint:"∳",awint:"⨑",backcong:"≌",backepsilon:"϶",backprime:"‵",backsim:"∽",backsimeq:"⋍",Backslash:"∖",Barv:"⫧",barvee:"⊽",barwed:"⌅",Barwed:"⌆",barwedge:"⌅",bbrk:"⎵",bbrktbrk:"⎶",bcong:"≌",Bcy:"Б",bcy:"б",bdquo:"„",becaus:"∵",because:"∵",Because:"∵",bemptyv:"⦰",bepsi:"϶",bernou:"ℬ",Bernoullis:"ℬ",Beta:"Β",beta:"β",beth:"ℶ",between:"≬",Bfr:"𝔅",bfr:"𝔟",bigcap:"⋂",bigcirc:"◯",bigcup:"⋃",bigodot:"⨀",bigoplus:"⨁",bigotimes:"⨂",bigsqcup:"⨆",bigstar:"★",bigtriangledown:"▽",bigtriangleup:"△",biguplus:"⨄",bigvee:"⋁",bigwedge:"⋀",bkarow:"⤍",blacklozenge:"⧫",blacksquare:"▪",blacktriangle:"▴",blacktriangledown:"▾",blacktriangleleft:"◂",blacktriangleright:"▸",blank:"␣",blk12:"▒",blk14:"░",blk34:"▓",block:"█",bne:"=⃥",bnequiv:"≡⃥",bNot:"⫭",bnot:"⌐",Bopf:"𝔹",bopf:"𝕓",bot:"⊥",bottom:"⊥",bowtie:"⋈",boxbox:"⧉",boxdl:"┐",boxdL:"╕",boxDl:"╖",boxDL:"╗",boxdr:"┌",boxdR:"╒",boxDr:"╓",boxDR:"╔",boxh:"─",boxH:"═",boxhd:"┬",boxHd:"╤",boxhD:"╥",boxHD:"╦",boxhu:"┴",boxHu:"╧",boxhU:"╨",boxHU:"╩",boxminus:"⊟",boxplus:"⊞",boxtimes:"⊠",boxul:"┘",boxuL:"╛",boxUl:"╜",boxUL:"╝",boxur:"└",boxuR:"╘",boxUr:"╙",boxUR:"╚",boxv:"│",boxV:"║",boxvh:"┼",boxvH:"╪",boxVh:"╫",boxVH:"╬",boxvl:"┤",boxvL:"╡",boxVl:"╢",boxVL:"╣",boxvr:"├",boxvR:"╞",boxVr:"╟",boxVR:"╠",bprime:"‵",breve:"˘",Breve:"˘",brvbar:"¦",bscr:"𝒷",Bscr:"ℬ",bsemi:"⁏",bsim:"∽",bsime:"⋍",bsolb:"⧅",bsol:"\\",bsolhsub:"⟈",bull:"•",bullet:"•",bump:"≎",bumpE:"⪮",bumpe:"≏",Bumpeq:"≎",bumpeq:"≏",Cacute:"Ć",cacute:"ć",capand:"⩄",capbrcup:"⩉",capcap:"⩋",cap:"∩",Cap:"⋒",capcup:"⩇",capdot:"⩀",CapitalDifferentialD:"ⅅ",caps:"∩︀",caret:"⁁",caron:"ˇ",Cayleys:"ℭ",ccaps:"⩍",Ccaron:"Č",ccaron:"č",Ccedil:"Ç",ccedil:"ç",Ccirc:"Ĉ",ccirc:"ĉ",Cconint:"∰",ccups:"⩌",ccupssm:"⩐",Cdot:"Ċ",cdot:"ċ",cedil:"¸",Cedilla:"¸",cemptyv:"⦲",cent:"¢",centerdot:"·",CenterDot:"·",cfr:"𝔠",Cfr:"ℭ",CHcy:"Ч",chcy:"ч",check:"✓",checkmark:"✓",Chi:"Χ",chi:"χ",circ:"ˆ",circeq:"≗",circlearrowleft:"↺",circlearrowright:"↻",circledast:"⊛",circledcirc:"⊚",circleddash:"⊝",CircleDot:"⊙",circledR:"®",circledS:"Ⓢ",CircleMinus:"⊖",CirclePlus:"⊕",CircleTimes:"⊗",cir:"○",cirE:"⧃",cire:"≗",cirfnint:"⨐",cirmid:"⫯",cirscir:"⧂",ClockwiseContourIntegral:"∲",CloseCurlyDoubleQuote:"”",CloseCurlyQuote:"’",clubs:"♣",clubsuit:"♣",colon:":",Colon:"∷",Colone:"⩴",colone:"≔",coloneq:"≔",comma:",",commat:"@",comp:"∁",compfn:"∘",complement:"∁",complexes:"ℂ",cong:"≅",congdot:"⩭",Congruent:"≡",conint:"∮",Conint:"∯",ContourIntegral:"∮",copf:"𝕔",Copf:"ℂ",coprod:"∐",Coproduct:"∐",copy:"©",COPY:"©",copysr:"℗",CounterClockwiseContourIntegral:"∳",crarr:"↵",cross:"✗",Cross:"⨯",Cscr:"𝒞",cscr:"𝒸",csub:"⫏",csube:"⫑",csup:"⫐",csupe:"⫒",ctdot:"⋯",cudarrl:"⤸",cudarrr:"⤵",cuepr:"⋞",cuesc:"⋟",cularr:"↶",cularrp:"⤽",cupbrcap:"⩈",cupcap:"⩆",CupCap:"≍",cup:"∪",Cup:"⋓",cupcup:"⩊",cupdot:"⊍",cupor:"⩅",cups:"∪︀",curarr:"↷",curarrm:"⤼",curlyeqprec:"⋞",curlyeqsucc:"⋟",curlyvee:"⋎",curlywedge:"⋏",curren:"¤",curvearrowleft:"↶",curvearrowright:"↷",cuvee:"⋎",cuwed:"⋏",cwconint:"∲",cwint:"∱",cylcty:"⌭",dagger:"†",Dagger:"‡",daleth:"ℸ",darr:"↓",Darr:"↡",dArr:"⇓",dash:"‐",Dashv:"⫤",dashv:"⊣",dbkarow:"⤏",dblac:"˝",Dcaron:"Ď",dcaron:"ď",Dcy:"Д",dcy:"д",ddagger:"‡",ddarr:"⇊",DD:"ⅅ",dd:"ⅆ",DDotrahd:"⤑",ddotseq:"⩷",deg:"°",Del:"∇",Delta:"Δ",delta:"δ",demptyv:"⦱",dfisht:"⥿",Dfr:"𝔇",dfr:"𝔡",dHar:"⥥",dharl:"⇃",dharr:"⇂",DiacriticalAcute:"´",DiacriticalDot:"˙",DiacriticalDoubleAcute:"˝",DiacriticalGrave:"`",DiacriticalTilde:"˜",diam:"⋄",diamond:"⋄",Diamond:"⋄",diamondsuit:"♦",diams:"♦",die:"¨",DifferentialD:"ⅆ",digamma:"ϝ",disin:"⋲",div:"÷",divide:"÷",divideontimes:"⋇",divonx:"⋇",DJcy:"Ђ",djcy:"ђ",dlcorn:"⌞",dlcrop:"⌍",dollar:"$",Dopf:"𝔻",dopf:"𝕕",Dot:"¨",dot:"˙",DotDot:"⃜",doteq:"≐",doteqdot:"≑",DotEqual:"≐",dotminus:"∸",dotplus:"∔",dotsquare:"⊡",doublebarwedge:"⌆",DoubleContourIntegral:"∯",DoubleDot:"¨",DoubleDownArrow:"⇓",DoubleLeftArrow:"⇐",DoubleLeftRightArrow:"⇔",DoubleLeftTee:"⫤",DoubleLongLeftArrow:"⟸",DoubleLongLeftRightArrow:"⟺",DoubleLongRightArrow:"⟹",DoubleRightArrow:"⇒",DoubleRightTee:"⊨",DoubleUpArrow:"⇑",DoubleUpDownArrow:"⇕",DoubleVerticalBar:"∥",DownArrowBar:"⤓",downarrow:"↓",DownArrow:"↓",Downarrow:"⇓",DownArrowUpArrow:"⇵",DownBreve:"̑",downdownarrows:"⇊",downharpoonleft:"⇃",downharpoonright:"⇂",DownLeftRightVector:"⥐",DownLeftTeeVector:"⥞",DownLeftVectorBar:"⥖",DownLeftVector:"↽",DownRightTeeVector:"⥟",DownRightVectorBar:"⥗",DownRightVector:"⇁",DownTeeArrow:"↧",DownTee:"⊤",drbkarow:"⤐",drcorn:"⌟",drcrop:"⌌",Dscr:"𝒟",dscr:"𝒹",DScy:"Ѕ",dscy:"ѕ",dsol:"⧶",Dstrok:"Đ",dstrok:"đ",dtdot:"⋱",dtri:"▿",dtrif:"▾",duarr:"⇵",duhar:"⥯",dwangle:"⦦",DZcy:"Џ",dzcy:"џ",dzigrarr:"⟿",Eacute:"É",eacute:"é",easter:"⩮",Ecaron:"Ě",ecaron:"ě",Ecirc:"Ê",ecirc:"ê",ecir:"≖",ecolon:"≕",Ecy:"Э",ecy:"э",eDDot:"⩷",Edot:"Ė",edot:"ė",eDot:"≑",ee:"ⅇ",efDot:"≒",Efr:"𝔈",efr:"𝔢",eg:"⪚",Egrave:"È",egrave:"è",egs:"⪖",egsdot:"⪘",el:"⪙",Element:"∈",elinters:"⏧",ell:"ℓ",els:"⪕",elsdot:"⪗",Emacr:"Ē",emacr:"ē",empty:"∅",emptyset:"∅",EmptySmallSquare:"◻",emptyv:"∅",EmptyVerySmallSquare:"▫",emsp13:" ",emsp14:" ",emsp:" ",ENG:"Ŋ",eng:"ŋ",ensp:" ",Eogon:"Ę",eogon:"ę",Eopf:"𝔼",eopf:"𝕖",epar:"⋕",eparsl:"⧣",eplus:"⩱",epsi:"ε",Epsilon:"Ε",epsilon:"ε",epsiv:"ϵ",eqcirc:"≖",eqcolon:"≕",eqsim:"≂",eqslantgtr:"⪖",eqslantless:"⪕",Equal:"⩵",equals:"=",EqualTilde:"≂",equest:"≟",Equilibrium:"⇌",equiv:"≡",equivDD:"⩸",eqvparsl:"⧥",erarr:"⥱",erDot:"≓",escr:"ℯ",Escr:"ℰ",esdot:"≐",Esim:"⩳",esim:"≂",Eta:"Η",eta:"η",ETH:"Ð",eth:"ð",Euml:"Ë",euml:"ë",euro:"€",excl:"!",exist:"∃",Exists:"∃",expectation:"ℰ",exponentiale:"ⅇ",ExponentialE:"ⅇ",fallingdotseq:"≒",Fcy:"Ф",fcy:"ф",female:"♀",ffilig:"ﬃ",fflig:"ﬀ",ffllig:"ﬄ",Ffr:"𝔉",ffr:"𝔣",filig:"ﬁ",FilledSmallSquare:"◼",FilledVerySmallSquare:"▪",fjlig:"fj",flat:"♭",fllig:"ﬂ",fltns:"▱",fnof:"ƒ",Fopf:"𝔽",fopf:"𝕗",forall:"∀",ForAll:"∀",fork:"⋔",forkv:"⫙",Fouriertrf:"ℱ",fpartint:"⨍",frac12:"½",frac13:"⅓",frac14:"¼",frac15:"⅕",frac16:"⅙",frac18:"⅛",frac23:"⅔",frac25:"⅖",frac34:"¾",frac35:"⅗",frac38:"⅜",frac45:"⅘",frac56:"⅚",frac58:"⅝",frac78:"⅞",frasl:"⁄",frown:"⌢",fscr:"𝒻",Fscr:"ℱ",gacute:"ǵ",Gamma:"Γ",gamma:"γ",Gammad:"Ϝ",gammad:"ϝ",gap:"⪆",Gbreve:"Ğ",gbreve:"ğ",Gcedil:"Ģ",Gcirc:"Ĝ",gcirc:"ĝ",Gcy:"Г",gcy:"г",Gdot:"Ġ",gdot:"ġ",ge:"≥",gE:"≧",gEl:"⪌",gel:"⋛",geq:"≥",geqq:"≧",geqslant:"⩾",gescc:"⪩",ges:"⩾",gesdot:"⪀",gesdoto:"⪂",gesdotol:"⪄",gesl:"⋛︀",gesles:"⪔",Gfr:"𝔊",gfr:"𝔤",gg:"≫",Gg:"⋙",ggg:"⋙",gimel:"ℷ",GJcy:"Ѓ",gjcy:"ѓ",gla:"⪥",gl:"≷",glE:"⪒",glj:"⪤",gnap:"⪊",gnapprox:"⪊",gne:"⪈",gnE:"≩",gneq:"⪈",gneqq:"≩",gnsim:"⋧",Gopf:"𝔾",gopf:"𝕘",grave:"`",GreaterEqual:"≥",GreaterEqualLess:"⋛",GreaterFullEqual:"≧",GreaterGreater:"⪢",GreaterLess:"≷",GreaterSlantEqual:"⩾",GreaterTilde:"≳",Gscr:"𝒢",gscr:"ℊ",gsim:"≳",gsime:"⪎",gsiml:"⪐",gtcc:"⪧",gtcir:"⩺",gt:">",GT:">",Gt:"≫",gtdot:"⋗",gtlPar:"⦕",gtquest:"⩼",gtrapprox:"⪆",gtrarr:"⥸",gtrdot:"⋗",gtreqless:"⋛",gtreqqless:"⪌",gtrless:"≷",gtrsim:"≳",gvertneqq:"≩︀",gvnE:"≩︀",Hacek:"ˇ",hairsp:" ",half:"½",hamilt:"ℋ",HARDcy:"Ъ",hardcy:"ъ",harrcir:"⥈",harr:"↔",hArr:"⇔",harrw:"↭",Hat:"^",hbar:"ℏ",Hcirc:"Ĥ",hcirc:"ĥ",hearts:"♥",heartsuit:"♥",hellip:"…",hercon:"⊹",hfr:"𝔥",Hfr:"ℌ",HilbertSpace:"ℋ",hksearow:"⤥",hkswarow:"⤦",hoarr:"⇿",homtht:"∻",hookleftarrow:"↩",hookrightarrow:"↪",hopf:"𝕙",Hopf:"ℍ",horbar:"―",HorizontalLine:"─",hscr:"𝒽",Hscr:"ℋ",hslash:"ℏ",Hstrok:"Ħ",hstrok:"ħ",HumpDownHump:"≎",HumpEqual:"≏",hybull:"⁃",hyphen:"‐",Iacute:"Í",iacute:"í",ic:"⁣",Icirc:"Î",icirc:"î",Icy:"И",icy:"и",Idot:"İ",IEcy:"Е",iecy:"е",iexcl:"¡",iff:"⇔",ifr:"𝔦",Ifr:"ℑ",Igrave:"Ì",igrave:"ì",ii:"ⅈ",iiiint:"⨌",iiint:"∭",iinfin:"⧜",iiota:"℩",IJlig:"Ĳ",ijlig:"ĳ",Imacr:"Ī",imacr:"ī",image:"ℑ",ImaginaryI:"ⅈ",imagline:"ℐ",imagpart:"ℑ",imath:"ı",Im:"ℑ",imof:"⊷",imped:"Ƶ",Implies:"⇒",incare:"℅",in:"∈",infin:"∞",infintie:"⧝",inodot:"ı",intcal:"⊺",int:"∫",Int:"∬",integers:"ℤ",Integral:"∫",intercal:"⊺",Intersection:"⋂",intlarhk:"⨗",intprod:"⨼",InvisibleComma:"⁣",InvisibleTimes:"⁢",IOcy:"Ё",iocy:"ё",Iogon:"Į",iogon:"į",Iopf:"𝕀",iopf:"𝕚",Iota:"Ι",iota:"ι",iprod:"⨼",iquest:"¿",iscr:"𝒾",Iscr:"ℐ",isin:"∈",isindot:"⋵",isinE:"⋹",isins:"⋴",isinsv:"⋳",isinv:"∈",it:"⁢",Itilde:"Ĩ",itilde:"ĩ",Iukcy:"І",iukcy:"і",Iuml:"Ï",iuml:"ï",Jcirc:"Ĵ",jcirc:"ĵ",Jcy:"Й",jcy:"й",Jfr:"𝔍",jfr:"𝔧",jmath:"ȷ",Jopf:"𝕁",jopf:"𝕛",Jscr:"𝒥",jscr:"𝒿",Jsercy:"Ј",jsercy:"ј",Jukcy:"Є",jukcy:"є",Kappa:"Κ",kappa:"κ",kappav:"ϰ",Kcedil:"Ķ",kcedil:"ķ",Kcy:"К",kcy:"к",Kfr:"𝔎",kfr:"𝔨",kgreen:"ĸ",KHcy:"Х",khcy:"х",KJcy:"Ќ",kjcy:"ќ",Kopf:"𝕂",kopf:"𝕜",Kscr:"𝒦",kscr:"𝓀",lAarr:"⇚",Lacute:"Ĺ",lacute:"ĺ",laemptyv:"⦴",lagran:"ℒ",Lambda:"Λ",lambda:"λ",lang:"⟨",Lang:"⟪",langd:"⦑",langle:"⟨",lap:"⪅",Laplacetrf:"ℒ",laquo:"«",larrb:"⇤",larrbfs:"⤟",larr:"←",Larr:"↞",lArr:"⇐",larrfs:"⤝",larrhk:"↩",larrlp:"↫",larrpl:"⤹",larrsim:"⥳",larrtl:"↢",latail:"⤙",lAtail:"⤛",lat:"⪫",late:"⪭",lates:"⪭︀",lbarr:"⤌",lBarr:"⤎",lbbrk:"❲",lbrace:"{",lbrack:"[",lbrke:"⦋",lbrksld:"⦏",lbrkslu:"⦍",Lcaron:"Ľ",lcaron:"ľ",Lcedil:"Ļ",lcedil:"ļ",lceil:"⌈",lcub:"{",Lcy:"Л",lcy:"л",ldca:"⤶",ldquo:"“",ldquor:"„",ldrdhar:"⥧",ldrushar:"⥋",ldsh:"↲",le:"≤",lE:"≦",LeftAngleBracket:"⟨",LeftArrowBar:"⇤",leftarrow:"←",LeftArrow:"←",Leftarrow:"⇐",LeftArrowRightArrow:"⇆",leftarrowtail:"↢",LeftCeiling:"⌈",LeftDoubleBracket:"⟦",LeftDownTeeVector:"⥡",LeftDownVectorBar:"⥙",LeftDownVector:"⇃",LeftFloor:"⌊",leftharpoondown:"↽",leftharpoonup:"↼",leftleftarrows:"⇇",leftrightarrow:"↔",LeftRightArrow:"↔",Leftrightarrow:"⇔",leftrightarrows:"⇆",leftrightharpoons:"⇋",leftrightsquigarrow:"↭",LeftRightVector:"⥎",LeftTeeArrow:"↤",LeftTee:"⊣",LeftTeeVector:"⥚",leftthreetimes:"⋋",LeftTriangleBar:"⧏",LeftTriangle:"⊲",LeftTriangleEqual:"⊴",LeftUpDownVector:"⥑",LeftUpTeeVector:"⥠",LeftUpVectorBar:"⥘",LeftUpVector:"↿",LeftVectorBar:"⥒",LeftVector:"↼",lEg:"⪋",leg:"⋚",leq:"≤",leqq:"≦",leqslant:"⩽",lescc:"⪨",les:"⩽",lesdot:"⩿",lesdoto:"⪁",lesdotor:"⪃",lesg:"⋚︀",lesges:"⪓",lessapprox:"⪅",lessdot:"⋖",lesseqgtr:"⋚",lesseqqgtr:"⪋",LessEqualGreater:"⋚",LessFullEqual:"≦",LessGreater:"≶",lessgtr:"≶",LessLess:"⪡",lesssim:"≲",LessSlantEqual:"⩽",LessTilde:"≲",lfisht:"⥼",lfloor:"⌊",Lfr:"𝔏",lfr:"𝔩",lg:"≶",lgE:"⪑",lHar:"⥢",lhard:"↽",lharu:"↼",lharul:"⥪",lhblk:"▄",LJcy:"Љ",ljcy:"љ",llarr:"⇇",ll:"≪",Ll:"⋘",llcorner:"⌞",Lleftarrow:"⇚",llhard:"⥫",lltri:"◺",Lmidot:"Ŀ",lmidot:"ŀ",lmoustache:"⎰",lmoust:"⎰",lnap:"⪉",lnapprox:"⪉",lne:"⪇",lnE:"≨",lneq:"⪇",lneqq:"≨",lnsim:"⋦",loang:"⟬",loarr:"⇽",lobrk:"⟦",longleftarrow:"⟵",LongLeftArrow:"⟵",Longleftarrow:"⟸",longleftrightarrow:"⟷",LongLeftRightArrow:"⟷",Longleftrightarrow:"⟺",longmapsto:"⟼",longrightarrow:"⟶",LongRightArrow:"⟶",Longrightarrow:"⟹",looparrowleft:"↫",looparrowright:"↬",lopar:"⦅",Lopf:"𝕃",lopf:"𝕝",loplus:"⨭",lotimes:"⨴",lowast:"∗",lowbar:"_",LowerLeftArrow:"↙",LowerRightArrow:"↘",loz:"◊",lozenge:"◊",lozf:"⧫",lpar:"(",lparlt:"⦓",lrarr:"⇆",lrcorner:"⌟",lrhar:"⇋",lrhard:"⥭",lrm:"‎",lrtri:"⊿",lsaquo:"‹",lscr:"𝓁",Lscr:"ℒ",lsh:"↰",Lsh:"↰",lsim:"≲",lsime:"⪍",lsimg:"⪏",lsqb:"[",lsquo:"‘",lsquor:"‚",Lstrok:"Ł",lstrok:"ł",ltcc:"⪦",ltcir:"⩹",lt:"<",LT:"<",Lt:"≪",ltdot:"⋖",lthree:"⋋",ltimes:"⋉",ltlarr:"⥶",ltquest:"⩻",ltri:"◃",ltrie:"⊴",ltrif:"◂",ltrPar:"⦖",lurdshar:"⥊",luruhar:"⥦",lvertneqq:"≨︀",lvnE:"≨︀",macr:"¯",male:"♂",malt:"✠",maltese:"✠",Map:"⤅",map:"↦",mapsto:"↦",mapstodown:"↧",mapstoleft:"↤",mapstoup:"↥",marker:"▮",mcomma:"⨩",Mcy:"М",mcy:"м",mdash:"—",mDDot:"∺",measuredangle:"∡",MediumSpace:" ",Mellintrf:"ℳ",Mfr:"𝔐",mfr:"𝔪",mho:"℧",micro:"µ",midast:"*",midcir:"⫰",mid:"∣",middot:"·",minusb:"⊟",minus:"−",minusd:"∸",minusdu:"⨪",MinusPlus:"∓",mlcp:"⫛",mldr:"…",mnplus:"∓",models:"⊧",Mopf:"𝕄",mopf:"𝕞",mp:"∓",mscr:"𝓂",Mscr:"ℳ",mstpos:"∾",Mu:"Μ",mu:"μ",multimap:"⊸",mumap:"⊸",nabla:"∇",Nacute:"Ń",nacute:"ń",nang:"∠⃒",nap:"≉",napE:"⩰̸",napid:"≋̸",napos:"ŉ",napprox:"≉",natural:"♮",naturals:"ℕ",natur:"♮",nbsp:" ",nbump:"≎̸",nbumpe:"≏̸",ncap:"⩃",Ncaron:"Ň",ncaron:"ň",Ncedil:"Ņ",ncedil:"ņ",ncong:"≇",ncongdot:"⩭̸",ncup:"⩂",Ncy:"Н",ncy:"н",ndash:"–",nearhk:"⤤",nearr:"↗",neArr:"⇗",nearrow:"↗",ne:"≠",nedot:"≐̸",NegativeMediumSpace:"​",NegativeThickSpace:"​",NegativeThinSpace:"​",NegativeVeryThinSpace:"​",nequiv:"≢",nesear:"⤨",nesim:"≂̸",NestedGreaterGreater:"≫",NestedLessLess:"≪",NewLine:"\n",nexist:"∄",nexists:"∄",Nfr:"𝔑",nfr:"𝔫",ngE:"≧̸",nge:"≱",ngeq:"≱",ngeqq:"≧̸",ngeqslant:"⩾̸",nges:"⩾̸",nGg:"⋙̸",ngsim:"≵",nGt:"≫⃒",ngt:"≯",ngtr:"≯",nGtv:"≫̸",nharr:"↮",nhArr:"⇎",nhpar:"⫲",ni:"∋",nis:"⋼",nisd:"⋺",niv:"∋",NJcy:"Њ",njcy:"њ",nlarr:"↚",nlArr:"⇍",nldr:"‥",nlE:"≦̸",nle:"≰",nleftarrow:"↚",nLeftarrow:"⇍",nleftrightarrow:"↮",nLeftrightarrow:"⇎",nleq:"≰",nleqq:"≦̸",nleqslant:"⩽̸",nles:"⩽̸",nless:"≮",nLl:"⋘̸",nlsim:"≴",nLt:"≪⃒",nlt:"≮",nltri:"⋪",nltrie:"⋬",nLtv:"≪̸",nmid:"∤",NoBreak:"⁠",NonBreakingSpace:" ",nopf:"𝕟",Nopf:"ℕ",Not:"⫬",not:"¬",NotCongruent:"≢",NotCupCap:"≭",NotDoubleVerticalBar:"∦",NotElement:"∉",NotEqual:"≠",NotEqualTilde:"≂̸",NotExists:"∄",NotGreater:"≯",NotGreaterEqual:"≱",NotGreaterFullEqual:"≧̸",NotGreaterGreater:"≫̸",NotGreaterLess:"≹",NotGreaterSlantEqual:"⩾̸",NotGreaterTilde:"≵",NotHumpDownHump:"≎̸",NotHumpEqual:"≏̸",notin:"∉",notindot:"⋵̸",notinE:"⋹̸",notinva:"∉",notinvb:"⋷",notinvc:"⋶",NotLeftTriangleBar:"⧏̸",NotLeftTriangle:"⋪",NotLeftTriangleEqual:"⋬",NotLess:"≮",NotLessEqual:"≰",NotLessGreater:"≸",NotLessLess:"≪̸",NotLessSlantEqual:"⩽̸",NotLessTilde:"≴",NotNestedGreaterGreater:"⪢̸",NotNestedLessLess:"⪡̸",notni:"∌",notniva:"∌",notnivb:"⋾",notnivc:"⋽",NotPrecedes:"⊀",NotPrecedesEqual:"⪯̸",NotPrecedesSlantEqual:"⋠",NotReverseElement:"∌",NotRightTriangleBar:"⧐̸",NotRightTriangle:"⋫",NotRightTriangleEqual:"⋭",NotSquareSubset:"⊏̸",NotSquareSubsetEqual:"⋢",NotSquareSuperset:"⊐̸",NotSquareSupersetEqual:"⋣",NotSubset:"⊂⃒",NotSubsetEqual:"⊈",NotSucceeds:"⊁",NotSucceedsEqual:"⪰̸",NotSucceedsSlantEqual:"⋡",NotSucceedsTilde:"≿̸",NotSuperset:"⊃⃒",NotSupersetEqual:"⊉",NotTilde:"≁",NotTildeEqual:"≄",NotTildeFullEqual:"≇",NotTildeTilde:"≉",NotVerticalBar:"∤",nparallel:"∦",npar:"∦",nparsl:"⫽⃥",npart:"∂̸",npolint:"⨔",npr:"⊀",nprcue:"⋠",nprec:"⊀",npreceq:"⪯̸",npre:"⪯̸",nrarrc:"⤳̸",nrarr:"↛",nrArr:"⇏",nrarrw:"↝̸",nrightarrow:"↛",nRightarrow:"⇏",nrtri:"⋫",nrtrie:"⋭",nsc:"⊁",nsccue:"⋡",nsce:"⪰̸",Nscr:"𝒩",nscr:"𝓃",nshortmid:"∤",nshortparallel:"∦",nsim:"≁",nsime:"≄",nsimeq:"≄",nsmid:"∤",nspar:"∦",nsqsube:"⋢",nsqsupe:"⋣",nsub:"⊄",nsubE:"⫅̸",nsube:"⊈",nsubset:"⊂⃒",nsubseteq:"⊈",nsubseteqq:"⫅̸",nsucc:"⊁",nsucceq:"⪰̸",nsup:"⊅",nsupE:"⫆̸",nsupe:"⊉",nsupset:"⊃⃒",nsupseteq:"⊉",nsupseteqq:"⫆̸",ntgl:"≹",Ntilde:"Ñ",ntilde:"ñ",ntlg:"≸",ntriangleleft:"⋪",ntrianglelefteq:"⋬",ntriangleright:"⋫",ntrianglerighteq:"⋭",Nu:"Ν",nu:"ν",num:"#",numero:"№",numsp:" ",nvap:"≍⃒",nvdash:"⊬",nvDash:"⊭",nVdash:"⊮",nVDash:"⊯",nvge:"≥⃒",nvgt:">⃒",nvHarr:"⤄",nvinfin:"⧞",nvlArr:"⤂",nvle:"≤⃒",nvlt:"<⃒",nvltrie:"⊴⃒",nvrArr:"⤃",nvrtrie:"⊵⃒",nvsim:"∼⃒",nwarhk:"⤣",nwarr:"↖",nwArr:"⇖",nwarrow:"↖",nwnear:"⤧",Oacute:"Ó",oacute:"ó",oast:"⊛",Ocirc:"Ô",ocirc:"ô",ocir:"⊚",Ocy:"О",ocy:"о",odash:"⊝",Odblac:"Ő",odblac:"ő",odiv:"⨸",odot:"⊙",odsold:"⦼",OElig:"Œ",oelig:"œ",ofcir:"⦿",Ofr:"𝔒",ofr:"𝔬",ogon:"˛",Ograve:"Ò",ograve:"ò",ogt:"⧁",ohbar:"⦵",ohm:"Ω",oint:"∮",olarr:"↺",olcir:"⦾",olcross:"⦻",oline:"‾",olt:"⧀",Omacr:"Ō",omacr:"ō",Omega:"Ω",omega:"ω",Omicron:"Ο",omicron:"ο",omid:"⦶",ominus:"⊖",Oopf:"𝕆",oopf:"𝕠",opar:"⦷",OpenCurlyDoubleQuote:"“",OpenCurlyQuote:"‘",operp:"⦹",oplus:"⊕",orarr:"↻",Or:"⩔",or:"∨",ord:"⩝",order:"ℴ",orderof:"ℴ",ordf:"ª",ordm:"º",origof:"⊶",oror:"⩖",orslope:"⩗",orv:"⩛",oS:"Ⓢ",Oscr:"𝒪",oscr:"ℴ",Oslash:"Ø",oslash:"ø",osol:"⊘",Otilde:"Õ",otilde:"õ",otimesas:"⨶",Otimes:"⨷",otimes:"⊗",Ouml:"Ö",ouml:"ö",ovbar:"⌽",OverBar:"‾",OverBrace:"⏞",OverBracket:"⎴",OverParenthesis:"⏜",para:"¶",parallel:"∥",par:"∥",parsim:"⫳",parsl:"⫽",part:"∂",PartialD:"∂",Pcy:"П",pcy:"п",percnt:"%",period:".",permil:"‰",perp:"⊥",pertenk:"‱",Pfr:"𝔓",pfr:"𝔭",Phi:"Φ",phi:"φ",phiv:"ϕ",phmmat:"ℳ",phone:"☎",Pi:"Π",pi:"π",pitchfork:"⋔",piv:"ϖ",planck:"ℏ",planckh:"ℎ",plankv:"ℏ",plusacir:"⨣",plusb:"⊞",pluscir:"⨢",plus:"+",plusdo:"∔",plusdu:"⨥",pluse:"⩲",PlusMinus:"±",plusmn:"±",plussim:"⨦",plustwo:"⨧",pm:"±",Poincareplane:"ℌ",pointint:"⨕",popf:"𝕡",Popf:"ℙ",pound:"£",prap:"⪷",Pr:"⪻",pr:"≺",prcue:"≼",precapprox:"⪷",prec:"≺",preccurlyeq:"≼",Precedes:"≺",PrecedesEqual:"⪯",PrecedesSlantEqual:"≼",PrecedesTilde:"≾",preceq:"⪯",precnapprox:"⪹",precneqq:"⪵",precnsim:"⋨",pre:"⪯",prE:"⪳",precsim:"≾",prime:"′",Prime:"″",primes:"ℙ",prnap:"⪹",prnE:"⪵",prnsim:"⋨",prod:"∏",Product:"∏",profalar:"⌮",profline:"⌒",profsurf:"⌓",prop:"∝",Proportional:"∝",Proportion:"∷",propto:"∝",prsim:"≾",prurel:"⊰",Pscr:"𝒫",pscr:"𝓅",Psi:"Ψ",psi:"ψ",puncsp:" ",Qfr:"𝔔",qfr:"𝔮",qint:"⨌",qopf:"𝕢",Qopf:"ℚ",qprime:"⁗",Qscr:"𝒬",qscr:"𝓆",quaternions:"ℍ",quatint:"⨖",quest:"?",questeq:"≟",quot:'"',QUOT:'"',rAarr:"⇛",race:"∽̱",Racute:"Ŕ",racute:"ŕ",radic:"√",raemptyv:"⦳",rang:"⟩",Rang:"⟫",rangd:"⦒",range:"⦥",rangle:"⟩",raquo:"»",rarrap:"⥵",rarrb:"⇥",rarrbfs:"⤠",rarrc:"⤳",rarr:"→",Rarr:"↠",rArr:"⇒",rarrfs:"⤞",rarrhk:"↪",rarrlp:"↬",rarrpl:"⥅",rarrsim:"⥴",Rarrtl:"⤖",rarrtl:"↣",rarrw:"↝",ratail:"⤚",rAtail:"⤜",ratio:"∶",rationals:"ℚ",rbarr:"⤍",rBarr:"⤏",RBarr:"⤐",rbbrk:"❳",rbrace:"}",rbrack:"]",rbrke:"⦌",rbrksld:"⦎",rbrkslu:"⦐",Rcaron:"Ř",rcaron:"ř",Rcedil:"Ŗ",rcedil:"ŗ",rceil:"⌉",rcub:"}",Rcy:"Р",rcy:"р",rdca:"⤷",rdldhar:"⥩",rdquo:"”",rdquor:"”",rdsh:"↳",real:"ℜ",realine:"ℛ",realpart:"ℜ",reals:"ℝ",Re:"ℜ",rect:"▭",reg:"®",REG:"®",ReverseElement:"∋",ReverseEquilibrium:"⇋",ReverseUpEquilibrium:"⥯",rfisht:"⥽",rfloor:"⌋",rfr:"𝔯",Rfr:"ℜ",rHar:"⥤",rhard:"⇁",rharu:"⇀",rharul:"⥬",Rho:"Ρ",rho:"ρ",rhov:"ϱ",RightAngleBracket:"⟩",RightArrowBar:"⇥",rightarrow:"→",RightArrow:"→",Rightarrow:"⇒",RightArrowLeftArrow:"⇄",rightarrowtail:"↣",RightCeiling:"⌉",RightDoubleBracket:"⟧",RightDownTeeVector:"⥝",RightDownVectorBar:"⥕",RightDownVector:"⇂",RightFloor:"⌋",rightharpoondown:"⇁",rightharpoonup:"⇀",rightleftarrows:"⇄",rightleftharpoons:"⇌",rightrightarrows:"⇉",rightsquigarrow:"↝",RightTeeArrow:"↦",RightTee:"⊢",RightTeeVector:"⥛",rightthreetimes:"⋌",RightTriangleBar:"⧐",RightTriangle:"⊳",RightTriangleEqual:"⊵",RightUpDownVector:"⥏",RightUpTeeVector:"⥜",RightUpVectorBar:"⥔",RightUpVector:"↾",RightVectorBar:"⥓",RightVector:"⇀",ring:"˚",risingdotseq:"≓",rlarr:"⇄",rlhar:"⇌",rlm:"‏",rmoustache:"⎱",rmoust:"⎱",rnmid:"⫮",roang:"⟭",roarr:"⇾",robrk:"⟧",ropar:"⦆",ropf:"𝕣",Ropf:"ℝ",roplus:"⨮",rotimes:"⨵",RoundImplies:"⥰",rpar:")",rpargt:"⦔",rppolint:"⨒",rrarr:"⇉",Rrightarrow:"⇛",rsaquo:"›",rscr:"𝓇",Rscr:"ℛ",rsh:"↱",Rsh:"↱",rsqb:"]",rsquo:"’",rsquor:"’",rthree:"⋌",rtimes:"⋊",rtri:"▹",rtrie:"⊵",rtrif:"▸",rtriltri:"⧎",RuleDelayed:"⧴",ruluhar:"⥨",rx:"℞",Sacute:"Ś",sacute:"ś",sbquo:"‚",scap:"⪸",Scaron:"Š",scaron:"š",Sc:"⪼",sc:"≻",sccue:"≽",sce:"⪰",scE:"⪴",Scedil:"Ş",scedil:"ş",Scirc:"Ŝ",scirc:"ŝ",scnap:"⪺",scnE:"⪶",scnsim:"⋩",scpolint:"⨓",scsim:"≿",Scy:"С",scy:"с",sdotb:"⊡",sdot:"⋅",sdote:"⩦",searhk:"⤥",searr:"↘",seArr:"⇘",searrow:"↘",sect:"§",semi:";",seswar:"⤩",setminus:"∖",setmn:"∖",sext:"✶",Sfr:"𝔖",sfr:"𝔰",sfrown:"⌢",sharp:"♯",SHCHcy:"Щ",shchcy:"щ",SHcy:"Ш",shcy:"ш",ShortDownArrow:"↓",ShortLeftArrow:"←",shortmid:"∣",shortparallel:"∥",ShortRightArrow:"→",ShortUpArrow:"↑",shy:"­",Sigma:"Σ",sigma:"σ",sigmaf:"ς",sigmav:"ς",sim:"∼",simdot:"⩪",sime:"≃",simeq:"≃",simg:"⪞",simgE:"⪠",siml:"⪝",simlE:"⪟",simne:"≆",simplus:"⨤",simrarr:"⥲",slarr:"←",SmallCircle:"∘",smallsetminus:"∖",smashp:"⨳",smeparsl:"⧤",smid:"∣",smile:"⌣",smt:"⪪",smte:"⪬",smtes:"⪬︀",SOFTcy:"Ь",softcy:"ь",solbar:"⌿",solb:"⧄",sol:"/",Sopf:"𝕊",sopf:"𝕤",spades:"♠",spadesuit:"♠",spar:"∥",sqcap:"⊓",sqcaps:"⊓︀",sqcup:"⊔",sqcups:"⊔︀",Sqrt:"√",sqsub:"⊏",sqsube:"⊑",sqsubset:"⊏",sqsubseteq:"⊑",sqsup:"⊐",sqsupe:"⊒",sqsupset:"⊐",sqsupseteq:"⊒",square:"□",Square:"□",SquareIntersection:"⊓",SquareSubset:"⊏",SquareSubsetEqual:"⊑",SquareSuperset:"⊐",SquareSupersetEqual:"⊒",SquareUnion:"⊔",squarf:"▪",squ:"□",squf:"▪",srarr:"→",Sscr:"𝒮",sscr:"𝓈",ssetmn:"∖",ssmile:"⌣",sstarf:"⋆",Star:"⋆",star:"☆",starf:"★",straightepsilon:"ϵ",straightphi:"ϕ",strns:"¯",sub:"⊂",Sub:"⋐",subdot:"⪽",subE:"⫅",sube:"⊆",subedot:"⫃",submult:"⫁",subnE:"⫋",subne:"⊊",subplus:"⪿",subrarr:"⥹",subset:"⊂",Subset:"⋐",subseteq:"⊆",subseteqq:"⫅",SubsetEqual:"⊆",subsetneq:"⊊",subsetneqq:"⫋",subsim:"⫇",subsub:"⫕",subsup:"⫓",succapprox:"⪸",succ:"≻",succcurlyeq:"≽",Succeeds:"≻",SucceedsEqual:"⪰",SucceedsSlantEqual:"≽",SucceedsTilde:"≿",succeq:"⪰",succnapprox:"⪺",succneqq:"⪶",succnsim:"⋩",succsim:"≿",SuchThat:"∋",sum:"∑",Sum:"∑",sung:"♪",sup1:"¹",sup2:"²",sup3:"³",sup:"⊃",Sup:"⋑",supdot:"⪾",supdsub:"⫘",supE:"⫆",supe:"⊇",supedot:"⫄",Superset:"⊃",SupersetEqual:"⊇",suphsol:"⟉",suphsub:"⫗",suplarr:"⥻",supmult:"⫂",supnE:"⫌",supne:"⊋",supplus:"⫀",supset:"⊃",Supset:"⋑",supseteq:"⊇",supseteqq:"⫆",supsetneq:"⊋",supsetneqq:"⫌",supsim:"⫈",supsub:"⫔",supsup:"⫖",swarhk:"⤦",swarr:"↙",swArr:"⇙",swarrow:"↙",swnwar:"⤪",szlig:"ß",Tab:"\t",target:"⌖",Tau:"Τ",tau:"τ",tbrk:"⎴",Tcaron:"Ť",tcaron:"ť",Tcedil:"Ţ",tcedil:"ţ",Tcy:"Т",tcy:"т",tdot:"⃛",telrec:"⌕",Tfr:"𝔗",tfr:"𝔱",there4:"∴",therefore:"∴",Therefore:"∴",Theta:"Θ",theta:"θ",thetasym:"ϑ",thetav:"ϑ",thickapprox:"≈",thicksim:"∼",ThickSpace:"  ",ThinSpace:" ",thinsp:" ",thkap:"≈",thksim:"∼",THORN:"Þ",thorn:"þ",tilde:"˜",Tilde:"∼",TildeEqual:"≃",TildeFullEqual:"≅",TildeTilde:"≈",timesbar:"⨱",timesb:"⊠",times:"×",timesd:"⨰",tint:"∭",toea:"⤨",topbot:"⌶",topcir:"⫱",top:"⊤",Topf:"𝕋",topf:"𝕥",topfork:"⫚",tosa:"⤩",tprime:"‴",trade:"™",TRADE:"™",triangle:"▵",triangledown:"▿",triangleleft:"◃",trianglelefteq:"⊴",triangleq:"≜",triangleright:"▹",trianglerighteq:"⊵",tridot:"◬",trie:"≜",triminus:"⨺",TripleDot:"⃛",triplus:"⨹",trisb:"⧍",tritime:"⨻",trpezium:"⏢",Tscr:"𝒯",tscr:"𝓉",TScy:"Ц",tscy:"ц",TSHcy:"Ћ",tshcy:"ћ",Tstrok:"Ŧ",tstrok:"ŧ",twixt:"≬",twoheadleftarrow:"↞",twoheadrightarrow:"↠",Uacute:"Ú",uacute:"ú",uarr:"↑",Uarr:"↟",uArr:"⇑",Uarrocir:"⥉",Ubrcy:"Ў",ubrcy:"ў",Ubreve:"Ŭ",ubreve:"ŭ",Ucirc:"Û",ucirc:"û",Ucy:"У",ucy:"у",udarr:"⇅",Udblac:"Ű",udblac:"ű",udhar:"⥮",ufisht:"⥾",Ufr:"𝔘",ufr:"𝔲",Ugrave:"Ù",ugrave:"ù",uHar:"⥣",uharl:"↿",uharr:"↾",uhblk:"▀",ulcorn:"⌜",ulcorner:"⌜",ulcrop:"⌏",ultri:"◸",Umacr:"Ū",umacr:"ū",uml:"¨",UnderBar:"_",UnderBrace:"⏟",UnderBracket:"⎵",UnderParenthesis:"⏝",Union:"⋃",UnionPlus:"⊎",Uogon:"Ų",uogon:"ų",Uopf:"𝕌",uopf:"𝕦",UpArrowBar:"⤒",uparrow:"↑",UpArrow:"↑",Uparrow:"⇑",UpArrowDownArrow:"⇅",updownarrow:"↕",UpDownArrow:"↕",Updownarrow:"⇕",UpEquilibrium:"⥮",upharpoonleft:"↿",upharpoonright:"↾",uplus:"⊎",UpperLeftArrow:"↖",UpperRightArrow:"↗",upsi:"υ",Upsi:"ϒ",upsih:"ϒ",Upsilon:"Υ",upsilon:"υ",UpTeeArrow:"↥",UpTee:"⊥",upuparrows:"⇈",urcorn:"⌝",urcorner:"⌝",urcrop:"⌎",Uring:"Ů",uring:"ů",urtri:"◹",Uscr:"𝒰",uscr:"𝓊",utdot:"⋰",Utilde:"Ũ",utilde:"ũ",utri:"▵",utrif:"▴",uuarr:"⇈",Uuml:"Ü",uuml:"ü",uwangle:"⦧",vangrt:"⦜",varepsilon:"ϵ",varkappa:"ϰ",varnothing:"∅",varphi:"ϕ",varpi:"ϖ",varpropto:"∝",varr:"↕",vArr:"⇕",varrho:"ϱ",varsigma:"ς",varsubsetneq:"⊊︀",varsubsetneqq:"⫋︀",varsupsetneq:"⊋︀",varsupsetneqq:"⫌︀",vartheta:"ϑ",vartriangleleft:"⊲",vartriangleright:"⊳",vBar:"⫨",Vbar:"⫫",vBarv:"⫩",Vcy:"В",vcy:"в",vdash:"⊢",vDash:"⊨",Vdash:"⊩",VDash:"⊫",Vdashl:"⫦",veebar:"⊻",vee:"∨",Vee:"⋁",veeeq:"≚",vellip:"⋮",verbar:"|",Verbar:"‖",vert:"|",Vert:"‖",VerticalBar:"∣",VerticalLine:"|",VerticalSeparator:"❘",VerticalTilde:"≀",VeryThinSpace:" ",Vfr:"𝔙",vfr:"𝔳",vltri:"⊲",vnsub:"⊂⃒",vnsup:"⊃⃒",Vopf:"𝕍",vopf:"𝕧",vprop:"∝",vrtri:"⊳",Vscr:"𝒱",vscr:"𝓋",vsubnE:"⫋︀",vsubne:"⊊︀",vsupnE:"⫌︀",vsupne:"⊋︀",Vvdash:"⊪",vzigzag:"⦚",Wcirc:"Ŵ",wcirc:"ŵ",wedbar:"⩟",wedge:"∧",Wedge:"⋀",wedgeq:"≙",weierp:"℘",Wfr:"𝔚",wfr:"𝔴",Wopf:"𝕎",wopf:"𝕨",wp:"℘",wr:"≀",wreath:"≀",Wscr:"𝒲",wscr:"𝓌",xcap:"⋂",xcirc:"◯",xcup:"⋃",xdtri:"▽",Xfr:"𝔛",xfr:"𝔵",xharr:"⟷",xhArr:"⟺",Xi:"Ξ",xi:"ξ",xlarr:"⟵",xlArr:"⟸",xmap:"⟼",xnis:"⋻",xodot:"⨀",Xopf:"𝕏",xopf:"𝕩",xoplus:"⨁",xotime:"⨂",xrarr:"⟶",xrArr:"⟹",Xscr:"𝒳",xscr:"𝓍",xsqcup:"⨆",xuplus:"⨄",xutri:"△",xvee:"⋁",xwedge:"⋀",Yacute:"Ý",yacute:"ý",YAcy:"Я",yacy:"я",Ycirc:"Ŷ",ycirc:"ŷ",Ycy:"Ы",ycy:"ы",yen:"¥",Yfr:"𝔜",yfr:"𝔶",YIcy:"Ї",yicy:"ї",Yopf:"𝕐",yopf:"𝕪",Yscr:"𝒴",yscr:"𝓎",YUcy:"Ю",yucy:"ю",yuml:"ÿ",Yuml:"Ÿ",Zacute:"Ź",zacute:"ź",Zcaron:"Ž",zcaron:"ž",Zcy:"З",zcy:"з",Zdot:"Ż",zdot:"ż",zeetrf:"ℨ",ZeroWidthSpace:"​",Zeta:"Ζ",zeta:"ζ",zfr:"𝔷",Zfr:"ℨ",ZHcy:"Ж",zhcy:"ж",zigrarr:"⇝",zopf:"𝕫",Zopf:"ℤ",Zscr:"𝒵",zscr:"𝓏",zwj:"‍",zwnj:"‌"},r=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/,t={};function n(e,r,s){var o,i,a,c,l,u="";for("string"!=typeof r&&(s=r,r=n.defaultChars),void 0===s&&(s=!0),l=function(e){var r,n,s=t[e];if(s)return s;for(s=t[e]=[],r=0;r<128;r++)n=String.fromCharCode(r),/^[0-9a-z]$/i.test(n)?s.push(n):s.push("%"+("0"+r.toString(16).toUpperCase()).slice(-2));for(r=0;r<e.length;r++)s[e.charCodeAt(r)]=e[r];return s}(r),o=0,i=e.length;o<i;o++)if(a=e.charCodeAt(o),s&&37===a&&o+2<i&&/^[0-9a-f]{2}$/i.test(e.slice(o+1,o+3)))u+=e.slice(o,o+3),o+=2;else if(a<128)u+=l[a];else if(a>=55296&&a<=57343){if(a>=55296&&a<=56319&&o+1<i&&(c=e.charCodeAt(o+1))>=56320&&c<=57343){u+=encodeURIComponent(e[o]+e[o+1]),o++;continue}u+="%EF%BF%BD";}else u+=encodeURIComponent(e[o]);return u}n.defaultChars=";/?:@&=+$,-_.!~*'()#",n.componentChars="-_.!~*'()";var s=n,o={};function i(e,r){var t;return "string"!=typeof r&&(r=i.defaultChars),t=function(e){var r,t,n=o[e];if(n)return n;for(n=o[e]=[],r=0;r<128;r++)t=String.fromCharCode(r),n.push(t);for(r=0;r<e.length;r++)t=e.charCodeAt(r),n[t]="%"+("0"+t.toString(16).toUpperCase()).slice(-2);return n}(r),e.replace(/(%[a-f0-9]{2})+/gi,function(e){var r,n,s,o,i,a,c,l="";for(r=0,n=e.length;r<n;r+=3)(s=parseInt(e.slice(r+1,r+3),16))<128?l+=t[s]:192==(224&s)&&r+3<n&&128==(192&(o=parseInt(e.slice(r+4,r+6),16)))?(l+=(c=s<<6&1984|63&o)<128?"��":String.fromCharCode(c),r+=3):224==(240&s)&&r+6<n&&(o=parseInt(e.slice(r+4,r+6),16),i=parseInt(e.slice(r+7,r+9),16),128==(192&o)&&128==(192&i))?(l+=(c=s<<12&61440|o<<6&4032|63&i)<2048||c>=55296&&c<=57343?"���":String.fromCharCode(c),r+=6):240==(248&s)&&r+9<n&&(o=parseInt(e.slice(r+4,r+6),16),i=parseInt(e.slice(r+7,r+9),16),a=parseInt(e.slice(r+10,r+12),16),128==(192&o)&&128==(192&i)&&128==(192&a))?((c=s<<18&1835008|o<<12&258048|i<<6&4032|63&a)<65536||c>1114111?l+="����":(c-=65536,l+=String.fromCharCode(55296+(c>>10),56320+(1023&c))),r+=9):l+="�";return l})}i.defaultChars=";/?:@&=+$,#",i.componentChars="";var a=i;function c(){this.protocol=null,this.slashes=null,this.auth=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.pathname=null;}var l=/^([a-z0-9.+-]+:)/i,u=/:[0-9]*$/,p=/^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,h=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","\t"]),f=["'"].concat(h),d=["%","/","?",";","#"].concat(f),m=["/","?","#"],g=/^[+a-z0-9A-Z_-]{0,63}$/,_=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,k={javascript:!0,"javascript:":!0},b={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};c.prototype.parse=function(e,r){var t,n,s,o,i,a=e;if(a=a.trim(),!r&&1===e.split("#").length){var c=p.exec(a);if(c)return this.pathname=c[1],c[2]&&(this.search=c[2]),this}var u=l.exec(a);if(u&&(u=u[0],s=u.toLowerCase(),this.protocol=u,a=a.substr(u.length)),(r||u||a.match(/^\/\/[^@\/]+@[^@\/]+/))&&(!(i="//"===a.substr(0,2))||u&&k[u]||(a=a.substr(2),this.slashes=!0)),!k[u]&&(i||u&&!b[u])){var h,f,v=-1;for(t=0;t<m.length;t++)-1!==(o=a.indexOf(m[t]))&&(-1===v||o<v)&&(v=o);for(-1!==(f=-1===v?a.lastIndexOf("@"):a.lastIndexOf("@",v))&&(h=a.slice(0,f),a=a.slice(f+1),this.auth=h),v=-1,t=0;t<d.length;t++)-1!==(o=a.indexOf(d[t]))&&(-1===v||o<v)&&(v=o);-1===v&&(v=a.length),":"===a[v-1]&&v--;var C=a.slice(0,v);a=a.slice(v),this.parseHost(C),this.hostname=this.hostname||"";var y="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!y){var A=this.hostname.split(/\./);for(t=0,n=A.length;t<n;t++){var x=A[t];if(x&&!x.match(g)){for(var w="",D=0,E=x.length;D<E;D++)x.charCodeAt(D)>127?w+="x":w+=x[D];if(!w.match(g)){var q=A.slice(0,t),S=A.slice(t+1),F=x.match(_);F&&(q.push(F[1]),S.unshift(F[2])),S.length&&(a=S.join(".")+a),this.hostname=q.join(".");break}}}}this.hostname.length>255&&(this.hostname=""),y&&(this.hostname=this.hostname.substr(1,this.hostname.length-2));}var L=a.indexOf("#");-1!==L&&(this.hash=a.substr(L),a=a.slice(0,L));var z=a.indexOf("?");return -1!==z&&(this.search=a.substr(z),a=a.slice(0,z)),a&&(this.pathname=a),b[s]&&this.hostname&&!this.pathname&&(this.pathname=""),this},c.prototype.parseHost=function(e){var r=u.exec(e);r&&(":"!==(r=r[0])&&(this.port=r.substr(1)),e=e.substr(0,e.length-r.length)),e&&(this.hostname=e);};var v,C,y={encode:s,decode:a,format:function(e){var r="";return r+=e.protocol||"",r+=e.slashes?"//":"",r+=e.auth?e.auth+"@":"",e.hostname&&-1!==e.hostname.indexOf(":")?r+="["+e.hostname+"]":r+=e.hostname||"",r+=e.port?":"+e.port:"",r+=e.pathname||"",r+=e.search||"",r+=e.hash||""},parse:function(e,r){if(e&&e instanceof c)return e;var t=new c;return t.parse(e,r),t}},A=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,x=/[\0-\x1F\x7F-\x9F]/,w=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/,D={Any:A,Cc:x,Cf:/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/,P:r,Z:w},E=(function(t,n){var s=Object.prototype.hasOwnProperty;function o(e,r){return s.call(e,r)}function i(e){return !(e>=55296&&e<=57343||e>=64976&&e<=65007||65535==(65535&e)||65534==(65535&e)||e>=0&&e<=8||11===e||e>=14&&e<=31||e>=127&&e<=159||e>1114111)}function a(e){if(e>65535){var r=55296+((e-=65536)>>10),t=56320+(1023&e);return String.fromCharCode(r,t)}return String.fromCharCode(e)}var c=/\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g,l=new RegExp(c.source+"|"+/&([a-z#][a-z0-9]{1,31});/gi.source,"gi"),u=/^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i,p=/[&<>"]/,h=/[&<>"]/g,f={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"};function d(e){return f[e]}var m=/[.?*+^$[\]\\(){}|-]/g;n.lib={},n.lib.mdurl=y,n.lib.ucmicro=D,n.assign=function(e){return Array.prototype.slice.call(arguments,1).forEach(function(r){if(r){if("object"!=typeof r)throw new TypeError(r+"must be object");Object.keys(r).forEach(function(t){e[t]=r[t];});}}),e},n.isString=function(e){return "[object String]"===function(e){return Object.prototype.toString.call(e)}(e)},n.has=o,n.unescapeMd=function(e){return e.indexOf("\\")<0?e:e.replace(c,"$1")},n.unescapeAll=function(r){return r.indexOf("\\")<0&&r.indexOf("&")<0?r:r.replace(l,function(r,t,n){return t||function(r,t){var n=0;return o(e,t)?e[t]:35===t.charCodeAt(0)&&u.test(t)&&i(n="x"===t[1].toLowerCase()?parseInt(t.slice(2),16):parseInt(t.slice(1),10))?a(n):r}(r,n)})},n.isValidEntityCode=i,n.fromCodePoint=a,n.escapeHtml=function(e){return p.test(e)?e.replace(h,d):e},n.arrayReplaceAt=function(e,r,t){return [].concat(e.slice(0,r),t,e.slice(r+1))},n.isSpace=function(e){switch(e){case 9:case 32:return !0}return !1},n.isWhiteSpace=function(e){if(e>=8192&&e<=8202)return !0;switch(e){case 9:case 10:case 11:case 12:case 13:case 32:case 160:case 5760:case 8239:case 8287:case 12288:return !0}return !1},n.isMdAsciiPunct=function(e){switch(e){case 33:case 34:case 35:case 36:case 37:case 38:case 39:case 40:case 41:case 42:case 43:case 44:case 45:case 46:case 47:case 58:case 59:case 60:case 61:case 62:case 63:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 124:case 125:case 126:return !0;default:return !1}},n.isPunctChar=function(e){return r.test(e)},n.escapeRE=function(e){return e.replace(m,"\\$&")},n.normalizeReference=function(e){return e=e.trim().replace(/\s+/g," "),"Ṿ"==="ẞ".toLowerCase()&&(e=e.replace(/\u1e9e/g,"ß")),e.toLowerCase().toUpperCase()};}(C={path:v,exports:{},require:function(e,r){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==r&&C.path)}},C.exports),C.exports),q=E.unescapeAll,S=E.unescapeAll,F={parseLinkLabel:function(e,r,t){var n,s,o,i,a=-1,c=e.posMax,l=e.pos;for(e.pos=r+1,n=1;e.pos<c;){if(93===(o=e.src.charCodeAt(e.pos))&&0==--n){s=!0;break}if(i=e.pos,e.md.inline.skipToken(e),91===o)if(i===e.pos-1)n++;else if(t)return e.pos=l,-1}return s&&(a=e.pos),e.pos=l,a},parseLinkDestination:function(e,r,t){var n,s,o=r,i={ok:!1,pos:0,lines:0,str:""};if(60===e.charCodeAt(r)){for(r++;r<t;){if(10===(n=e.charCodeAt(r)))return i;if(60===n)return i;if(62===n)return i.pos=r+1,i.str=q(e.slice(o+1,r)),i.ok=!0,i;92===n&&r+1<t?r+=2:r++;}return i}for(s=0;r<t&&32!==(n=e.charCodeAt(r))&&!(n<32||127===n);)if(92===n&&r+1<t){if(32===e.charCodeAt(r+1))break;r+=2;}else {if(40===n&&++s>32)return i;if(41===n){if(0===s)break;s--;}r++;}return o===r?i:0!==s?i:(i.str=q(e.slice(o,r)),i.lines=0,i.pos=r,i.ok=!0,i)},parseLinkTitle:function(e,r,t){var n,s,o=0,i=r,a={ok:!1,pos:0,lines:0,str:""};if(r>=t)return a;if(34!==(s=e.charCodeAt(r))&&39!==s&&40!==s)return a;for(r++,40===s&&(s=41);r<t;){if((n=e.charCodeAt(r))===s)return a.pos=r+1,a.lines=o,a.str=S(e.slice(i+1,r)),a.ok=!0,a;if(40===n&&41===s)return a;10===n?o++:92===n&&r+1<t&&(r++,10===e.charCodeAt(r)&&o++),r++;}return a}},L=E.assign,z=E.unescapeAll,T=E.escapeHtml,I={};function M(){this.rules=L({},I);}I.code_inline=function(e,r,t,n,s){var o=e[r];return "<code"+s.renderAttrs(o)+">"+T(e[r].content)+"</code>"},I.code_block=function(e,r,t,n,s){var o=e[r];return "<pre"+s.renderAttrs(o)+"><code>"+T(e[r].content)+"</code></pre>\n"},I.fence=function(e,r,t,n,s){var o,i,a,c,l,u=e[r],p=u.info?z(u.info).trim():"",h="",f="";return p&&(a=p.split(/(\s+)/g),h=a[0],f=a.slice(2).join("")),0===(o=t.highlight&&t.highlight(u.content,h,f)||T(u.content)).indexOf("<pre")?o+"\n":p?(i=u.attrIndex("class"),c=u.attrs?u.attrs.slice():[],i<0?c.push(["class",t.langPrefix+h]):(c[i]=c[i].slice(),c[i][1]+=" "+t.langPrefix+h),l={attrs:c},"<pre><code"+s.renderAttrs(l)+">"+o+"</code></pre>\n"):"<pre><code"+s.renderAttrs(u)+">"+o+"</code></pre>\n"},I.image=function(e,r,t,n,s){var o=e[r];return o.attrs[o.attrIndex("alt")][1]=s.renderInlineAsText(o.children,t,n),s.renderToken(e,r,t)},I.hardbreak=function(e,r,t){return t.xhtmlOut?"<br />\n":"<br>\n"},I.softbreak=function(e,r,t){return t.breaks?t.xhtmlOut?"<br />\n":"<br>\n":"\n"},I.text=function(e,r){return T(e[r].content)},I.html_block=function(e,r){return e[r].content},I.html_inline=function(e,r){return e[r].content},M.prototype.renderAttrs=function(e){var r,t,n;if(!e.attrs)return "";for(n="",r=0,t=e.attrs.length;r<t;r++)n+=" "+T(e.attrs[r][0])+'="'+T(e.attrs[r][1])+'"';return n},M.prototype.renderToken=function(e,r,t){var n,s="",o=!1,i=e[r];return i.hidden?"":(i.block&&-1!==i.nesting&&r&&e[r-1].hidden&&(s+="\n"),s+=(-1===i.nesting?"</":"<")+i.tag,s+=this.renderAttrs(i),0===i.nesting&&t.xhtmlOut&&(s+=" /"),i.block&&(o=!0,1===i.nesting&&r+1<e.length&&("inline"===(n=e[r+1]).type||n.hidden?o=!1:-1===n.nesting&&n.tag===i.tag&&(o=!1))),s+=o?">\n":">")},M.prototype.renderInline=function(e,r,t){for(var n,s="",o=this.rules,i=0,a=e.length;i<a;i++)n=e[i].type,void 0!==o[n]?s+=o[n](e,i,r,t,this):s+=this.renderToken(e,i,r);return s},M.prototype.renderInlineAsText=function(e,r,t){for(var n="",s=0,o=e.length;s<o;s++)"text"===e[s].type?n+=e[s].content:"image"===e[s].type&&(n+=this.renderInlineAsText(e[s].children,r,t));return n},M.prototype.render=function(e,r,t){var n,s,o,i="",a=this.rules;for(n=0,s=e.length;n<s;n++)"inline"===(o=e[n].type)?i+=this.renderInline(e[n].children,r,t):void 0!==a[o]?i+=a[e[n].type](e,n,r,t,this):i+=this.renderToken(e,n,r,t);return i};var R=M;function B(){this.__rules__=[],this.__cache__=null;}B.prototype.__find__=function(e){for(var r=0;r<this.__rules__.length;r++)if(this.__rules__[r].name===e)return r;return -1},B.prototype.__compile__=function(){var e=this,r=[""];e.__rules__.forEach(function(e){e.enabled&&e.alt.forEach(function(e){r.indexOf(e)<0&&r.push(e);});}),e.__cache__={},r.forEach(function(r){e.__cache__[r]=[],e.__rules__.forEach(function(t){t.enabled&&(r&&t.alt.indexOf(r)<0||e.__cache__[r].push(t.fn));});});},B.prototype.at=function(e,r,t){var n=this.__find__(e),s=t||{};if(-1===n)throw new Error("Parser rule not found: "+e);this.__rules__[n].fn=r,this.__rules__[n].alt=s.alt||[],this.__cache__=null;},B.prototype.before=function(e,r,t,n){var s=this.__find__(e),o=n||{};if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s,0,{name:r,enabled:!0,fn:t,alt:o.alt||[]}),this.__cache__=null;},B.prototype.after=function(e,r,t,n){var s=this.__find__(e),o=n||{};if(-1===s)throw new Error("Parser rule not found: "+e);this.__rules__.splice(s+1,0,{name:r,enabled:!0,fn:t,alt:o.alt||[]}),this.__cache__=null;},B.prototype.push=function(e,r,t){var n=t||{};this.__rules__.push({name:e,enabled:!0,fn:r,alt:n.alt||[]}),this.__cache__=null;},B.prototype.enable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];return e.forEach(function(e){var n=this.__find__(e);if(n<0){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!0,t.push(e);},this),this.__cache__=null,t},B.prototype.enableOnly=function(e,r){Array.isArray(e)||(e=[e]),this.__rules__.forEach(function(e){e.enabled=!1;}),this.enable(e,r);},B.prototype.disable=function(e,r){Array.isArray(e)||(e=[e]);var t=[];return e.forEach(function(e){var n=this.__find__(e);if(n<0){if(r)return;throw new Error("Rules manager: invalid rule name "+e)}this.__rules__[n].enabled=!1,t.push(e);},this),this.__cache__=null,t},B.prototype.getRules=function(e){return null===this.__cache__&&this.__compile__(),this.__cache__[e]||[]};var N=B,O=/\r\n?|\n/g,P=/\0/g,j=E.arrayReplaceAt;function U(e){return /^<\/a\s*>/i.test(e)}var V=/\+-|\.\.|\?\?\?\?|!!!!|,,|--/,Z=/\((c|tm|r|p)\)/i,$=/\((c|tm|r|p)\)/gi,G={c:"©",r:"®",p:"§",tm:"™"};function H(e,r){return G[r.toLowerCase()]}function J(e){var r,t,n=0;for(r=e.length-1;r>=0;r--)"text"!==(t=e[r]).type||n||(t.content=t.content.replace($,H)),"link_open"===t.type&&"auto"===t.info&&n--,"link_close"===t.type&&"auto"===t.info&&n++;}function W(e){var r,t,n=0;for(r=e.length-1;r>=0;r--)"text"!==(t=e[r]).type||n||V.test(t.content)&&(t.content=t.content.replace(/\+-/g,"±").replace(/\.{2,}/g,"…").replace(/([?!])\u2026/g,"$1..").replace(/([?!]){4,}/g,"$1$1$1").replace(/,{2,}/g,",").replace(/(^|[^-])---(?=[^-]|$)/gm,"$1—").replace(/(^|\s)--(?=\s|$)/gm,"$1–").replace(/(^|[^-\s])--(?=[^-\s]|$)/gm,"$1–")),"link_open"===t.type&&"auto"===t.info&&n--,"link_close"===t.type&&"auto"===t.info&&n++;}var Y=E.isWhiteSpace,K=E.isPunctChar,Q=E.isMdAsciiPunct,X=/['"]/,ee=/['"]/g,re="’";function te(e,r,t){return e.substr(0,r)+t+e.substr(r+1)}function ne(e,r){var t,n,s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b,v,C,y;for(v=[],t=0;t<e.length;t++){for(n=e[t],c=e[t].level,k=v.length-1;k>=0&&!(v[k].level<=c);k--);if(v.length=k+1,"text"===n.type){s=n.content,i=0,a=s.length;e:for(;i<a&&(ee.lastIndex=i,o=ee.exec(s));){if(g=_=!0,i=o.index+1,b="'"===o[0],u=32,o.index-1>=0)u=s.charCodeAt(o.index-1);else for(k=t-1;k>=0&&"softbreak"!==e[k].type&&"hardbreak"!==e[k].type;k--)if(e[k].content){u=e[k].content.charCodeAt(e[k].content.length-1);break}if(p=32,i<a)p=s.charCodeAt(i);else for(k=t+1;k<e.length&&"softbreak"!==e[k].type&&"hardbreak"!==e[k].type;k++)if(e[k].content){p=e[k].content.charCodeAt(0);break}if(h=Q(u)||K(String.fromCharCode(u)),f=Q(p)||K(String.fromCharCode(p)),d=Y(u),(m=Y(p))?g=!1:f&&(d||h||(g=!1)),d?_=!1:h&&(m||f||(_=!1)),34===p&&'"'===o[0]&&u>=48&&u<=57&&(_=g=!1),g&&_&&(g=h,_=f),g||_){if(_)for(k=v.length-1;k>=0&&(l=v[k],!(v[k].level<c));k--)if(l.single===b&&v[k].level===c){l=v[k],b?(C=r.md.options.quotes[2],y=r.md.options.quotes[3]):(C=r.md.options.quotes[0],y=r.md.options.quotes[1]),n.content=te(n.content,o.index,y),e[l.token].content=te(e[l.token].content,l.pos,C),i+=y.length-1,l.token===t&&(i+=C.length-1),s=n.content,a=s.length,v.length=k;continue e}g?v.push({token:t,pos:o.index,single:b,level:c}):_&&b&&(n.content=te(n.content,o.index,re));}else b&&(n.content=te(n.content,o.index,re));}}}}function se(e,r,t){this.type=e,this.tag=r,this.attrs=null,this.map=null,this.nesting=t,this.level=0,this.children=null,this.content="",this.markup="",this.info="",this.meta=null,this.block=!1,this.hidden=!1;}se.prototype.attrIndex=function(e){var r,t,n;if(!this.attrs)return -1;for(r=this.attrs,t=0,n=r.length;t<n;t++)if(r[t][0]===e)return t;return -1},se.prototype.attrPush=function(e){this.attrs?this.attrs.push(e):this.attrs=[e];},se.prototype.attrSet=function(e,r){var t=this.attrIndex(e),n=[e,r];t<0?this.attrPush(n):this.attrs[t]=n;},se.prototype.attrGet=function(e){var r=this.attrIndex(e),t=null;return r>=0&&(t=this.attrs[r][1]),t},se.prototype.attrJoin=function(e,r){var t=this.attrIndex(e);t<0?this.attrPush([e,r]):this.attrs[t][1]=this.attrs[t][1]+" "+r;};var oe=se;function ie(e,r,t){this.src=e,this.env=t,this.tokens=[],this.inlineMode=!1,this.md=r;}ie.prototype.Token=oe;var ae=ie,ce=[["normalize",function(e){var r;r=(r=e.src.replace(O,"\n")).replace(P,"�"),e.src=r;}],["block",function(e){var r;e.inlineMode?((r=new e.Token("inline","",0)).content=e.src,r.map=[0,1],r.children=[],e.tokens.push(r)):e.md.block.parse(e.src,e.md,e.env,e.tokens);}],["inline",function(e){var r,t,n,s=e.tokens;for(t=0,n=s.length;t<n;t++)"inline"===(r=s[t]).type&&e.md.inline.parse(r.content,e.md,e.env,r.children);}],["linkify",function(e){var r,t,n,s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b=e.tokens;if(e.md.options.linkify)for(t=0,n=b.length;t<n;t++)if("inline"===b[t].type&&e.md.linkify.pretest(b[t].content))for(s=b[t].children,f=0,r=s.length-1;r>=0;r--)if("link_close"!==(i=s[r]).type){if("html_inline"===i.type&&(k=i.content,/^<a[>\s]/i.test(k)&&f>0&&f--,U(i.content)&&f++),!(f>0)&&"text"===i.type&&e.md.linkify.test(i.content)){for(l=i.content,_=e.md.linkify.match(l),a=[],h=i.level,p=0,c=0;c<_.length;c++)d=_[c].url,m=e.md.normalizeLink(d),e.md.validateLink(m)&&(g=_[c].text,g=_[c].schema?"mailto:"!==_[c].schema||/^mailto:/i.test(g)?e.md.normalizeLinkText(g):e.md.normalizeLinkText("mailto:"+g).replace(/^mailto:/,""):e.md.normalizeLinkText("http://"+g).replace(/^http:\/\//,""),(u=_[c].index)>p&&((o=new e.Token("text","",0)).content=l.slice(p,u),o.level=h,a.push(o)),(o=new e.Token("link_open","a",1)).attrs=[["href",m]],o.level=h++,o.markup="linkify",o.info="auto",a.push(o),(o=new e.Token("text","",0)).content=g,o.level=h,a.push(o),(o=new e.Token("link_close","a",-1)).level=--h,o.markup="linkify",o.info="auto",a.push(o),p=_[c].lastIndex);p<l.length&&((o=new e.Token("text","",0)).content=l.slice(p),o.level=h,a.push(o)),b[t].children=s=j(s,r,a);}}else for(r--;s[r].level!==i.level&&"link_open"!==s[r].type;)r--;}],["replacements",function(e){var r;if(e.md.options.typographer)for(r=e.tokens.length-1;r>=0;r--)"inline"===e.tokens[r].type&&(Z.test(e.tokens[r].content)&&J(e.tokens[r].children),V.test(e.tokens[r].content)&&W(e.tokens[r].children));}],["smartquotes",function(e){var r;if(e.md.options.typographer)for(r=e.tokens.length-1;r>=0;r--)"inline"===e.tokens[r].type&&X.test(e.tokens[r].content)&&ne(e.tokens[r].children,e);}]];function le(){this.ruler=new N;for(var e=0;e<ce.length;e++)this.ruler.push(ce[e][0],ce[e][1]);}le.prototype.process=function(e){var r,t,n;for(n=this.ruler.getRules(""),r=0,t=n.length;r<t;r++)n[r](e);},le.prototype.State=ae;var ue=le,pe=E.isSpace;function he(e,r){var t=e.bMarks[r]+e.tShift[r],n=e.eMarks[r];return e.src.substr(t,n-t)}function fe(e){var r,t=[],n=0,s=e.length,o=!1,i=0,a="";for(r=e.charCodeAt(n);n<s;)124===r&&(o?(a+=e.substring(i,n-1),i=n):(t.push(a+e.substring(i,n)),a="",i=n+1)),o=92===r,n++,r=e.charCodeAt(n);return t.push(a+e.substring(i)),t}var de=E.isSpace,me=E.isSpace,ge=E.isSpace;function _e(e,r){var t,n,s,o;return n=e.bMarks[r]+e.tShift[r],s=e.eMarks[r],42!==(t=e.src.charCodeAt(n++))&&45!==t&&43!==t?-1:n<s&&(o=e.src.charCodeAt(n),!ge(o))?-1:n}function ke(e,r){var t,n=e.bMarks[r]+e.tShift[r],s=n,o=e.eMarks[r];if(s+1>=o)return -1;if((t=e.src.charCodeAt(s++))<48||t>57)return -1;for(;;){if(s>=o)return -1;if(!((t=e.src.charCodeAt(s++))>=48&&t<=57)){if(41===t||46===t)break;return -1}if(s-n>=10)return -1}return s<o&&(t=e.src.charCodeAt(s),!ge(t))?-1:s}var be=E.normalizeReference,ve=E.isSpace,Ce=E.isSpace,ye="<[A-Za-z][A-Za-z0-9\\-]*(?:\\s+[a-zA-Z_:][a-zA-Z0-9:._-]*(?:\\s*=\\s*(?:[^\"'=<>`\\x00-\\x20]+|'[^']*'|\"[^\"]*\"))?)*\\s*\\/?>",Ae="<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>",xe=new RegExp("^(?:"+ye+"|"+Ae+"|\x3c!----\x3e|\x3c!--(?:-?[^>-])(?:-?[^-])*--\x3e|<[?][\\s\\S]*?[?]>|<![A-Z]+\\s+[^>]*>|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>)"),we=new RegExp("^(?:"+ye+"|"+Ae+")"),De={HTML_TAG_RE:xe,HTML_OPEN_CLOSE_TAG_RE:we},Ee=De.HTML_OPEN_CLOSE_TAG_RE,qe=[[/^<(script|pre|style)(?=(\s|>|$))/i,/<\/(script|pre|style)>/i,!0],[/^<!--/,/-->/,!0],[/^<\?/,/\?>/,!0],[/^<![A-Z]/,/>/,!0],[/^<!\[CDATA\[/,/\]\]>/,!0],[new RegExp("^</?("+["address","article","aside","base","basefont","blockquote","body","caption","center","col","colgroup","dd","details","dialog","dir","div","dl","dt","fieldset","figcaption","figure","footer","form","frame","frameset","h1","h2","h3","h4","h5","h6","head","header","hr","html","iframe","legend","li","link","main","menu","menuitem","nav","noframes","ol","optgroup","option","p","param","section","source","summary","table","tbody","td","tfoot","th","thead","title","tr","track","ul"].join("|")+")(?=(\\s|/?>|$))","i"),/^$/,!0],[new RegExp(Ee.source+"\\s*$"),/^$/,!1]],Se=E.isSpace;function Fe(e,r,t,n){var s,o,i,a,c,l,u,p;for(this.src=e,this.md=r,this.env=t,this.tokens=n,this.bMarks=[],this.eMarks=[],this.tShift=[],this.sCount=[],this.bsCount=[],this.blkIndent=0,this.line=0,this.lineMax=0,this.tight=!1,this.ddIndent=-1,this.listIndent=-1,this.parentType="root",this.level=0,this.result="",o=this.src,p=!1,i=a=l=u=0,c=o.length;a<c;a++){if(s=o.charCodeAt(a),!p){if(Se(s)){l++,9===s?u+=4-u%4:u++;continue}p=!0;}10!==s&&a!==c-1||(10!==s&&a++,this.bMarks.push(i),this.eMarks.push(a),this.tShift.push(l),this.sCount.push(u),this.bsCount.push(0),p=!1,l=0,u=0,i=a+1);}this.bMarks.push(o.length),this.eMarks.push(o.length),this.tShift.push(0),this.sCount.push(0),this.bsCount.push(0),this.lineMax=this.bMarks.length-1;}Fe.prototype.push=function(e,r,t){var n=new oe(e,r,t);return n.block=!0,t<0&&this.level--,n.level=this.level,t>0&&this.level++,this.tokens.push(n),n},Fe.prototype.isEmpty=function(e){return this.bMarks[e]+this.tShift[e]>=this.eMarks[e]},Fe.prototype.skipEmptyLines=function(e){for(var r=this.lineMax;e<r&&!(this.bMarks[e]+this.tShift[e]<this.eMarks[e]);e++);return e},Fe.prototype.skipSpaces=function(e){for(var r,t=this.src.length;e<t&&(r=this.src.charCodeAt(e),Se(r));e++);return e},Fe.prototype.skipSpacesBack=function(e,r){if(e<=r)return e;for(;e>r;)if(!Se(this.src.charCodeAt(--e)))return e+1;return e},Fe.prototype.skipChars=function(e,r){for(var t=this.src.length;e<t&&this.src.charCodeAt(e)===r;e++);return e},Fe.prototype.skipCharsBack=function(e,r,t){if(e<=t)return e;for(;e>t;)if(r!==this.src.charCodeAt(--e))return e+1;return e},Fe.prototype.getLines=function(e,r,t,n){var s,o,i,a,c,l,u,p=e;if(e>=r)return "";for(l=new Array(r-e),s=0;p<r;p++,s++){for(o=0,u=a=this.bMarks[p],c=p+1<r||n?this.eMarks[p]+1:this.eMarks[p];a<c&&o<t;){if(i=this.src.charCodeAt(a),Se(i))9===i?o+=4-(o+this.bsCount[p])%4:o++;else {if(!(a-u<this.tShift[p]))break;o++;}a++;}l[s]=o>t?new Array(o-t+1).join(" ")+this.src.slice(a,c):this.src.slice(a,c);}return l.join("")},Fe.prototype.Token=oe;var Le=Fe,ze=[["table",function(e,r,t,n){var s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b;if(r+2>t)return !1;if(l=r+1,e.sCount[l]<e.blkIndent)return !1;if(e.sCount[l]-e.blkIndent>=4)return !1;if((i=e.bMarks[l]+e.tShift[l])>=e.eMarks[l])return !1;if(124!==(s=e.src.charCodeAt(i++))&&45!==s&&58!==s)return !1;for(;i<e.eMarks[l];){if(124!==(s=e.src.charCodeAt(i))&&45!==s&&58!==s&&!pe(s))return !1;i++;}for(o=he(e,r+1),u=o.split("|"),f=[],a=0;a<u.length;a++){if(!(d=u[a].trim())){if(0===a||a===u.length-1)continue;return !1}if(!/^:?-+:?$/.test(d))return !1;58===d.charCodeAt(d.length-1)?f.push(58===d.charCodeAt(0)?"center":"right"):58===d.charCodeAt(0)?f.push("left"):f.push("");}if(-1===(o=he(e,r).trim()).indexOf("|"))return !1;if(e.sCount[r]-e.blkIndent>=4)return !1;if((u=fe(o)).length&&""===u[0]&&u.shift(),u.length&&""===u[u.length-1]&&u.pop(),0===(p=u.length)||p!==f.length)return !1;if(n)return !0;for(_=e.parentType,e.parentType="table",b=e.md.block.ruler.getRules("blockquote"),(h=e.push("table_open","table",1)).map=m=[r,0],(h=e.push("thead_open","thead",1)).map=[r,r+1],(h=e.push("tr_open","tr",1)).map=[r,r+1],a=0;a<u.length;a++)h=e.push("th_open","th",1),f[a]&&(h.attrs=[["style","text-align:"+f[a]]]),(h=e.push("inline","",0)).content=u[a].trim(),h.children=[],h=e.push("th_close","th",-1);for(h=e.push("tr_close","tr",-1),h=e.push("thead_close","thead",-1),l=r+2;l<t&&!(e.sCount[l]<e.blkIndent);l++){for(k=!1,a=0,c=b.length;a<c;a++)if(b[a](e,l,t,!0)){k=!0;break}if(k)break;if(!(o=he(e,l).trim()))break;if(e.sCount[l]-e.blkIndent>=4)break;for((u=fe(o)).length&&""===u[0]&&u.shift(),u.length&&""===u[u.length-1]&&u.pop(),l===r+2&&((h=e.push("tbody_open","tbody",1)).map=g=[r+2,0]),(h=e.push("tr_open","tr",1)).map=[l,l+1],a=0;a<p;a++)h=e.push("td_open","td",1),f[a]&&(h.attrs=[["style","text-align:"+f[a]]]),(h=e.push("inline","",0)).content=u[a]?u[a].trim():"",h.children=[],h=e.push("td_close","td",-1);h=e.push("tr_close","tr",-1);}return g&&(h=e.push("tbody_close","tbody",-1),g[1]=l),h=e.push("table_close","table",-1),m[1]=l,e.parentType=_,e.line=l,!0},["paragraph","reference"]],["code",function(e,r,t){var n,s,o;if(e.sCount[r]-e.blkIndent<4)return !1;for(s=n=r+1;n<t;)if(e.isEmpty(n))n++;else {if(!(e.sCount[n]-e.blkIndent>=4))break;s=++n;}return e.line=s,(o=e.push("code_block","code",0)).content=e.getLines(r,s,4+e.blkIndent,!0),o.map=[r,e.line],!0}],["fence",function(e,r,t,n){var s,o,i,a,c,l,u,p=!1,h=e.bMarks[r]+e.tShift[r],f=e.eMarks[r];if(e.sCount[r]-e.blkIndent>=4)return !1;if(h+3>f)return !1;if(126!==(s=e.src.charCodeAt(h))&&96!==s)return !1;if(c=h,h=e.skipChars(h,s),(o=h-c)<3)return !1;if(u=e.src.slice(c,h),i=e.src.slice(h,f),96===s&&i.indexOf(String.fromCharCode(s))>=0)return !1;if(n)return !0;for(a=r;!(++a>=t||(h=c=e.bMarks[a]+e.tShift[a],f=e.eMarks[a],h<f&&e.sCount[a]<e.blkIndent));)if(e.src.charCodeAt(h)===s&&!(e.sCount[a]-e.blkIndent>=4||(h=e.skipChars(h,s))-c<o||(h=e.skipSpaces(h))<f)){p=!0;break}return o=e.sCount[r],e.line=a+(p?1:0),(l=e.push("fence","code",0)).info=i,l.content=e.getLines(r+1,a,o,!0),l.markup=u,l.map=[r,e.line],!0},["paragraph","reference","blockquote","list"]],["blockquote",function(e,r,t,n){var s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b,v,C,y,A,x=e.lineMax,w=e.bMarks[r]+e.tShift[r],D=e.eMarks[r];if(e.sCount[r]-e.blkIndent>=4)return !1;if(62!==e.src.charCodeAt(w++))return !1;if(n)return !0;for(a=h=e.sCount[r]+1,32===e.src.charCodeAt(w)?(w++,a++,h++,s=!1,b=!0):9===e.src.charCodeAt(w)?(b=!0,(e.bsCount[r]+h)%4==3?(w++,a++,h++,s=!1):s=!0):b=!1,f=[e.bMarks[r]],e.bMarks[r]=w;w<D&&(o=e.src.charCodeAt(w),de(o));)9===o?h+=4-(h+e.bsCount[r]+(s?1:0))%4:h++,w++;for(d=[e.bsCount[r]],e.bsCount[r]=e.sCount[r]+1+(b?1:0),l=w>=D,_=[e.sCount[r]],e.sCount[r]=h-a,k=[e.tShift[r]],e.tShift[r]=w-e.bMarks[r],C=e.md.block.ruler.getRules("blockquote"),g=e.parentType,e.parentType="blockquote",p=r+1;p<t&&(A=e.sCount[p]<e.blkIndent,w=e.bMarks[p]+e.tShift[p],D=e.eMarks[p],!(w>=D));p++)if(62!==e.src.charCodeAt(w++)||A){if(l)break;for(v=!1,i=0,c=C.length;i<c;i++)if(C[i](e,p,t,!0)){v=!0;break}if(v){e.lineMax=p,0!==e.blkIndent&&(f.push(e.bMarks[p]),d.push(e.bsCount[p]),k.push(e.tShift[p]),_.push(e.sCount[p]),e.sCount[p]-=e.blkIndent);break}f.push(e.bMarks[p]),d.push(e.bsCount[p]),k.push(e.tShift[p]),_.push(e.sCount[p]),e.sCount[p]=-1;}else {for(a=h=e.sCount[p]+1,32===e.src.charCodeAt(w)?(w++,a++,h++,s=!1,b=!0):9===e.src.charCodeAt(w)?(b=!0,(e.bsCount[p]+h)%4==3?(w++,a++,h++,s=!1):s=!0):b=!1,f.push(e.bMarks[p]),e.bMarks[p]=w;w<D&&(o=e.src.charCodeAt(w),de(o));)9===o?h+=4-(h+e.bsCount[p]+(s?1:0))%4:h++,w++;l=w>=D,d.push(e.bsCount[p]),e.bsCount[p]=e.sCount[p]+1+(b?1:0),_.push(e.sCount[p]),e.sCount[p]=h-a,k.push(e.tShift[p]),e.tShift[p]=w-e.bMarks[p];}for(m=e.blkIndent,e.blkIndent=0,(y=e.push("blockquote_open","blockquote",1)).markup=">",y.map=u=[r,0],e.md.block.tokenize(e,r,p),(y=e.push("blockquote_close","blockquote",-1)).markup=">",e.lineMax=x,e.parentType=g,u[1]=e.line,i=0;i<k.length;i++)e.bMarks[i+r]=f[i],e.tShift[i+r]=k[i],e.sCount[i+r]=_[i],e.bsCount[i+r]=d[i];return e.blkIndent=m,!0},["paragraph","reference","blockquote","list"]],["hr",function(e,r,t,n){var s,o,i,a,c=e.bMarks[r]+e.tShift[r],l=e.eMarks[r];if(e.sCount[r]-e.blkIndent>=4)return !1;if(42!==(s=e.src.charCodeAt(c++))&&45!==s&&95!==s)return !1;for(o=1;c<l;){if((i=e.src.charCodeAt(c++))!==s&&!me(i))return !1;i===s&&o++;}return !(o<3)&&(!!n||(e.line=r+1,(a=e.push("hr","hr",0)).map=[r,e.line],a.markup=Array(o+1).join(String.fromCharCode(s)),!0))},["paragraph","reference","blockquote","list"]],["list",function(e,r,t,n){var s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b,v,C,y,A,x,w,D,E,q,S,F,L,z=!1,T=!0;if(e.sCount[r]-e.blkIndent>=4)return !1;if(e.listIndent>=0&&e.sCount[r]-e.listIndent>=4&&e.sCount[r]<e.blkIndent)return !1;if(n&&"paragraph"===e.parentType&&e.tShift[r]>=e.blkIndent&&(z=!0),(D=ke(e,r))>=0){if(u=!0,q=e.bMarks[r]+e.tShift[r],g=Number(e.src.substr(q,D-q-1)),z&&1!==g)return !1}else {if(!((D=_e(e,r))>=0))return !1;u=!1;}if(z&&e.skipSpaces(D)>=e.eMarks[r])return !1;if(m=e.src.charCodeAt(D-1),n)return !0;for(d=e.tokens.length,u?(L=e.push("ordered_list_open","ol",1),1!==g&&(L.attrs=[["start",g]])):L=e.push("bullet_list_open","ul",1),L.map=f=[r,0],L.markup=String.fromCharCode(m),k=r,E=!1,F=e.md.block.ruler.getRules("list"),C=e.parentType,e.parentType="list";k<t;){for(w=D,_=e.eMarks[k],l=b=e.sCount[k]+D-(e.bMarks[r]+e.tShift[r]);w<_;){if(9===(s=e.src.charCodeAt(w)))b+=4-(b+e.bsCount[k])%4;else {if(32!==s)break;b++;}w++;}if((c=(o=w)>=_?1:b-l)>4&&(c=1),a=l+c,(L=e.push("list_item_open","li",1)).markup=String.fromCharCode(m),L.map=p=[r,0],x=e.tight,A=e.tShift[r],y=e.sCount[r],v=e.listIndent,e.listIndent=e.blkIndent,e.blkIndent=a,e.tight=!0,e.tShift[r]=o-e.bMarks[r],e.sCount[r]=b,o>=_&&e.isEmpty(r+1)?e.line=Math.min(e.line+2,t):e.md.block.tokenize(e,r,t,!0),e.tight&&!E||(T=!1),E=e.line-r>1&&e.isEmpty(e.line-1),e.blkIndent=e.listIndent,e.listIndent=v,e.tShift[r]=A,e.sCount[r]=y,e.tight=x,(L=e.push("list_item_close","li",-1)).markup=String.fromCharCode(m),k=r=e.line,p[1]=k,o=e.bMarks[r],k>=t)break;if(e.sCount[k]<e.blkIndent)break;if(e.sCount[r]-e.blkIndent>=4)break;for(S=!1,i=0,h=F.length;i<h;i++)if(F[i](e,k,t,!0)){S=!0;break}if(S)break;if(u){if((D=ke(e,k))<0)break}else if((D=_e(e,k))<0)break;if(m!==e.src.charCodeAt(D-1))break}return (L=u?e.push("ordered_list_close","ol",-1):e.push("bullet_list_close","ul",-1)).markup=String.fromCharCode(m),f[1]=k,e.line=k,e.parentType=C,T&&function(e,r){var t,n,s=e.level+2;for(t=r+2,n=e.tokens.length-2;t<n;t++)e.tokens[t].level===s&&"paragraph_open"===e.tokens[t].type&&(e.tokens[t+2].hidden=!0,e.tokens[t].hidden=!0,t+=2);}(e,d),!0},["paragraph","reference","blockquote"]],["reference",function(e,r,t,n){var s,o,i,a,c,l,u,p,h,f,d,m,g,_,k,b,v=0,C=e.bMarks[r]+e.tShift[r],y=e.eMarks[r],A=r+1;if(e.sCount[r]-e.blkIndent>=4)return !1;if(91!==e.src.charCodeAt(C))return !1;for(;++C<y;)if(93===e.src.charCodeAt(C)&&92!==e.src.charCodeAt(C-1)){if(C+1===y)return !1;if(58!==e.src.charCodeAt(C+1))return !1;break}for(a=e.lineMax,k=e.md.block.ruler.getRules("reference"),f=e.parentType,e.parentType="reference";A<a&&!e.isEmpty(A);A++)if(!(e.sCount[A]-e.blkIndent>3||e.sCount[A]<0)){for(_=!1,l=0,u=k.length;l<u;l++)if(k[l](e,A,a,!0)){_=!0;break}if(_)break}for(g=e.getLines(r,A,e.blkIndent,!1).trim(),y=g.length,C=1;C<y;C++){if(91===(s=g.charCodeAt(C)))return !1;if(93===s){h=C;break}10===s?v++:92===s&&++C<y&&10===g.charCodeAt(C)&&v++;}if(h<0||58!==g.charCodeAt(h+1))return !1;for(C=h+2;C<y;C++)if(10===(s=g.charCodeAt(C)))v++;else if(!ve(s))break;if(!(d=e.md.helpers.parseLinkDestination(g,C,y)).ok)return !1;if(c=e.md.normalizeLink(d.str),!e.md.validateLink(c))return !1;for(C=d.pos,v+=d.lines,o=C,i=v,m=C;C<y;C++)if(10===(s=g.charCodeAt(C)))v++;else if(!ve(s))break;for(d=e.md.helpers.parseLinkTitle(g,C,y),C<y&&m!==C&&d.ok?(b=d.str,C=d.pos,v+=d.lines):(b="",C=o,v=i);C<y&&(s=g.charCodeAt(C),ve(s));)C++;if(C<y&&10!==g.charCodeAt(C)&&b)for(b="",C=o,v=i;C<y&&(s=g.charCodeAt(C),ve(s));)C++;return !(C<y&&10!==g.charCodeAt(C))&&(!!(p=be(g.slice(1,h)))&&(!!n||(void 0===e.env.references&&(e.env.references={}),void 0===e.env.references[p]&&(e.env.references[p]={title:b,href:c}),e.parentType=f,e.line=r+v+1,!0)))}],["heading",function(e,r,t,n){var s,o,i,a,c=e.bMarks[r]+e.tShift[r],l=e.eMarks[r];if(e.sCount[r]-e.blkIndent>=4)return !1;if(35!==(s=e.src.charCodeAt(c))||c>=l)return !1;for(o=1,s=e.src.charCodeAt(++c);35===s&&c<l&&o<=6;)o++,s=e.src.charCodeAt(++c);return !(o>6||c<l&&!Ce(s))&&(!!n||(l=e.skipSpacesBack(l,c),(i=e.skipCharsBack(l,35,c))>c&&Ce(e.src.charCodeAt(i-1))&&(l=i),e.line=r+1,(a=e.push("heading_open","h"+String(o),1)).markup="########".slice(0,o),a.map=[r,e.line],(a=e.push("inline","",0)).content=e.src.slice(c,l).trim(),a.map=[r,e.line],a.children=[],(a=e.push("heading_close","h"+String(o),-1)).markup="########".slice(0,o),!0))},["paragraph","reference","blockquote"]],["lheading",function(e,r,t){var n,s,o,i,a,c,l,u,p,h,f=r+1,d=e.md.block.ruler.getRules("paragraph");if(e.sCount[r]-e.blkIndent>=4)return !1;for(h=e.parentType,e.parentType="paragraph";f<t&&!e.isEmpty(f);f++)if(!(e.sCount[f]-e.blkIndent>3)){if(e.sCount[f]>=e.blkIndent&&(c=e.bMarks[f]+e.tShift[f],l=e.eMarks[f],c<l&&(45===(p=e.src.charCodeAt(c))||61===p)&&(c=e.skipChars(c,p),(c=e.skipSpaces(c))>=l))){u=61===p?1:2;break}if(!(e.sCount[f]<0)){for(s=!1,o=0,i=d.length;o<i;o++)if(d[o](e,f,t,!0)){s=!0;break}if(s)break}}return !!u&&(n=e.getLines(r,f,e.blkIndent,!1).trim(),e.line=f+1,(a=e.push("heading_open","h"+String(u),1)).markup=String.fromCharCode(p),a.map=[r,e.line],(a=e.push("inline","",0)).content=n,a.map=[r,e.line-1],a.children=[],(a=e.push("heading_close","h"+String(u),-1)).markup=String.fromCharCode(p),e.parentType=h,!0)}],["html_block",function(e,r,t,n){var s,o,i,a,c=e.bMarks[r]+e.tShift[r],l=e.eMarks[r];if(e.sCount[r]-e.blkIndent>=4)return !1;if(!e.md.options.html)return !1;if(60!==e.src.charCodeAt(c))return !1;for(a=e.src.slice(c,l),s=0;s<qe.length&&!qe[s][0].test(a);s++);if(s===qe.length)return !1;if(n)return qe[s][2];if(o=r+1,!qe[s][1].test(a))for(;o<t&&!(e.sCount[o]<e.blkIndent);o++)if(c=e.bMarks[o]+e.tShift[o],l=e.eMarks[o],a=e.src.slice(c,l),qe[s][1].test(a)){0!==a.length&&o++;break}return e.line=o,(i=e.push("html_block","",0)).map=[r,o],i.content=e.getLines(r,o,e.blkIndent,!0),!0},["paragraph","reference","blockquote"]],["paragraph",function(e,r){var t,n,s,o,i,a,c=r+1,l=e.md.block.ruler.getRules("paragraph"),u=e.lineMax;for(a=e.parentType,e.parentType="paragraph";c<u&&!e.isEmpty(c);c++)if(!(e.sCount[c]-e.blkIndent>3||e.sCount[c]<0)){for(n=!1,s=0,o=l.length;s<o;s++)if(l[s](e,c,u,!0)){n=!0;break}if(n)break}return t=e.getLines(r,c,e.blkIndent,!1).trim(),e.line=c,(i=e.push("paragraph_open","p",1)).map=[r,e.line],(i=e.push("inline","",0)).content=t,i.map=[r,e.line],i.children=[],i=e.push("paragraph_close","p",-1),e.parentType=a,!0}]];function Te(){this.ruler=new N;for(var e=0;e<ze.length;e++)this.ruler.push(ze[e][0],ze[e][1],{alt:(ze[e][2]||[]).slice()});}Te.prototype.tokenize=function(e,r,t){for(var n,s=this.ruler.getRules(""),o=s.length,i=r,a=!1,c=e.md.options.maxNesting;i<t&&(e.line=i=e.skipEmptyLines(i),!(i>=t))&&!(e.sCount[i]<e.blkIndent);){if(e.level>=c){e.line=t;break}for(n=0;n<o&&!s[n](e,i,t,!1);n++);e.tight=!a,e.isEmpty(e.line-1)&&(a=!0),(i=e.line)<t&&e.isEmpty(i)&&(a=!0,i++,e.line=i);}},Te.prototype.parse=function(e,r,t,n){var s;e&&(s=new this.State(e,r,t,n),this.tokenize(s,s.line,s.lineMax));},Te.prototype.State=Le;var Ie=Te;function Me(e){switch(e){case 10:case 33:case 35:case 36:case 37:case 38:case 42:case 43:case 45:case 58:case 60:case 61:case 62:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 125:case 126:return !0;default:return !1}}for(var Re=E.isSpace,Be=E.isSpace,Ne=[],Oe=0;Oe<256;Oe++)Ne.push(0);function Pe(e,r){var t,n,s,o,i,a=[],c=r.length;for(t=0;t<c;t++)126===(s=r[t]).marker&&-1!==s.end&&(o=r[s.end],(i=e.tokens[s.token]).type="s_open",i.tag="s",i.nesting=1,i.markup="~~",i.content="",(i=e.tokens[o.token]).type="s_close",i.tag="s",i.nesting=-1,i.markup="~~",i.content="","text"===e.tokens[o.token-1].type&&"~"===e.tokens[o.token-1].content&&a.push(o.token-1));for(;a.length;){for(t=a.pop(),n=t+1;n<e.tokens.length&&"s_close"===e.tokens[n].type;)n++;t!==--n&&(i=e.tokens[n],e.tokens[n]=e.tokens[t],e.tokens[t]=i);}}"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(e){Ne[e.charCodeAt(0)]=1;});var je={tokenize:function(e,r){var t,n,s,o,i=e.pos,a=e.src.charCodeAt(i);if(r)return !1;if(126!==a)return !1;if(n=e.scanDelims(e.pos,!0),s=n.length,o=String.fromCharCode(a),s<2)return !1;for(s%2&&(e.push("text","",0).content=o,s--),t=0;t<s;t+=2)e.push("text","",0).content=o+o,e.delimiters.push({marker:a,length:0,jump:t/2,token:e.tokens.length-1,end:-1,open:n.can_open,close:n.can_close});return e.pos+=n.length,!0},postProcess:function(e){var r,t=e.tokens_meta,n=e.tokens_meta.length;for(Pe(e,e.delimiters),r=0;r<n;r++)t[r]&&t[r].delimiters&&Pe(e,t[r].delimiters);}};function Ue(e,r){var t,n,s,o,i,a,c=r.length;for(t=c-1;t>=0;t--)95!==(n=r[t]).marker&&42!==n.marker||-1!==n.end&&(s=r[n.end],a=t>0&&r[t-1].end===n.end+1&&r[t-1].token===n.token-1&&r[n.end+1].token===s.token+1&&r[t-1].marker===n.marker,i=String.fromCharCode(n.marker),(o=e.tokens[n.token]).type=a?"strong_open":"em_open",o.tag=a?"strong":"em",o.nesting=1,o.markup=a?i+i:i,o.content="",(o=e.tokens[s.token]).type=a?"strong_close":"em_close",o.tag=a?"strong":"em",o.nesting=-1,o.markup=a?i+i:i,o.content="",a&&(e.tokens[r[t-1].token].content="",e.tokens[r[n.end+1].token].content="",t--));}var Ve={tokenize:function(e,r){var t,n,s=e.pos,o=e.src.charCodeAt(s);if(r)return !1;if(95!==o&&42!==o)return !1;for(n=e.scanDelims(e.pos,42===o),t=0;t<n.length;t++)e.push("text","",0).content=String.fromCharCode(o),e.delimiters.push({marker:o,length:n.length,jump:t,token:e.tokens.length-1,end:-1,open:n.can_open,close:n.can_close});return e.pos+=n.length,!0},postProcess:function(e){var r,t=e.tokens_meta,n=e.tokens_meta.length;for(Ue(e,e.delimiters),r=0;r<n;r++)t[r]&&t[r].delimiters&&Ue(e,t[r].delimiters);}},Ze=E.normalizeReference,$e=E.isSpace,Ge=E.normalizeReference,He=E.isSpace,Je=/^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/,We=/^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/,Ye=De.HTML_TAG_RE,Ke=E.has,Qe=E.isValidEntityCode,Xe=E.fromCodePoint,er=/^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i,rr=/^&([a-z][a-z0-9]{1,31});/i;function tr(e,r){var t,n,s,o,i,a,c,l,u={},p=r.length;for(t=0;t<p;t++)if((s=r[t]).length=s.length||0,s.close){for(u.hasOwnProperty(s.marker)||(u[s.marker]=[-1,-1,-1]),i=u[s.marker][s.length%3],(n=t-s.jump-1)<-1&&(n=-1),a=n;n>i;n-=o.jump+1)if((o=r[n]).marker===s.marker&&o.open&&o.end<0&&(c=!1,(o.close||s.open)&&(o.length+s.length)%3==0&&(o.length%3==0&&s.length%3==0||(c=!0)),!c)){l=n>0&&!r[n-1].open?r[n-1].jump+1:0,s.jump=t-n+l,s.open=!1,o.end=t,o.jump=l,o.close=!1,a=-1;break}-1!==a&&(u[s.marker][(s.length||0)%3]=a);}}var nr=E.isWhiteSpace,sr=E.isPunctChar,or=E.isMdAsciiPunct;function ir(e,r,t,n){this.src=e,this.env=t,this.md=r,this.tokens=n,this.tokens_meta=Array(n.length),this.pos=0,this.posMax=this.src.length,this.level=0,this.pending="",this.pendingLevel=0,this.cache={},this.delimiters=[],this._prev_delimiters=[],this.backticks={},this.backticksScanned=!1;}ir.prototype.pushPending=function(){var e=new oe("text","",0);return e.content=this.pending,e.level=this.pendingLevel,this.tokens.push(e),this.pending="",e},ir.prototype.push=function(e,r,t){this.pending&&this.pushPending();var n=new oe(e,r,t),s=null;return t<0&&(this.level--,this.delimiters=this._prev_delimiters.pop()),n.level=this.level,t>0&&(this.level++,this._prev_delimiters.push(this.delimiters),this.delimiters=[],s={delimiters:this.delimiters}),this.pendingLevel=this.level,this.tokens.push(n),this.tokens_meta.push(s),n},ir.prototype.scanDelims=function(e,r){var t,n,s,o,i,a,c,l,u,p=e,h=!0,f=!0,d=this.posMax,m=this.src.charCodeAt(e);for(t=e>0?this.src.charCodeAt(e-1):32;p<d&&this.src.charCodeAt(p)===m;)p++;return s=p-e,n=p<d?this.src.charCodeAt(p):32,c=or(t)||sr(String.fromCharCode(t)),u=or(n)||sr(String.fromCharCode(n)),a=nr(t),(l=nr(n))?h=!1:u&&(a||c||(h=!1)),a?f=!1:c&&(l||u||(f=!1)),r?(o=h,i=f):(o=h&&(!f||c),i=f&&(!h||u)),{can_open:o,can_close:i,length:s}},ir.prototype.Token=oe;var ar=ir,cr=[["text",function(e,r){for(var t=e.pos;t<e.posMax&&!Me(e.src.charCodeAt(t));)t++;return t!==e.pos&&(r||(e.pending+=e.src.slice(e.pos,t)),e.pos=t,!0)}],["newline",function(e,r){var t,n,s=e.pos;if(10!==e.src.charCodeAt(s))return !1;for(t=e.pending.length-1,n=e.posMax,r||(t>=0&&32===e.pending.charCodeAt(t)?t>=1&&32===e.pending.charCodeAt(t-1)?(e.pending=e.pending.replace(/ +$/,""),e.push("hardbreak","br",0)):(e.pending=e.pending.slice(0,-1),e.push("softbreak","br",0)):e.push("softbreak","br",0)),s++;s<n&&Re(e.src.charCodeAt(s));)s++;return e.pos=s,!0}],["escape",function(e,r){var t,n=e.pos,s=e.posMax;if(92!==e.src.charCodeAt(n))return !1;if(++n<s){if((t=e.src.charCodeAt(n))<256&&0!==Ne[t])return r||(e.pending+=e.src[n]),e.pos+=2,!0;if(10===t){for(r||e.push("hardbreak","br",0),n++;n<s&&(t=e.src.charCodeAt(n),Be(t));)n++;return e.pos=n,!0}}return r||(e.pending+="\\"),e.pos++,!0}],["backticks",function(e,r){var t,n,s,o,i,a,c,l,u=e.pos;if(96!==e.src.charCodeAt(u))return !1;for(t=u,u++,n=e.posMax;u<n&&96===e.src.charCodeAt(u);)u++;if(s=e.src.slice(t,u),c=s.length,e.backticksScanned&&(e.backticks[c]||0)<=t)return r||(e.pending+=s),e.pos+=c,!0;for(i=a=u;-1!==(i=e.src.indexOf("`",a));){for(a=i+1;a<n&&96===e.src.charCodeAt(a);)a++;if((l=a-i)===c)return r||((o=e.push("code_inline","code",0)).markup=s,o.content=e.src.slice(u,i).replace(/\n/g," ").replace(/^ (.+) $/,"$1")),e.pos=a,!0;e.backticks[l]=i;}return e.backticksScanned=!0,r||(e.pending+=s),e.pos+=c,!0}],["strikethrough",je.tokenize],["emphasis",Ve.tokenize],["link",function(e,r){var t,n,s,o,i,a,c,l,u="",p="",h=e.pos,f=e.posMax,d=e.pos,m=!0;if(91!==e.src.charCodeAt(e.pos))return !1;if(i=e.pos+1,(o=e.md.helpers.parseLinkLabel(e,e.pos,!0))<0)return !1;if((a=o+1)<f&&40===e.src.charCodeAt(a)){for(m=!1,a++;a<f&&(n=e.src.charCodeAt(a),$e(n)||10===n);a++);if(a>=f)return !1;if(d=a,(c=e.md.helpers.parseLinkDestination(e.src,a,e.posMax)).ok){for(u=e.md.normalizeLink(c.str),e.md.validateLink(u)?a=c.pos:u="",d=a;a<f&&(n=e.src.charCodeAt(a),$e(n)||10===n);a++);if(c=e.md.helpers.parseLinkTitle(e.src,a,e.posMax),a<f&&d!==a&&c.ok)for(p=c.str,a=c.pos;a<f&&(n=e.src.charCodeAt(a),$e(n)||10===n);a++);}(a>=f||41!==e.src.charCodeAt(a))&&(m=!0),a++;}if(m){if(void 0===e.env.references)return !1;if(a<f&&91===e.src.charCodeAt(a)?(d=a+1,(a=e.md.helpers.parseLinkLabel(e,a))>=0?s=e.src.slice(d,a++):a=o+1):a=o+1,s||(s=e.src.slice(i,o)),!(l=e.env.references[Ze(s)]))return e.pos=h,!1;u=l.href,p=l.title;}return r||(e.pos=i,e.posMax=o,e.push("link_open","a",1).attrs=t=[["href",u]],p&&t.push(["title",p]),e.md.inline.tokenize(e),e.push("link_close","a",-1)),e.pos=a,e.posMax=f,!0}],["image",function(e,r){var t,n,s,o,i,a,c,l,u,p,h,f,d,m="",g=e.pos,_=e.posMax;if(33!==e.src.charCodeAt(e.pos))return !1;if(91!==e.src.charCodeAt(e.pos+1))return !1;if(a=e.pos+2,(i=e.md.helpers.parseLinkLabel(e,e.pos+1,!1))<0)return !1;if((c=i+1)<_&&40===e.src.charCodeAt(c)){for(c++;c<_&&(n=e.src.charCodeAt(c),He(n)||10===n);c++);if(c>=_)return !1;for(d=c,(u=e.md.helpers.parseLinkDestination(e.src,c,e.posMax)).ok&&(m=e.md.normalizeLink(u.str),e.md.validateLink(m)?c=u.pos:m=""),d=c;c<_&&(n=e.src.charCodeAt(c),He(n)||10===n);c++);if(u=e.md.helpers.parseLinkTitle(e.src,c,e.posMax),c<_&&d!==c&&u.ok)for(p=u.str,c=u.pos;c<_&&(n=e.src.charCodeAt(c),He(n)||10===n);c++);else p="";if(c>=_||41!==e.src.charCodeAt(c))return e.pos=g,!1;c++;}else {if(void 0===e.env.references)return !1;if(c<_&&91===e.src.charCodeAt(c)?(d=c+1,(c=e.md.helpers.parseLinkLabel(e,c))>=0?o=e.src.slice(d,c++):c=i+1):c=i+1,o||(o=e.src.slice(a,i)),!(l=e.env.references[Ge(o)]))return e.pos=g,!1;m=l.href,p=l.title;}return r||(s=e.src.slice(a,i),e.md.inline.parse(s,e.md,e.env,f=[]),(h=e.push("image","img",0)).attrs=t=[["src",m],["alt",""]],h.children=f,h.content=s,p&&t.push(["title",p])),e.pos=c,e.posMax=_,!0}],["autolink",function(e,r){var t,n,s,o,i,a,c=e.pos;if(60!==e.src.charCodeAt(c))return !1;for(i=e.pos,a=e.posMax;;){if(++c>=a)return !1;if(60===(o=e.src.charCodeAt(c)))return !1;if(62===o)break}return t=e.src.slice(i+1,c),We.test(t)?(n=e.md.normalizeLink(t),!!e.md.validateLink(n)&&(r||((s=e.push("link_open","a",1)).attrs=[["href",n]],s.markup="autolink",s.info="auto",(s=e.push("text","",0)).content=e.md.normalizeLinkText(t),(s=e.push("link_close","a",-1)).markup="autolink",s.info="auto"),e.pos+=t.length+2,!0)):!!Je.test(t)&&(n=e.md.normalizeLink("mailto:"+t),!!e.md.validateLink(n)&&(r||((s=e.push("link_open","a",1)).attrs=[["href",n]],s.markup="autolink",s.info="auto",(s=e.push("text","",0)).content=e.md.normalizeLinkText(t),(s=e.push("link_close","a",-1)).markup="autolink",s.info="auto"),e.pos+=t.length+2,!0))}],["html_inline",function(e,r){var t,n,s,o=e.pos;return !!e.md.options.html&&(s=e.posMax,!(60!==e.src.charCodeAt(o)||o+2>=s)&&(!(33!==(t=e.src.charCodeAt(o+1))&&63!==t&&47!==t&&!function(e){var r=32|e;return r>=97&&r<=122}(t))&&(!!(n=e.src.slice(o).match(Ye))&&(r||(e.push("html_inline","",0).content=e.src.slice(o,o+n[0].length)),e.pos+=n[0].length,!0))))}],["entity",function(r,t){var n,s,o=r.pos,i=r.posMax;if(38!==r.src.charCodeAt(o))return !1;if(o+1<i)if(35===r.src.charCodeAt(o+1)){if(s=r.src.slice(o).match(er))return t||(n="x"===s[1][0].toLowerCase()?parseInt(s[1].slice(1),16):parseInt(s[1],10),r.pending+=Qe(n)?Xe(n):Xe(65533)),r.pos+=s[0].length,!0}else if((s=r.src.slice(o).match(rr))&&Ke(e,s[1]))return t||(r.pending+=e[s[1]]),r.pos+=s[0].length,!0;return t||(r.pending+="&"),r.pos++,!0}]],lr=[["balance_pairs",function(e){var r,t=e.tokens_meta,n=e.tokens_meta.length;for(tr(0,e.delimiters),r=0;r<n;r++)t[r]&&t[r].delimiters&&tr(0,t[r].delimiters);}],["strikethrough",je.postProcess],["emphasis",Ve.postProcess],["text_collapse",function(e){var r,t,n=0,s=e.tokens,o=e.tokens.length;for(r=t=0;r<o;r++)s[r].nesting<0&&n--,s[r].level=n,s[r].nesting>0&&n++,"text"===s[r].type&&r+1<o&&"text"===s[r+1].type?s[r+1].content=s[r].content+s[r+1].content:(r!==t&&(s[t]=s[r]),t++);r!==t&&(s.length=t);}]];function ur(){var e;for(this.ruler=new N,e=0;e<cr.length;e++)this.ruler.push(cr[e][0],cr[e][1]);for(this.ruler2=new N,e=0;e<lr.length;e++)this.ruler2.push(lr[e][0],lr[e][1]);}ur.prototype.skipToken=function(e){var r,t,n=e.pos,s=this.ruler.getRules(""),o=s.length,i=e.md.options.maxNesting,a=e.cache;if(void 0===a[n]){if(e.level<i)for(t=0;t<o&&(e.level++,r=s[t](e,!0),e.level--,!r);t++);else e.pos=e.posMax;r||e.pos++,a[n]=e.pos;}else e.pos=a[n];},ur.prototype.tokenize=function(e){for(var r,t,n=this.ruler.getRules(""),s=n.length,o=e.posMax,i=e.md.options.maxNesting;e.pos<o;){if(e.level<i)for(t=0;t<s&&!(r=n[t](e,!1));t++);if(r){if(e.pos>=o)break}else e.pending+=e.src[e.pos++];}e.pending&&e.pushPending();},ur.prototype.parse=function(e,r,t,n){var s,o,i,a=new this.State(e,r,t,n);for(this.tokenize(a),o=this.ruler2.getRules(""),i=o.length,s=0;s<i;s++)o[s](a);},ur.prototype.State=ar;var pr=ur,hr=function(e){var t={};return t.src_Any=A.source,t.src_Cc=x.source,t.src_Z=w.source,t.src_P=r.source,t.src_ZPCc=[t.src_Z,t.src_P,t.src_Cc].join("|"),t.src_ZCc=[t.src_Z,t.src_Cc].join("|"),t.src_pseudo_letter="(?:(?![><｜]|"+t.src_ZPCc+")"+t.src_Any+")",t.src_ip4="(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)",t.src_auth="(?:(?:(?!"+t.src_ZCc+"|[@/\\[\\]()]).)+@)?",t.src_port="(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?",t.src_host_terminator="(?=$|[><｜]|"+t.src_ZPCc+")(?!-|_|:\\d|\\.-|\\.(?!$|"+t.src_ZPCc+"))",t.src_path="(?:[/?#](?:(?!"+t.src_ZCc+"|[><｜]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!"+t.src_ZCc+"|\\]).)*\\]|\\((?:(?!"+t.src_ZCc+"|[)]).)*\\)|\\{(?:(?!"+t.src_ZCc+'|[}]).)*\\}|\\"(?:(?!'+t.src_ZCc+'|["]).)+\\"|\\\'(?:(?!'+t.src_ZCc+"|[']).)+\\'|\\'(?="+t.src_pseudo_letter+"|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!"+t.src_ZCc+"|[.]).|"+(e&&e["---"]?"\\-(?!--(?:[^-]|$))(?:-*)|":"\\-+|")+"\\,(?!"+t.src_ZCc+").|\\!+(?!"+t.src_ZCc+"|[!]).|\\?(?!"+t.src_ZCc+"|[?]).)+|\\/)?",t.src_email_name='[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*',t.src_xn="xn--[a-z0-9\\-]{1,59}",t.src_domain_root="(?:"+t.src_xn+"|"+t.src_pseudo_letter+"{1,63})",t.src_domain="(?:"+t.src_xn+"|(?:"+t.src_pseudo_letter+")|(?:"+t.src_pseudo_letter+"(?:-|"+t.src_pseudo_letter+"){0,61}"+t.src_pseudo_letter+"))",t.src_host="(?:(?:(?:(?:"+t.src_domain+")\\.)*"+t.src_domain+"))",t.tpl_host_fuzzy="(?:"+t.src_ip4+"|(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%)))",t.tpl_host_no_ip_fuzzy="(?:(?:(?:"+t.src_domain+")\\.)+(?:%TLDS%))",t.src_host_strict=t.src_host+t.src_host_terminator,t.tpl_host_fuzzy_strict=t.tpl_host_fuzzy+t.src_host_terminator,t.src_host_port_strict=t.src_host+t.src_port+t.src_host_terminator,t.tpl_host_port_fuzzy_strict=t.tpl_host_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_port_no_ip_fuzzy_strict=t.tpl_host_no_ip_fuzzy+t.src_port+t.src_host_terminator,t.tpl_host_fuzzy_test="localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:"+t.src_ZPCc+"|>|$))",t.tpl_email_fuzzy='(^|[><｜]|"|\\(|'+t.src_ZCc+")("+t.src_email_name+"@"+t.tpl_host_fuzzy_strict+")",t.tpl_link_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_fuzzy_strict+t.src_path+")",t.tpl_link_no_ip_fuzzy="(^|(?![.:/\\-_@])(?:[$+<=>^`|｜]|"+t.src_ZPCc+"))((?![$+<=>^`|｜])"+t.tpl_host_port_no_ip_fuzzy_strict+t.src_path+")",t};function fr(e){var r=Array.prototype.slice.call(arguments,1);return r.forEach(function(r){r&&Object.keys(r).forEach(function(t){e[t]=r[t];});}),e}function dr(e){return Object.prototype.toString.call(e)}function mr(e){return "[object Function]"===dr(e)}function gr(e){return e.replace(/[.?*+^$[\]\\(){}|-]/g,"\\$&")}var _r={fuzzyLink:!0,fuzzyEmail:!0,fuzzyIP:!1},kr={"http:":{validate:function(e,r,t){var n=e.slice(r);return t.re.http||(t.re.http=new RegExp("^\\/\\/"+t.re.src_auth+t.re.src_host_port_strict+t.re.src_path,"i")),t.re.http.test(n)?n.match(t.re.http)[0].length:0}},"https:":"http:","ftp:":"http:","//":{validate:function(e,r,t){var n=e.slice(r);return t.re.no_http||(t.re.no_http=new RegExp("^"+t.re.src_auth+"(?:localhost|(?:(?:"+t.re.src_domain+")\\.)+"+t.re.src_domain_root+")"+t.re.src_port+t.re.src_host_terminator+t.re.src_path,"i")),t.re.no_http.test(n)?r>=3&&":"===e[r-3]?0:r>=3&&"/"===e[r-3]?0:n.match(t.re.no_http)[0].length:0}},"mailto:":{validate:function(e,r,t){var n=e.slice(r);return t.re.mailto||(t.re.mailto=new RegExp("^"+t.re.src_email_name+"@"+t.re.src_host_strict,"i")),t.re.mailto.test(n)?n.match(t.re.mailto)[0].length:0}}},br="a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",vr="biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф".split("|");function Cr(e){var r=e.re=hr(e.__opts__),t=e.__tlds__.slice();function n(e){return e.replace("%TLDS%",r.src_tlds)}e.onCompile(),e.__tlds_replaced__||t.push(br),t.push(r.src_xn),r.src_tlds=t.join("|"),r.email_fuzzy=RegExp(n(r.tpl_email_fuzzy),"i"),r.link_fuzzy=RegExp(n(r.tpl_link_fuzzy),"i"),r.link_no_ip_fuzzy=RegExp(n(r.tpl_link_no_ip_fuzzy),"i"),r.host_fuzzy_test=RegExp(n(r.tpl_host_fuzzy_test),"i");var s=[];function o(e,r){throw new Error('(LinkifyIt) Invalid schema "'+e+'": '+r)}e.__compiled__={},Object.keys(e.__schemas__).forEach(function(r){var t=e.__schemas__[r];if(null!==t){var n,i={validate:null,link:null};if(e.__compiled__[r]=i,"[object Object]"===dr(t))return function(e){return "[object RegExp]"===dr(e)}(t.validate)?i.validate=(n=t.validate,function(e,r){var t=e.slice(r);return n.test(t)?t.match(n)[0].length:0}):mr(t.validate)?i.validate=t.validate:o(r,t),void(mr(t.normalize)?i.normalize=t.normalize:t.normalize?o(r,t):i.normalize=function(e,r){r.normalize(e);});!function(e){return "[object String]"===dr(e)}(t)?o(r,t):s.push(r);}}),s.forEach(function(r){e.__compiled__[e.__schemas__[r]]&&(e.__compiled__[r].validate=e.__compiled__[e.__schemas__[r]].validate,e.__compiled__[r].normalize=e.__compiled__[e.__schemas__[r]].normalize);}),e.__compiled__[""]={validate:null,normalize:function(e,r){r.normalize(e);}};var i=Object.keys(e.__compiled__).filter(function(r){return r.length>0&&e.__compiled__[r]}).map(gr).join("|");e.re.schema_test=RegExp("(^|(?!_)(?:[><｜]|"+r.src_ZPCc+"))("+i+")","i"),e.re.schema_search=RegExp("(^|(?!_)(?:[><｜]|"+r.src_ZPCc+"))("+i+")","ig"),e.re.pretest=RegExp("("+e.re.schema_test.source+")|("+e.re.host_fuzzy_test.source+")|@","i"),function(e){e.__index__=-1,e.__text_cache__="";}(e);}function yr(e,r){var t=e.__index__,n=e.__last_index__,s=e.__text_cache__.slice(t,n);this.schema=e.__schema__.toLowerCase(),this.index=t+r,this.lastIndex=n+r,this.raw=s,this.text=s,this.url=s;}function Ar(e,r){var t=new yr(e,r);return e.__compiled__[t.schema].normalize(t,e),t}function xr(e,r){if(!(this instanceof xr))return new xr(e,r);var t;r||(t=e,Object.keys(t||{}).reduce(function(e,r){return e||_r.hasOwnProperty(r)},!1)&&(r=e,e={})),this.__opts__=fr({},_r,r),this.__index__=-1,this.__last_index__=-1,this.__schema__="",this.__text_cache__="",this.__schemas__=fr({},kr,e),this.__compiled__={},this.__tlds__=vr,this.__tlds_replaced__=!1,this.re={},Cr(this);}xr.prototype.add=function(e,r){return this.__schemas__[e]=r,Cr(this),this},xr.prototype.set=function(e){return this.__opts__=fr(this.__opts__,e),this},xr.prototype.test=function(e){if(this.__text_cache__=e,this.__index__=-1,!e.length)return !1;var r,t,n,s,o,i,a,c;if(this.re.schema_test.test(e))for((a=this.re.schema_search).lastIndex=0;null!==(r=a.exec(e));)if(s=this.testSchemaAt(e,r[2],a.lastIndex)){this.__schema__=r[2],this.__index__=r.index+r[1].length,this.__last_index__=r.index+r[0].length+s;break}return this.__opts__.fuzzyLink&&this.__compiled__["http:"]&&(c=e.search(this.re.host_fuzzy_test))>=0&&(this.__index__<0||c<this.__index__)&&null!==(t=e.match(this.__opts__.fuzzyIP?this.re.link_fuzzy:this.re.link_no_ip_fuzzy))&&(o=t.index+t[1].length,(this.__index__<0||o<this.__index__)&&(this.__schema__="",this.__index__=o,this.__last_index__=t.index+t[0].length)),this.__opts__.fuzzyEmail&&this.__compiled__["mailto:"]&&e.indexOf("@")>=0&&null!==(n=e.match(this.re.email_fuzzy))&&(o=n.index+n[1].length,i=n.index+n[0].length,(this.__index__<0||o<this.__index__||o===this.__index__&&i>this.__last_index__)&&(this.__schema__="mailto:",this.__index__=o,this.__last_index__=i)),this.__index__>=0},xr.prototype.pretest=function(e){return this.re.pretest.test(e)},xr.prototype.testSchemaAt=function(e,r,t){return this.__compiled__[r.toLowerCase()]?this.__compiled__[r.toLowerCase()].validate(e,t,this):0},xr.prototype.match=function(e){var r=0,t=[];this.__index__>=0&&this.__text_cache__===e&&(t.push(Ar(this,r)),r=this.__last_index__);for(var n=r?e.slice(r):e;this.test(n);)t.push(Ar(this,r)),n=n.slice(this.__last_index__),r+=this.__last_index__;return t.length?t:null},xr.prototype.tlds=function(e,r){return e=Array.isArray(e)?e:[e],r?(this.__tlds__=this.__tlds__.concat(e).sort().filter(function(e,r,t){return e!==t[r-1]}).reverse(),Cr(this),this):(this.__tlds__=e.slice(),this.__tlds_replaced__=!0,Cr(this),this)},xr.prototype.normalize=function(e){e.schema||(e.url="http://"+e.url),"mailto:"!==e.schema||/^mailto:/i.test(e.url)||(e.url="mailto:"+e.url);},xr.prototype.onCompile=function(){};var wr=xr,Dr=2147483647,Er=36,qr=1,Sr=26,Fr=38,Lr=700,zr=72,Tr=128,Ir="-",Mr=/^xn--/,Rr=/[^\x20-\x7E]/,Br=/[\x2E\u3002\uFF0E\uFF61]/g,Nr={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},Or=Er-qr,Pr=Math.floor,jr=String.fromCharCode;function Ur(e){throw new RangeError(Nr[e])}function Vr(e,r){for(var t=e.length,n=[];t--;)n[t]=r(e[t]);return n}function Zr(e,r){var t=e.split("@"),n="";t.length>1&&(n=t[0]+"@",e=t[1]);var s=(e=e.replace(Br,".")).split("."),o=Vr(s,r).join(".");return n+o}function $r(e){for(var r,t,n=[],s=0,o=e.length;s<o;)(r=e.charCodeAt(s++))>=55296&&r<=56319&&s<o?56320==(64512&(t=e.charCodeAt(s++)))?n.push(((1023&r)<<10)+(1023&t)+65536):(n.push(r),s--):n.push(r);return n}function Gr(e){return Vr(e,function(e){var r="";return e>65535&&(r+=jr((e-=65536)>>>10&1023|55296),e=56320|1023&e),r+=jr(e)}).join("")}function Hr(e,r){return e+22+75*(e<26)-((0!=r)<<5)}function Jr(e,r,t){var n=0;for(e=t?Pr(e/Lr):e>>1,e+=Pr(e/r);e>Or*Sr>>1;n+=Er)e=Pr(e/Or);return Pr(n+(Or+1)*e/(e+Fr))}function Wr(e){var r,t,n,s,o,i,a,c,l,u,p,h=[],f=e.length,d=0,m=Tr,g=zr;for((t=e.lastIndexOf(Ir))<0&&(t=0),n=0;n<t;++n)e.charCodeAt(n)>=128&&Ur("not-basic"),h.push(e.charCodeAt(n));for(s=t>0?t+1:0;s<f;){for(o=d,i=1,a=Er;s>=f&&Ur("invalid-input"),p=e.charCodeAt(s++),((c=p-48<10?p-22:p-65<26?p-65:p-97<26?p-97:Er)>=Er||c>Pr((Dr-d)/i))&&Ur("overflow"),d+=c*i,!(c<(l=a<=g?qr:a>=g+Sr?Sr:a-g));a+=Er)i>Pr(Dr/(u=Er-l))&&Ur("overflow"),i*=u;r=h.length+1,g=Jr(d-o,r,0==o),Pr(d/r)>Dr-m&&Ur("overflow"),m+=Pr(d/r),d%=r,h.splice(d++,0,m);}return Gr(h)}function Yr(e){var r,t,n,s,o,i,a,c,l,u,p,h,f,d,m,g=[];for(e=$r(e),h=e.length,r=Tr,t=0,o=zr,i=0;i<h;++i)(p=e[i])<128&&g.push(jr(p));for(n=s=g.length,s&&g.push(Ir);n<h;){for(a=Dr,i=0;i<h;++i)(p=e[i])>=r&&p<a&&(a=p);for(a-r>Pr((Dr-t)/(f=n+1))&&Ur("overflow"),t+=(a-r)*f,r=a,i=0;i<h;++i)if((p=e[i])<r&&++t>Dr&&Ur("overflow"),p==r){for(c=t,l=Er;!(c<(u=l<=o?qr:l>=o+Sr?Sr:l-o));l+=Er)m=c-u,d=Er-u,g.push(jr(Hr(u+m%d,0))),c=Pr(m/d);g.push(jr(Hr(c,0))),o=Jr(t,f,n==s),t=0,++n;}++t,++r;}return g.join("")}function Kr(e){return Zr(e,function(e){return Mr.test(e)?Wr(e.slice(4).toLowerCase()):e})}function Qr(e){return Zr(e,function(e){return Rr.test(e)?"xn--"+Yr(e):e})}var Xr={decode:$r,encode:Gr},et={version:"1.4.1",ucs2:Xr,toASCII:Qr,toUnicode:Kr,encode:Yr,decode:Wr},rt=Object.freeze({__proto__:null,decode:Wr,encode:Yr,toUnicode:Kr,toASCII:Qr,version:"1.4.1",ucs2:Xr,default:et}),tt=function(e){if(e.__esModule)return e;var r=Object.defineProperty({},"__esModule",{value:!0});return Object.keys(e).forEach(function(t){var n=Object.getOwnPropertyDescriptor(e,t);Object.defineProperty(r,t,n.get?n:{enumerable:!0,get:function(){return e[t]}});}),r}(rt),nt={default:{options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"“”‘’",highlight:null,maxNesting:100},components:{core:{},block:{},inline:{}}},zero:{options:{html:!1,xhtmlOut:!1,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"“”‘’",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline"]},block:{rules:["paragraph"]},inline:{rules:["text"],rules2:["balance_pairs","text_collapse"]}}},commonmark:{options:{html:!0,xhtmlOut:!0,breaks:!1,langPrefix:"language-",linkify:!1,typographer:!1,quotes:"“”‘’",highlight:null,maxNesting:20},components:{core:{rules:["normalize","block","inline"]},block:{rules:["blockquote","code","fence","heading","hr","html_block","lheading","list","reference","paragraph"]},inline:{rules:["autolink","backticks","emphasis","entity","escape","html_inline","image","link","newline","text"],rules2:["balance_pairs","emphasis","text_collapse"]}}}},st=/^(vbscript|javascript|file|data):/,ot=/^data:image\/(gif|png|jpeg|webp);/;function it(e){var r=e.trim().toLowerCase();return !st.test(r)||!!ot.test(r)}var at=["http:","https:","mailto:"];function ct(e){var r=y.parse(e,!0);if(r.hostname&&(!r.protocol||at.indexOf(r.protocol)>=0))try{r.hostname=tt.toASCII(r.hostname);}catch(e){}return y.encode(y.format(r))}function lt(e){var r=y.parse(e,!0);if(r.hostname&&(!r.protocol||at.indexOf(r.protocol)>=0))try{r.hostname=tt.toUnicode(r.hostname);}catch(e){}return y.decode(y.format(r),y.decode.defaultChars+"%")}function ut(e,r){if(!(this instanceof ut))return new ut(e,r);r||E.isString(e)||(r=e||{},e="default"),this.inline=new pr,this.block=new Ie,this.core=new ue,this.renderer=new R,this.linkify=new wr,this.validateLink=it,this.normalizeLink=ct,this.normalizeLinkText=lt,this.utils=E,this.helpers=E.assign({},F),this.options={},this.configure(e),r&&this.set(r);}return ut.prototype.set=function(e){return E.assign(this.options,e),this},ut.prototype.configure=function(e){var r,t=this;if(E.isString(e)&&!(e=nt[r=e]))throw new Error('Wrong `markdown-it` preset "'+r+'", check name');if(!e)throw new Error("Wrong `markdown-it` preset, can't be empty");return e.options&&t.set(e.options),e.components&&Object.keys(e.components).forEach(function(r){e.components[r].rules&&t[r].ruler.enableOnly(e.components[r].rules),e.components[r].rules2&&t[r].ruler2.enableOnly(e.components[r].rules2);}),this},ut.prototype.enable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.enable(e,!0));},this),t=t.concat(this.inline.ruler2.enable(e,!0));var n=e.filter(function(e){return t.indexOf(e)<0});if(n.length&&!r)throw new Error("MarkdownIt. Failed to enable unknown rule(s): "+n);return this},ut.prototype.disable=function(e,r){var t=[];Array.isArray(e)||(e=[e]),["core","block","inline"].forEach(function(r){t=t.concat(this[r].ruler.disable(e,!0));},this),t=t.concat(this.inline.ruler2.disable(e,!0));var n=e.filter(function(e){return t.indexOf(e)<0});if(n.length&&!r)throw new Error("MarkdownIt. Failed to disable unknown rule(s): "+n);return this},ut.prototype.use=function(e){var r=[this].concat(Array.prototype.slice.call(arguments,1));return e.apply(e,r),this},ut.prototype.parse=function(e,r){if("string"!=typeof e)throw new Error("Input data should be a String");var t=new this.core.State(e,this,r);return this.core.process(t),t.tokens},ut.prototype.render=function(e,r){return r=r||{},this.renderer.render(this.parse(e,r),this.options,r)},ut.prototype.parseInline=function(e,r){var t=new this.core.State(e,this,r);return t.inlineMode=!0,this.core.process(t),t.tokens},ut.prototype.renderInline=function(e,r){return r=r||{},this.renderer.render(this.parseInline(e,r),this.options,r)},ut}();}(e={exports:{}},e.exports),e.exports),n=(r=t)&&r.__esModule&&Object.prototype.hasOwnProperty.call(r,"default")?r.default:r;function s(e,r){var t,n,s,o,i=e.pos,a=e.src.charCodeAt(i);if(r)return !1;if(43!==a)return !1;if(s=(n=e.scanDelims(e.pos,!0)).length,o=String.fromCharCode(a),s<2)return !1;for(s%2&&(e.push("text","",0).content=o,s--),t=0;t<s;t+=2)e.push("text","",0).content=o+o,e.delimiters.push({marker:a,jump:t,token:e.tokens.length-1,level:e.level,end:-1,open:n.can_open,close:n.can_close});return e.pos+=n.length,!0}function o(e){var r,t,n,s,o,i=[],a=e.delimiters,c=e.delimiters.length;for(r=0;r<c;r++)43===(n=a[r]).marker&&-1!==n.end&&(s=a[n.end],(o=e.tokens[n.token]).type="u_open",o.tag="u",o.nesting=1,o.markup="++",o.content="",(o=e.tokens[s.token]).type="u_close",o.tag="u",o.nesting=-1,o.markup="++",o.content="","text"===e.tokens[s.token-1].type&&"+"===e.tokens[s.token-1].content&&i.push(s.token-1));for(;i.length;){for(t=(r=i.pop())+1;t<e.tokens.length&&"u_close"===e.tokens[t].type;)t++;r!==--t&&(o=e.tokens[t],e.tokens[t]=e.tokens[r],e.tokens[r]=o);}}var i=function(e){e.inline.ruler.after("emphasis","underline",s),e.inline.ruler2.after("emphasis","underline",o);},a=/\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;function c(e,r){var t,n,s=e.posMax,o=e.pos;if(126!==e.src.charCodeAt(o))return !1;if(r)return !1;if(o+2>=s)return !1;for(e.pos=o+1;e.pos<s;){if(126===e.src.charCodeAt(e.pos)){t=!0;break}e.md.inline.skipToken(e);}return t&&o+1!==e.pos?(n=e.src.slice(o+1,e.pos)).match(/(^|[^\\])(\\\\)*\s/)?(e.pos=o,!1):(e.posMax=e.pos,e.pos=o+1,e.push("sub_open","sub",1).markup="~",e.push("text","",0).content=n.replace(a,"$1"),e.push("sub_close","sub",-1).markup="~",e.pos=e.posMax+1,e.posMax=s,!0):(e.pos=o,!1)}var l=function(e){e.inline.ruler.after("emphasis","sub",c);},u=/\\([ \\!"#$%&'()*+,.\/:;<=>?@[\]^_`{|}~-])/g;function p(e,r){var t,n,s=e.posMax,o=e.pos;if(94!==e.src.charCodeAt(o))return !1;if(r)return !1;if(o+2>=s)return !1;for(e.pos=o+1;e.pos<s;){if(94===e.src.charCodeAt(e.pos)){t=!0;break}e.md.inline.skipToken(e);}return t&&o+1!==e.pos?(n=e.src.slice(o+1,e.pos)).match(/(^|[^\\])(\\\\)*\s/)?(e.pos=o,!1):(e.posMax=e.pos,e.pos=o+1,e.push("sup_open","sup",1).markup="^",e.push("text","",0).content=n.replace(u,"$1"),e.push("sup_close","sup",-1).markup="^",e.pos=e.posMax+1,e.posMax=s,!0):(e.pos=o,!1)}var h=function(e){e.inline.ruler.after("emphasis","sup",p);},f=function(){function e(){this._md=new n,this.addPlugin(i),this.addPlugin(l),this.addPlugin(h);}var r=e.prototype;return r.addPlugin=function(e){for(var r=arguments.length,t=new Array(r>1?r-1:0),n=1;n<r;n++)t[n-1]=arguments[n];t.unshift(e),this._md.use.apply(this._md,t);},r.disablePlugin=function(e){this._md.disable(e,!0);},r.toHTML=function(e){return this._md.render(e)},e}(),d=new f;return d.class=f,d});
	});

	var RtfConverter = unwrapExports(rtfConverter_min);

	/**
	 * This class leverages the {@link RtfConverter} library to perform Rich Text to
	 * HTML conversions.
	 */

	var RichTextFormatterImpl = /*#__PURE__*/function () {
	  function RichTextFormatterImpl() {}

	  var _proto = RichTextFormatterImpl.prototype;

	  /**
	   * Generates an HTML representation of the provided Rich Text field value. Note that
	   * the HTML will contain a wrapper div. This is to support click analytics for Rich Text
	   * links.
	   *
	   * @param {string} fieldValue A Rich Text field value.
	   * @param {string} fieldName The name of the field, to be included in the payload of a click
	   *                           analytics event. This parameter is optional.
	   * @param {Object|string} targetConfig Configuration object specifying the 'target' behavior for
	   *                          the various types of links. If a string is provided, it is assumed that
	   *                          is the 'target' behavior across all types of links. This parameter is optional.
	   * @returns {string} The HTML representation of the field value, serialized as a string.
	   */
	  _proto.format = function format(fieldValue, fieldName, targetConfig) {
	    var _this = this;

	    if (typeof fieldValue !== 'string') {
	      throw new AnswersCoreError("Rich text \"" + fieldValue + "\" needs to be a string. Currently is a " + typeof fieldValue);
	    }

	    var pluginName = this._generatePluginName();

	    RtfConverter.addPlugin(markdownItForInline, pluginName, 'link_open', function (tokens, idx) {
	      return _this._urlTransformer(tokens, idx, targetConfig);
	    });
	    fieldName = fieldName || '';
	    var html = "<div class=\"js-yxt-rtfValue\" data-field-name=\"" + fieldName + "\">\n" + ("" + RtfConverter.toHTML(fieldValue)) + '</div>'; // Because all invocations of this method share the same {@link RtfConverter}, we must make sure to
	    // disable the plugin added above. Otherwise, it will be applied in all subsequent conversions.

	    RtfConverter.disablePlugin(pluginName);
	    return html;
	  }
	  /**
	   * An inline token parser for use with the {@link iterator} Markdown-it plugin.
	   * This token parser adds a cta-type data attribute to any link it encounters.
	   */
	  ;

	  _proto._urlTransformer = function _urlTransformer(tokens, idx, targetConfig) {
	    targetConfig = targetConfig || {};
	    var target;

	    if (typeof targetConfig === 'string') {
	      target = targetConfig;
	    }

	    var href = tokens[idx].attrGet('href');
	    var ctaType;

	    if (startsWith$2(href).call(href, 'mailto')) {
	      ctaType = 'EMAIL';
	      target = target || targetConfig.email;
	    } else if (startsWith$2(href).call(href, 'tel')) {
	      ctaType = 'TAP_TO_CALL';
	      target = target || targetConfig.phone;
	    } else {
	      ctaType = 'VIEW_WEBSITE';
	      target = target || targetConfig.url;
	    }

	    tokens[idx].attrSet('data-cta-type', ctaType);
	    target && tokens[idx].attrSet('target', target);
	  }
	  /**
	   * A function that generates a unique UUID to serve as the name for a
	   * Markdown-it plugin.
	   *
	   * @returns {string} the UUID.
	   */
	  ;

	  _proto._generatePluginName = function _generatePluginName() {
	    function s4() {
	      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
	    }

	    return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
	  };

	  return RichTextFormatterImpl;
	}();

	var RichTextFormatter = new RichTextFormatterImpl();

	function isValidContext(context) {
	  // should be both valid JSON and a map
	  var parsed;

	  try {
	    parsed = JSON.parse(context);
	  } catch (e) {
	    return false;
	  }

	  if (!parsed) {
	    return false;
	  }

	  return typeof parsed === 'object' && !isArray$3(parsed);
	}

	/** @typedef {import('./core/services/errorreporterservice').default} ErrorReporterService */

	/** @typedef {import('./core/services/analyticsreporterservice').default} AnalyticsReporterService */

	/**
	 * @typedef Services
	 * @property {ErrorReporterService} errorReporterService
	 */

	var DEFAULTS = {
	  locale: LOCALE,
	  querySource: QUERY_SOURCE,
	  analyticsEventsEnabled: true
	};
	/**
	 * The main Answers interface
	 */

	var Answers = /*#__PURE__*/function () {
	  function Answers() {
	    if (!Answers.setInstance(this)) {
	      return Answers.getInstance();
	    }
	    /**
	     * A reference to the Component base class for custom
	     * components to extend
	     */


	    this.Component = Component;
	    /**
	     * A reference to the AnalyticsEvent base class for reporting
	     * custom analytics
	     */

	    this.AnalyticsEvent = AnalyticsEvent;
	    /**
	     * A reference to the FilterNodeFactory class for creating {@link FilterNode}s.
	     */

	    this.FilterNodeFactory = FilterNodeFactory;
	    /**
	     * A reference of the renderer to use for the components
	     * This is provided during initialization.
	     * @type {Renderer}
	     */

	    this.renderer = new Renderers.Handlebars();
	    /**
	     * A reference to the formatRichText function.
	     * @type {Function}
	     */

	    this.formatRichText = function (markdown, eventOptionsFieldName, targetConfig) {
	      return RichTextFormatter.format(markdown, eventOptionsFieldName, targetConfig);
	    };
	    /**
	     * A local reference to the component manager
	     * @type {ComponentManager}
	     */


	    this.components = ComponentManager.getInstance();
	    /**
	     * A local reference to the core api
	     * @type {Core}
	     */

	    this.core = null;
	    /**
	     * A callback function to invoke once the library is ready.
	     * Typically fired after templates are fetched from server for rendering.
	     */

	    this._onReady = function () {};
	    /**
	     * @type {boolean}
	     * @private
	     */


	    this._eligibleForAnalytics = false;
	    /**
	     * @type {Services}
	     * @private
	     */

	    this._services = null;
	    /**
	     * @type {AnalyticsReporterService}
	     * @private
	     */

	    this._analyticsReporterService = null;
	  }

	  Answers.setInstance = function setInstance(instance) {
	    if (!this.instance) {
	      this.instance = instance;
	      return true;
	    }

	    return false;
	  };

	  Answers.getInstance = function getInstance() {
	    return this.instance;
	  };

	  var _proto = Answers.prototype;

	  _proto._initStorage = function _initStorage(parsedConfig) {
	    var _this = this;

	    var storage = new Storage({
	      updateListener: function updateListener(data, url) {
	        if (parsedConfig.onStateChange) {
	          parsedConfig.onStateChange(fromEntries$2(data), url);
	        }
	      },
	      resetListener: function resetListener(data) {
	        var query = data.get(StorageKeys.QUERY);
	        var hasQuery = query || query === '';

	        _this.core.storage["delete"](StorageKeys.PERSISTED_LOCATION_RADIUS);

	        _this.core.storage["delete"](StorageKeys.PERSISTED_FILTER);

	        _this.core.storage["delete"](StorageKeys.PERSISTED_FACETS);

	        _this.core.storage["delete"](StorageKeys.SORT_BYS);

	        _this.core.filterRegistry.clearAllFilterNodes();

	        if (!hasQuery) {
	          _this.core.clearResults();
	        } else {
	          _this.core.storage.set(StorageKeys.QUERY_TRIGGER, QueryTriggers.QUERY_PARAMETER);
	        }

	        if (!data.get(StorageKeys.SEARCH_OFFSET)) {
	          _this.core.storage.set(StorageKeys.SEARCH_OFFSET, 0);
	        }

	        forEach$2(data).call(data, function (value, key) {
	          if (key === StorageKeys.QUERY) {
	            return;
	          }

	          var parsedValue = _this._parsePersistentStorageValue(key, value);

	          _this.core.storage.set(key, parsedValue);
	        });

	        _this.core.storage.set(StorageKeys.HISTORY_POP_STATE, data);

	        if (hasQuery) {
	          _this.core.storage.set(StorageKeys.QUERY, query);
	        }
	      },
	      persistedValueParser: this._parsePersistentStorageValue
	    });
	    storage.init(window.location.search);
	    storage.set(StorageKeys.SEARCH_CONFIG, parsedConfig.search);
	    storage.set(StorageKeys.VERTICAL_PAGES_CONFIG, parsedConfig.verticalPages);
	    storage.set(StorageKeys.LOCALE, parsedConfig.locale);
	    storage.set(StorageKeys.QUERY_SOURCE, parsedConfig.querySource); // Check if sessionsOptIn data is stored in the URL. If it is, prefer that over
	    // what is in parsedConfig.

	    var sessionOptIn = storage.get(StorageKeys.SESSIONS_OPT_IN);

	    if (!sessionOptIn) {
	      storage.set(StorageKeys.SESSIONS_OPT_IN, {
	        value: parsedConfig.sessionTrackingEnabled,
	        setDynamically: false
	      });
	    } else {
	      // If sessionsOptIn was stored in the URL, it was stored only as a string.
	      // Parse this value and add it back to storage.
	      storage.set(StorageKeys.SESSIONS_OPT_IN, {
	        value: /^true$/i.test(sessionOptIn),
	        setDynamically: true
	      });
	    }

	    parsedConfig.noResults && storage.set(StorageKeys.NO_RESULTS_CONFIG, parsedConfig.noResults);
	    var isSuggestQueryTrigger = storage.get(StorageKeys.QUERY_TRIGGER) === QueryTriggers.SUGGEST;

	    if (storage.has(StorageKeys.QUERY) && !isSuggestQueryTrigger) {
	      storage.set(StorageKeys.QUERY_TRIGGER, QueryTriggers.QUERY_PARAMETER);
	    }

	    var context = storage.get(StorageKeys.API_CONTEXT);

	    if (context && !isValidContext(context)) {
	      storage["delete"](StorageKeys.API_CONTEXT);
	      console.error("Context parameter \"" + context + "\" is invalid, omitting from the search.");
	    }

	    if (storage.get(StorageKeys.REFERRER_PAGE_URL) === undefined) {
	      storage.set(StorageKeys.REFERRER_PAGE_URL, urlWithoutQueryParamsAndHash(document.referrer));
	    }

	    return storage;
	  }
	  /**
	   * Initializes the SDK with the provided configuration. Note that before onReady
	   * is ever called, a check to the relevant Answers Status page is made.
	   *
	   * @param {Object} config The Answers configuration.
	   */
	  ;

	  _proto.init = function init(config) {
	    var _this2 = this;

	    window.performance.mark('yext.answers.initStart');
	    var parsedConfig = this.parseConfig(config);
	    this.validateConfig(parsedConfig);
	    parsedConfig.search = new SearchConfig(parsedConfig.search);
	    parsedConfig.verticalPages = new VerticalPagesConfig(parsedConfig.verticalPages);

	    var storage = this._initStorage(parsedConfig);

	    this._services = parsedConfig.mock ? getMockServices() : getServices(parsedConfig, storage);
	    this._eligibleForAnalytics = parsedConfig.businessId != null; // TODO(amullings): Initialize with other services

	    if (this._eligibleForAnalytics && parsedConfig.mock) {
	      this._analyticsReporterService = new NoopAnalyticsReporter();
	    } else if (this._eligibleForAnalytics) {
	      this._analyticsReporterService = new AnalyticsReporter(parsedConfig.experienceKey, parsedConfig.experienceVersion, parsedConfig.businessId, parsedConfig.analyticsEventsEnabled, parsedConfig.analyticsOptions, parsedConfig.environment); // listen to query id updates

	      storage.registerListener({
	        eventType: 'update',
	        storageKey: StorageKeys.QUERY_ID,
	        callback: function callback(id) {
	          return _this2._analyticsReporterService.setQueryId(id);
	        }
	      });
	      this.components.setAnalyticsReporter(this._analyticsReporterService);
	      initScrollListener(this._analyticsReporterService);
	    }

	    this.core = new Core({
	      apiKey: parsedConfig.apiKey,
	      storage: storage,
	      experienceKey: parsedConfig.experienceKey,
	      fieldFormatters: parsedConfig.fieldFormatters,
	      experienceVersion: parsedConfig.experienceVersion,
	      locale: parsedConfig.locale,
	      analyticsReporter: this._analyticsReporterService,
	      onVerticalSearch: parsedConfig.onVerticalSearch,
	      onUniversalSearch: parsedConfig.onUniversalSearch,
	      environment: parsedConfig.environment,
	      componentManager: this.components
	    });

	    if (parsedConfig.onStateChange && typeof parsedConfig.onStateChange === 'function') {
	      parsedConfig.onStateChange(fromEntries$2(storage.getAll()), this.core.storage.getCurrentStateUrlMerged());
	    }

	    this.components.setCore(this.core).setRenderer(this.renderer);

	    this._setDefaultInitialSearch(parsedConfig.search);

	    this.core.init();

	    this._onReady = parsedConfig.onReady || function () {};

	    var asyncDeps = this._loadAsyncDependencies(parsedConfig);

	    return asyncDeps["finally"](function () {
	      _this2._onReady();

	      if (!_this2.components.getActiveComponent(SearchComponent.type)) {
	        _this2._initQueryUpdateListener(parsedConfig.search);
	      }

	      _this2._searchOnLoad();
	    });
	  };

	  _proto._initQueryUpdateListener = function _initQueryUpdateListener(_ref) {
	    var verticalKey = _ref.verticalKey,
	        defaultInitialSearch = _ref.defaultInitialSearch;
	    var queryUpdateListener = new QueryUpdateListener(this.core, {
	      defaultInitialSearch: defaultInitialSearch,
	      verticalKey: verticalKey
	    });
	    this.core.setQueryUpdateListener(queryUpdateListener);
	  }
	  /**
	   * This guarantees that execution of the SearchBar's search on page load occurs only
	   * AFTER all components have been added to the page. Trying to do this with a regular
	   * onCreate relies on the SearchBar having some sort of async behavior to move the execution
	   * of the search to the end of the call stack. For instance, relying on promptForLocation
	   * being set to true, which adds additional Promises that will delay the exeuction.
	   *
	   * We need to guarantee that the searchOnLoad happens after the onReady, because certain
	   * components will update values in storage in their onMount/onCreate, which are then expected
	   * to be applied to this search on page load. For example, filter components can apply
	   * filters on page load, which must be applied before this search is made to affect it.
	   *
	   * If no special search components exist, we still want to search on load if a query has been set,
	   * either from a defaultInitialSearch or from a query in the URL.
	   */
	  ;

	  _proto._searchOnLoad = function _searchOnLoad() {
	    var _context;

	    var searchComponents = filter$2(_context = this.components._activeComponents).call(_context, function (c) {
	      return c.constructor.type === SearchComponent.type;
	    });

	    if (searchComponents.length) {
	      forEach$2(searchComponents).call(searchComponents, function (c) {
	        return c.searchAfterAnswersOnReady && c.searchAfterAnswersOnReady();
	      });
	    } else if (this.core.storage.has(StorageKeys.QUERY)) {
	      this.core.triggerSearch(this.core.storage.get(StorageKeys.QUERY_TRIGGER));
	    }
	  };

	  _proto._loadAsyncDependencies = function _loadAsyncDependencies(parsedConfig) {
	    var loadTemplates = this._loadTemplates(parsedConfig);

	    var ponyfillCssVariables = this._handlePonyfillCssVariables(parsedConfig.disableCssVariablesPonyfill);

	    return promise$3.all([loadTemplates, ponyfillCssVariables]);
	  };

	  _proto._loadTemplates = function _loadTemplates(_ref2) {
	    var _this3 = this;

	    var useTemplates = _ref2.useTemplates,
	        templateBundle = _ref2.templateBundle;

	    if (useTemplates === false || templateBundle) {
	      if (templateBundle) {
	        this.renderer.init(templateBundle, this._getInitLocale());
	        return promise$3.resolve();
	      }
	    } else {
	      // Templates are currently downloaded separately from the CORE and UI bundle.
	      // Future enhancement is to ship the components with templates in a separate bundle.
	      this.templates = new DefaultTemplatesLoader(function (templates) {
	        _this3.renderer.init(templates, _this3._getInitLocale());
	      });
	      return this.templates.fetchTemplates();
	    }
	  };

	  _proto.domReady = function domReady(cb) {
	    DOM.onReady(cb);
	  };

	  _proto.onReady = function onReady(cb) {
	    this._onReady = cb;
	    return this;
	  }
	  /**
	   * Parses the config provided by the user. In the parsed config, any options not supplied by the
	   * user are given default values.
	   * @param {Object} config The user supplied config.
	   */
	  ;

	  _proto.parseConfig = function parseConfig(config) {
	    var _context2;

	    var parsedConfig = _extends({}, DEFAULTS, config);

	    var sessionTrackingEnabled = true;

	    if (typeof config.sessionTrackingEnabled === 'boolean') {
	      sessionTrackingEnabled = config.sessionTrackingEnabled;
	    }

	    parsedConfig.sessionTrackingEnabled = sessionTrackingEnabled;
	    var sandboxPrefix = SANDBOX + "-";
	    includes$4(_context2 = parsedConfig.apiKey).call(_context2, sandboxPrefix) ? parsedConfig.environment = SANDBOX : parsedConfig.environment = PRODUCTION;
	    parsedConfig.apiKey = parsedConfig.apiKey.replace(sandboxPrefix, '');
	    return parsedConfig;
	  }
	  /**
	   * Validates the Answers config object to ensure things like api key and experience key are
	   * properly set.
	   * @param {Object} config The Answers config.
	   */
	  ;

	  _proto.validateConfig = function validateConfig(config) {
	    // TODO (tmeyer): Extract this method into it's own class. Investigate the use of JSON schema
	    // to validate these configs.
	    if (typeof config.apiKey !== 'string') {
	      throw new Error('Missing required `apiKey`. Type must be {string}');
	    }

	    if (typeof config.experienceKey !== 'string') {
	      throw new Error('Missing required `experienceKey`. Type must be {string}');
	    }

	    if (config.onVerticalSearch && typeof config.onVerticalSearch !== 'function') {
	      throw new Error('onVerticalSearch must be a function. Current type is: ' + typeof config.onVerticalSearch);
	    }

	    if (config.onUniversalSearch && typeof config.onUniversalSearch !== 'function') {
	      throw new Error('onUniversalSearch must be a function. Current type is: ' + typeof config.onUniversalSearch);
	    }
	  }
	  /**
	   * Register a custom component type so it can be created via
	   * addComponent and used as a child component
	   * @param {Component} componentClass
	   */
	  ;

	  _proto.registerComponentType = function registerComponentType(componentClass) {
	    this.components.register(componentClass);
	  };

	  _proto.addComponent = function addComponent(type, opts) {
	    if (typeof opts === 'string') {
	      opts = {
	        container: opts
	      };
	    }

	    try {
	      this.components.create(type, opts).mount();
	    } catch (e) {
	      console.error('Failed to add component', type, '\n\n', e);
	    }

	    return this;
	  }
	  /**
	   * Remove the component - and all of its children - with the given name
	   * @param {string} name The name of the component to remove
	   */
	  ;

	  _proto.removeComponent = function removeComponent(name) {
	    this.components.removeByName(name);
	  };

	  _proto.createComponent = function createComponent(opts) {
	    return this.components.create('Component', opts).mount();
	  }
	  /**
	   * Conducts a search in the Answers experience
	   *
	   * @param {string} query
	   */
	  ;

	  _proto.search = function search(query) {
	    this.core.storage.setWithPersist(StorageKeys.QUERY, query);
	  };

	  _proto.registerHelper = function registerHelper(name, cb) {
	    this.renderer.registerHelper(name, cb);
	    return this;
	  }
	  /**
	   * Compile and add a template to the current renderer
	   * @param {string} templateName The unique name for the template
	   * @param {string} template The handlebars template string
	   */
	  ;

	  _proto.registerTemplate = function registerTemplate(templateName, template) {
	    this.renderer.registerTemplate(templateName, template);
	  }
	  /**
	   * Opt in or out of analytic events
	   * @param {boolean} analyticsEventsEnabled
	   */
	  ;

	  _proto.setAnalyticsOptIn = function setAnalyticsOptIn(analyticsEventsEnabled) {
	    this._analyticsReporterService.setAnalyticsOptIn(analyticsEventsEnabled);
	  }
	  /**
	   * Opt in or out of convertion tracking analytics
	   * @param {boolean} optIn
	   */
	  ;

	  _proto.setConversionsOptIn = function setConversionsOptIn(optIn) {
	    if (this._eligibleForAnalytics) {
	      this._analyticsReporterService.setConversionTrackingEnabled(optIn);
	    }
	  }
	  /**
	   * Opt in or out of session cookies
	   * @param {boolean} optIn
	   */
	  ;

	  _proto.setSessionsOptIn = function setSessionsOptIn(optIn) {
	    this.core.storage.set(StorageKeys.SESSIONS_OPT_IN, {
	      value: optIn,
	      setDynamically: true
	    });
	  }
	  /**
	   * Sets a search query on initialization for vertical searchers that have a
	   * defaultInitialSearch provided, if the user hasn't already provided their
	   * own via URL param. A default initial search should not be persisted in the URL,
	   * so we do a regular set instead of a setWithPersist here.
	   *
	   * @param {SearchConfig} searchConfig
	   * @private
	   */
	  ;

	  _proto._setDefaultInitialSearch = function _setDefaultInitialSearch(searchConfig) {
	    if (searchConfig.defaultInitialSearch == null) {
	      return;
	    }

	    var prepopulatedQuery = this.core.storage.get(StorageKeys.QUERY);

	    if (prepopulatedQuery != null) {
	      return;
	    }

	    this.core.storage.set(StorageKeys.QUERY_TRIGGER, QueryTriggers.INITIALIZE);
	    this.core.storage.set(StorageKeys.QUERY, searchConfig.defaultInitialSearch);
	  }
	  /**
	   * Sets the geolocation tag in storage, overriding other inputs. Do not use in conjunction
	   * with other components that will set the geolocation internally.
	   * @param {number} lat
	   * @param {number} long
	   */
	  ;

	  _proto.setGeolocation = function setGeolocation(lat, lng) {
	    this.core.storage.set(StorageKeys.GEOLOCATION, {
	      lat: lat,
	      lng: lng,
	      radius: 0
	    });
	  }
	  /**
	   * A promise that resolves when ponyfillCssVariables resolves,
	   * or resolves immediately if ponyfill is disabled
	   * @param {boolean} option to opt out of the css variables ponyfill
	   * @return {Promise} resolves after ponyfillCssVariables, or immediately if disabled
	   */
	  ;

	  _proto._handlePonyfillCssVariables = function _handlePonyfillCssVariables(ponyfillDisabled) {
	    var _this4 = this;

	    window.performance.mark('yext.answers.ponyfillStart');

	    if (ponyfillDisabled) {
	      window.performance.mark('yext.answers.ponyfillEnd');
	      return promise$3.resolve();
	    }

	    return new promise$3(function (resolve, reject) {
	      _this4.ponyfillCssVariables({
	        onFinally: function onFinally() {
	          window.performance.mark('yext.answers.ponyfillEnd');
	          resolve();
	        }
	      });
	    });
	  }
	  /*
	   * Updates the css styles with new current variables. This is useful when the css
	   * variables are updated dynamically (e.g. through js) or if the css variables are
	   * added after the ANSWERS.init
	   *
	   * To solve issues with non-zero max-age cache controls for link/script assets in IE11,
	   * we add a cache busting parameter so that XMLHttpRequests succeed.
	   *
	   * @param {Object} config Additional config to pass to the ponyfill
	   */
	  ;

	  _proto.ponyfillCssVariables = function ponyfillCssVariables(config) {
	    if (config === void 0) {
	      config = {};
	    }

	    cssVars({
	      onlyLegacy: true,
	      onError: config.onError || function () {},
	      onSuccess: config.onSuccess || function () {},
	      onFinally: config.onFinally || function () {},
	      onBeforeSend: function onBeforeSend(xhr, node, url) {
	        try {
	          var uriWithCacheBust = new url$2(url);
	          var params = new SearchParams(uriWithCacheBust.search);
	          params.set('_', new Date().getTime());
	          uriWithCacheBust.search = params.toString();
	          xhr.open('GET', uriWithCacheBust.toString());
	        } catch (e) {// Catch the error and continue if the URL provided in the asset is not a valid URL
	        }
	      }
	    });
	  }
	  /*
	   * Adds context as a parameter for the query API calls.
	   * @param {Object} context The context object passed in the API calls
	   */
	  ;

	  _proto.setContext = function setContext(context) {
	    var contextString = stringify$2(context);

	    if (!isValidContext(contextString)) {
	      console.error("Context parameter \"" + context + "\" is invalid, omitting from the search.");
	      return;
	    }

	    this.core.storage.set(StorageKeys.API_CONTEXT, contextString);
	  }
	  /**
	   * Processes a translation which includes performing interpolation, pluralization, or
	   * both
	   * @param {string | Object} translations The translation, or an object containing
	   * translated plural forms
	   * @param {Object} interpolationParams Params to use during interpolation
	   * @param {number} count The count associated with the pluralization
	   * @param {string} language The langauge associated with the pluralization
	   * @returns {string} The translation with any interpolation or pluralization applied
	   */
	  ;

	  _proto.processTranslation = function processTranslation(translations, interpolationParams, count, language) {
	    var _context3;

	    var initLocale = this._getInitLocale();

	    language = language || initLocale.substring(0, 2);

	    if (!this.renderer) {
	      console.error('The renderer must be initialized before translations can be processed');
	      return '';
	    }

	    var escapeExpression = bind$2(_context3 = this.renderer.escapeExpression).call(_context3, this.renderer);

	    return TranslationProcessor.process(translations, interpolationParams, count, language, escapeExpression);
	  }
	  /**
	   * Gets the locale that ANSWERS was initialized to
	   *
	   * @returns {string}
	   */
	  ;

	  _proto._getInitLocale = function _getInitLocale() {
	    return this.core.storage.get(StorageKeys.LOCALE);
	  }
	  /**
	   * Parses a value from persistent storage, which stores strings,
	   * into the shape the SDK expects.
	   * TODO(SLAP-1111): Move this into a dedicated file/class.
	   *
	   * @param {string} key
	   * @param {string} value
	   * @returns {string|number|Filter}
	   */
	  ;

	  _proto._parsePersistentStorageValue = function _parsePersistentStorageValue(key, value) {
	    switch (key) {
	      case StorageKeys.PERSISTED_FILTER:
	        return Filter.from(JSON.parse(value));

	      case StorageKeys.PERSISTED_LOCATION_RADIUS:
	        return _parseFloat$2(value);

	      case StorageKeys.PERSISTED_FACETS:
	      case StorageKeys.SORT_BYS:
	        return JSON.parse(value);

	      default:
	        return value;
	    }
	  };

	  return Answers;
	}();
	/**
	 * @param {Object} config
	 * @param {Storage} storage
	 * @returns {Services}
	 */


	function getServices(config, storage) {
	  return {
	    errorReporterService: new ErrorReporter({
	      apiKey: config.apiKey,
	      experienceKey: config.experienceKey,
	      experienceVersion: config.experienceVersion,
	      printVerbose: config.debug,
	      sendToServer: !config.suppressErrorReports,
	      environment: config.environment
	    }, storage)
	  };
	}
	/**
	 * @returns {Services}
	 */


	function getMockServices() {
	  return {
	    errorReporterService: new ConsoleErrorReporter()
	  };
	}
	/**
	 * Initialize the scroll event listener to send analytics events
	 * when the user scrolls to the bottom. Debounces scroll events so
	 * they are processed after the user stops scrolling
	 */


	function initScrollListener(reporter) {
	  var DEBOUNCE_TIME = 100;
	  var timeout = null;

	  var sendEvent = function sendEvent() {
	    if (window.innerHeight + window.pageYOffset >= document.body.scrollHeight) {
	      var event = new AnalyticsEvent('SCROLL_TO_BOTTOM_OF_PAGE');

	      if (reporter.getQueryId()) {
	        reporter.report(event);
	      }
	    }
	  };

	  document.addEventListener('scroll', function () {
	    clearTimeout(timeout);
	    timeout = setTimeout$2(sendEvent, DEBOUNCE_TIME);
	  });
	}

	var ANSWERS$1 = new Answers();

	return ANSWERS$1;

}());
